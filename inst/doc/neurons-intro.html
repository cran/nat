<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Gregory Jefferis" />

<meta name="date" content="2023-01-28" />

<title>Introduction to neurons and neuronlists</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>(function() {
  // If window.HTMLWidgets is already defined, then use it; otherwise create a
  // new object. This allows preceding code to set options that affect the
  // initialization process (though none currently exist).
  window.HTMLWidgets = window.HTMLWidgets || {};

  // See if we're running in a viewer pane. If not, we're in a web browser.
  var viewerMode = window.HTMLWidgets.viewerMode =
      /\bviewer_pane=1\b/.test(window.location);

  // See if we're running in Shiny mode. If not, it's a static document.
  // Note that static widgets can appear in both Shiny and static modes, but
  // obviously, Shiny widgets can only appear in Shiny apps/documents.
  var shinyMode = window.HTMLWidgets.shinyMode =
      typeof(window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

  // We can't count on jQuery being available, so we implement our own
  // version if necessary.
  function querySelectorAll(scope, selector) {
    if (typeof(jQuery) !== "undefined" && scope instanceof jQuery) {
      return scope.find(selector);
    }
    if (scope.querySelectorAll) {
      return scope.querySelectorAll(selector);
    }
  }

  function asArray(value) {
    if (value === null)
      return [];
    if ($.isArray(value))
      return value;
    return [value];
  }

  // Implement jQuery's extend
  function extend(target /*, ... */) {
    if (arguments.length == 1) {
      return target;
    }
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
    return target;
  }

  // IE8 doesn't support Array.forEach.
  function forEach(values, callback, thisArg) {
    if (values.forEach) {
      values.forEach(callback, thisArg);
    } else {
      for (var i = 0; i < values.length; i++) {
        callback.call(thisArg, values[i], i, values);
      }
    }
  }

  // Replaces the specified method with the return value of funcSource.
  //
  // Note that funcSource should not BE the new method, it should be a function
  // that RETURNS the new method. funcSource receives a single argument that is
  // the overridden method, it can be called from the new method. The overridden
  // method can be called like a regular function, it has the target permanently
  // bound to it so "this" will work correctly.
  function overrideMethod(target, methodName, funcSource) {
    var superFunc = target[methodName] || function() {};
    var superFuncBound = function() {
      return superFunc.apply(target, arguments);
    };
    target[methodName] = funcSource(superFuncBound);
  }

  // Add a method to delegator that, when invoked, calls
  // delegatee.methodName. If there is no such method on
  // the delegatee, but there was one on delegator before
  // delegateMethod was called, then the original version
  // is invoked instead.
  // For example:
  //
  // var a = {
  //   method1: function() { console.log('a1'); }
  //   method2: function() { console.log('a2'); }
  // };
  // var b = {
  //   method1: function() { console.log('b1'); }
  // };
  // delegateMethod(a, b, "method1");
  // delegateMethod(a, b, "method2");
  // a.method1();
  // a.method2();
  //
  // The output would be "b1", "a2".
  function delegateMethod(delegator, delegatee, methodName) {
    var inherited = delegator[methodName];
    delegator[methodName] = function() {
      var target = delegatee;
      var method = delegatee[methodName];

      // The method doesn't exist on the delegatee. Instead,
      // call the method on the delegator, if it exists.
      if (!method) {
        target = delegator;
        method = inherited;
      }

      if (method) {
        return method.apply(target, arguments);
      }
    };
  }

  // Implement a vague facsimilie of jQuery's data method
  function elementData(el, name, value) {
    if (arguments.length == 2) {
      return el["htmlwidget_data_" + name];
    } else if (arguments.length == 3) {
      el["htmlwidget_data_" + name] = value;
      return el;
    } else {
      throw new Error("Wrong number of arguments for elementData: " +
        arguments.length);
    }
  }

  // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
  function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
  }

  function hasClass(el, className) {
    var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
    return re.test(el.className);
  }

  // elements - array (or array-like object) of HTML elements
  // className - class name to test for
  // include - if true, only return elements with given className;
  //   if false, only return elements *without* given className
  function filterByClass(elements, className, include) {
    var results = [];
    for (var i = 0; i < elements.length; i++) {
      if (hasClass(elements[i], className) == include)
        results.push(elements[i]);
    }
    return results;
  }

  function on(obj, eventName, func) {
    if (obj.addEventListener) {
      obj.addEventListener(eventName, func, false);
    } else if (obj.attachEvent) {
      obj.attachEvent(eventName, func);
    }
  }

  function off(obj, eventName, func) {
    if (obj.removeEventListener)
      obj.removeEventListener(eventName, func, false);
    else if (obj.detachEvent) {
      obj.detachEvent(eventName, func);
    }
  }

  // Translate array of values to top/right/bottom/left, as usual with
  // the "padding" CSS property
  // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
  function unpackPadding(value) {
    if (typeof(value) === "number")
      value = [value];
    if (value.length === 1) {
      return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
    }
    if (value.length === 2) {
      return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
    }
    if (value.length === 3) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
    }
    if (value.length === 4) {
      return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
    }
  }

  // Convert an unpacked padding object to a CSS value
  function paddingToCss(paddingObj) {
    return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px " + paddingObj.left + "px";
  }

  // Makes a number suitable for CSS
  function px(x) {
    if (typeof(x) === "number")
      return x + "px";
    else
      return x;
  }

  // Retrieves runtime widget sizing information for an element.
  // The return value is either null, or an object with fill, padding,
  // defaultWidth, defaultHeight fields.
  function sizingPolicy(el) {
    var sizingEl = document.querySelector("script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
    if (!sizingEl)
      return null;
    var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
    if (viewerMode) {
      return sp.viewer;
    } else {
      return sp.browser;
    }
  }

  // @param tasks Array of strings (or falsy value, in which case no-op).
  //   Each element must be a valid JavaScript expression that yields a
  //   function. Or, can be an array of objects with "code" and "data"
  //   properties; in this case, the "code" property should be a string
  //   of JS that's an expr that yields a function, and "data" should be
  //   an object that will be added as an additional argument when that
  //   function is called.
  // @param target The object that will be "this" for each function
  //   execution.
  // @param args Array of arguments to be passed to the functions. (The
  //   same arguments will be passed to all functions.)
  function evalAndRun(tasks, target, args) {
    if (tasks) {
      forEach(tasks, function(task) {
        var theseArgs = args;
        if (typeof(task) === "object") {
          theseArgs = theseArgs.concat([task.data]);
          task = task.code;
        }
        var taskFunc = tryEval(task);
        if (typeof(taskFunc) !== "function") {
          throw new Error("Task must be a function! Source:\n" + task);
        }
        taskFunc.apply(target, theseArgs);
      });
    }
  }

  // Attempt eval() both with and without enclosing in parentheses.
  // Note that enclosing coerces a function declaration into
  // an expression that eval() can parse
  // (otherwise, a SyntaxError is thrown)
  function tryEval(code) {
    var result = null;
    try {
      result = eval("(" + code + ")");
    } catch(error) {
      if (!(error instanceof SyntaxError)) {
        throw error;
      }
      try {
        result = eval(code);
      } catch(e) {
        if (e instanceof SyntaxError) {
          throw error;
        } else {
          throw e;
        }
      }
    }
    return result;
  }

  function initSizing(el) {
    var sizing = sizingPolicy(el);
    if (!sizing)
      return;

    var cel = document.getElementById("htmlwidget_container");
    if (!cel)
      return;

    if (typeof(sizing.padding) !== "undefined") {
      document.body.style.margin = "0";
      document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
    }

    if (sizing.fill) {
      document.body.style.overflow = "hidden";
      document.body.style.width = "100%";
      document.body.style.height = "100%";
      document.documentElement.style.width = "100%";
      document.documentElement.style.height = "100%";
      cel.style.position = "absolute";
      var pad = unpackPadding(sizing.padding);
      cel.style.top = pad.top + "px";
      cel.style.right = pad.right + "px";
      cel.style.bottom = pad.bottom + "px";
      cel.style.left = pad.left + "px";
      el.style.width = "100%";
      el.style.height = "100%";

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };

    } else {
      el.style.width = px(sizing.width);
      el.style.height = px(sizing.height);

      return {
        getWidth: function() { return cel.getBoundingClientRect().width; },
        getHeight: function() { return cel.getBoundingClientRect().height; }
      };
    }
  }

  // Default implementations for methods
  var defaults = {
    find: function(scope) {
      return querySelectorAll(scope, "." + this.name);
    },
    renderError: function(el, err) {
      var $el = $(el);

      this.clearError(el);

      // Add all these error classes, as Shiny does
      var errClass = "shiny-output-error";
      if (err.type !== null) {
        // use the classes of the error condition as CSS class names
        errClass = errClass + " " + $.map(asArray(err.type), function(type) {
          return errClass + "-" + type;
        }).join(" ");
      }
      errClass = errClass + " htmlwidgets-error";

      // Is el inline or block? If inline or inline-block, just display:none it
      // and add an inline error.
      var display = $el.css("display");
      $el.data("restore-display-mode", display);

      if (display === "inline" || display === "inline-block") {
        $el.hide();
        if (err.message !== "") {
          var errorSpan = $("<span>").addClass(errClass);
          errorSpan.text(err.message);
          $el.after(errorSpan);
        }
      } else if (display === "block") {
        // If block, add an error just after the el, set visibility:none on the
        // el, and position the error to be on top of the el.
        // Mark it with a unique ID and CSS class so we can remove it later.
        $el.css("visibility", "hidden");
        if (err.message !== "") {
          var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
            .css("top", el.offsetTop)
            .css("left", el.offsetLeft)
            // setting width can push out the page size, forcing otherwise
            // unnecessary scrollbars to appear and making it impossible for
            // the element to shrink; so use max-width instead
            .css("maxWidth", el.offsetWidth)
            .css("height", el.offsetHeight);
          errorDiv.text(err.message);
          $el.after(errorDiv);

          // Really dumb way to keep the size/position of the error in sync with
          // the parent element as the window is resized or whatever.
          var intId = setInterval(function() {
            if (!errorDiv[0].parentElement) {
              clearInterval(intId);
              return;
            }
            errorDiv
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
          }, 500);
        }
      }
    },
    clearError: function(el) {
      var $el = $(el);
      var display = $el.data("restore-display-mode");
      $el.data("restore-display-mode", null);

      if (display === "inline" || display === "inline-block") {
        if (display)
          $el.css("display", display);
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      } else if (display === "block"){
        $el.css("visibility", "inherit");
        $(el.nextSibling).filter(".htmlwidgets-error").remove();
      }
    },
    sizing: {}
  };

  // Called by widget bindings to register a new type of widget. The definition
  // object can contain the following properties:
  // - name (required) - A string indicating the binding name, which will be
  //   used by default as the CSS classname to look for.
  // - initialize (optional) - A function(el) that will be called once per
  //   widget element; if a value is returned, it will be passed as the third
  //   value to renderValue.
  // - renderValue (required) - A function(el, data, initValue) that will be
  //   called with data. Static contexts will cause this to be called once per
  //   element; Shiny apps will cause this to be called multiple times per
  //   element, as the data changes.
  window.HTMLWidgets.widget = function(definition) {
    if (!definition.name) {
      throw new Error("Widget must have a name");
    }
    if (!definition.type) {
      throw new Error("Widget must have a type");
    }
    // Currently we only support output widgets
    if (definition.type !== "output") {
      throw new Error("Unrecognized widget type '" + definition.type + "'");
    }
    // TODO: Verify that .name is a valid CSS classname

    // Support new-style instance-bound definitions. Old-style class-bound
    // definitions have one widget "object" per widget per type/class of
    // widget; the renderValue and resize methods on such widget objects
    // take el and instance arguments, because the widget object can't
    // store them. New-style instance-bound definitions have one widget
    // object per widget instance; the definition that's passed in doesn't
    // provide renderValue or resize methods at all, just the single method
    //   factory(el, width, height)
    // which returns an object that has renderValue(x) and resize(w, h).
    // This enables a far more natural programming style for the widget
    // author, who can store per-instance state using either OO-style
    // instance fields or functional-style closure variables (I guess this
    // is in contrast to what can only be called C-style pseudo-OO which is
    // what we required before).
    if (definition.factory) {
      definition = createLegacyDefinitionAdapter(definition);
    }

    if (!definition.renderValue) {
      throw new Error("Widget must have a renderValue function");
    }

    // For static rendering (non-Shiny), use a simple widget registration
    // scheme. We also use this scheme for Shiny apps/documents that also
    // contain static widgets.
    window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
    // Merge defaults into the definition; don't mutate the original definition.
    var staticBinding = extend({}, defaults, definition);
    overrideMethod(staticBinding, "find", function(superfunc) {
      return function(scope) {
        var results = superfunc(scope);
        // Filter out Shiny outputs, we only want the static kind
        return filterByClass(results, "html-widget-output", false);
      };
    });
    window.HTMLWidgets.widgets.push(staticBinding);

    if (shinyMode) {
      // Shiny is running. Register the definition with an output binding.
      // The definition itself will not be the output binding, instead
      // we will make an output binding object that delegates to the
      // definition. This is because we foolishly used the same method
      // name (renderValue) for htmlwidgets definition and Shiny bindings
      // but they actually have quite different semantics (the Shiny
      // bindings receive data that includes lots of metadata that it
      // strips off before calling htmlwidgets renderValue). We can't
      // just ignore the difference because in some widgets it's helpful
      // to call this.renderValue() from inside of resize(), and if
      // we're not delegating, then that call will go to the Shiny
      // version instead of the htmlwidgets version.

      // Merge defaults with definition, without mutating either.
      var bindingDef = extend({}, defaults, definition);

      // This object will be our actual Shiny binding.
      var shinyBinding = new Shiny.OutputBinding();

      // With a few exceptions, we'll want to simply use the bindingDef's
      // version of methods if they are available, otherwise fall back to
      // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
      // methods in the future, and we want them to be overrideable by
      // HTMLWidget binding definitions, then we'll need to add them to this
      // list.
      delegateMethod(shinyBinding, bindingDef, "getId");
      delegateMethod(shinyBinding, bindingDef, "onValueChange");
      delegateMethod(shinyBinding, bindingDef, "onValueError");
      delegateMethod(shinyBinding, bindingDef, "renderError");
      delegateMethod(shinyBinding, bindingDef, "clearError");
      delegateMethod(shinyBinding, bindingDef, "showProgress");

      // The find, renderValue, and resize are handled differently, because we
      // want to actually decorate the behavior of the bindingDef methods.

      shinyBinding.find = function(scope) {
        var results = bindingDef.find(scope);

        // Only return elements that are Shiny outputs, not static ones
        var dynamicResults = results.filter(".html-widget-output");

        // It's possible that whatever caused Shiny to think there might be
        // new dynamic outputs, also caused there to be new static outputs.
        // Since there might be lots of different htmlwidgets bindings, we
        // schedule execution for later--no need to staticRender multiple
        // times.
        if (results.length !== dynamicResults.length)
          scheduleStaticRender();

        return dynamicResults;
      };

      // Wrap renderValue to handle initialization, which unfortunately isn't
      // supported natively by Shiny at the time of this writing.

      shinyBinding.renderValue = function(el, data) {
        Shiny.renderDependencies(data.deps);
        // Resolve strings marked as javascript literals to objects
        if (!(data.evals instanceof Array)) data.evals = [data.evals];
        for (var i = 0; data.evals && i < data.evals.length; i++) {
          window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
        }
        if (!bindingDef.renderOnNullValue) {
          if (data.x === null) {
            el.style.visibility = "hidden";
            return;
          } else {
            el.style.visibility = "inherit";
          }
        }
        if (!elementData(el, "initialized")) {
          initSizing(el);

          elementData(el, "initialized", true);
          if (bindingDef.initialize) {
            var rect = el.getBoundingClientRect();
            var result = bindingDef.initialize(el, rect.width, rect.height);
            elementData(el, "init_result", result);
          }
        }
        bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
        evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
      };

      // Only override resize if bindingDef implements it
      if (bindingDef.resize) {
        shinyBinding.resize = function(el, width, height) {
          // Shiny can call resize before initialize/renderValue have been
          // called, which doesn't make sense for widgets.
          if (elementData(el, "initialized")) {
            bindingDef.resize(el, width, height, elementData(el, "init_result"));
          }
        };
      }

      Shiny.outputBindings.register(shinyBinding, bindingDef.name);
    }
  };

  var scheduleStaticRenderTimerId = null;
  function scheduleStaticRender() {
    if (!scheduleStaticRenderTimerId) {
      scheduleStaticRenderTimerId = setTimeout(function() {
        scheduleStaticRenderTimerId = null;
        window.HTMLWidgets.staticRender();
      }, 1);
    }
  }

  // Render static widgets after the document finishes loading
  // Statically render all elements that are of this widget's class
  window.HTMLWidgets.staticRender = function() {
    var bindings = window.HTMLWidgets.widgets || [];
    forEach(bindings, function(binding) {
      var matches = binding.find(document.documentElement);
      forEach(matches, function(el) {
        var sizeObj = initSizing(el, binding);

        var getSize = function(el) {
          if (sizeObj) {
            return {w: sizeObj.getWidth(), h: sizeObj.getHeight()}
          } else {
            var rect = el.getBoundingClientRect();
            return {w: rect.width, h: rect.height}
          }
        };

        if (hasClass(el, "html-widget-static-bound"))
          return;
        el.className = el.className + " html-widget-static-bound";

        var initResult;
        if (binding.initialize) {
          var size = getSize(el);
          initResult = binding.initialize(el, size.w, size.h);
          elementData(el, "init_result", initResult);
        }

        if (binding.resize) {
          var lastSize = getSize(el);
          var resizeHandler = function(e) {
            var size = getSize(el);
            if (size.w === 0 && size.h === 0)
              return;
            if (size.w === lastSize.w && size.h === lastSize.h)
              return;
            lastSize = size;
            binding.resize(el, size.w, size.h, initResult);
          };

          on(window, "resize", resizeHandler);

          // This is needed for cases where we're running in a Shiny
          // app, but the widget itself is not a Shiny output, but
          // rather a simple static widget. One example of this is
          // an rmarkdown document that has runtime:shiny and widget
          // that isn't in a render function. Shiny only knows to
          // call resize handlers for Shiny outputs, not for static
          // widgets, so we do it ourselves.
          if (window.jQuery) {
            window.jQuery(document).on(
              "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
              resizeHandler
            );
            window.jQuery(document).on(
              "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
              resizeHandler
            );
          }

          // This is needed for the specific case of ioslides, which
          // flips slides between display:none and display:block.
          // Ideally we would not have to have ioslide-specific code
          // here, but rather have ioslides raise a generic event,
          // but the rmarkdown package just went to CRAN so the
          // window to getting that fixed may be long.
          if (window.addEventListener) {
            // It's OK to limit this to window.addEventListener
            // browsers because ioslides itself only supports
            // such browsers.
            on(document, "slideenter", resizeHandler);
            on(document, "slideleave", resizeHandler);
          }
        }

        var scriptData = document.querySelector("script[data-for='" + el.id + "'][type='application/json']");
        if (scriptData) {
          var data = JSON.parse(scriptData.textContent || scriptData.text);
          // Resolve strings marked as javascript literals to objects
          if (!(data.evals instanceof Array)) data.evals = [data.evals];
          for (var k = 0; data.evals && k < data.evals.length; k++) {
            window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
          }
          binding.renderValue(el, data.x, initResult);
          evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
        }
      });
    });

    invokePostRenderHandlers();
  }


  function has_jQuery3() {
    if (!window.jQuery) {
      return false;
    }
    var $version = window.jQuery.fn.jquery;
    var $major_version = parseInt($version.split(".")[0]);
    return $major_version >= 3;
  }

  /*
  / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
  / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
  / really means $(setTimeout(fn)).
  / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
  /
  / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
  / one tick later than it did before, which means staticRender() is
  / called renderValue() earlier than (advanced) widget authors might be expecting.
  / https://github.com/rstudio/shiny/issues/2630
  /
  / For a concrete example, leaflet has some methods (e.g., updateBounds)
  / which reference Shiny methods registered in initShiny (e.g., setInputValue).
  / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
  / delay execution of those methods (until Shiny methods are ready)
  / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
  /
  / Ideally widget authors wouldn't need to use this setTimeout() hack that
  / leaflet uses to call Shiny methods on a staticRender(). In the long run,
  / the logic initShiny should be broken up so that method registration happens
  / right away, but binding happens later.
  */
  function maybeStaticRenderLater() {
    if (shinyMode && has_jQuery3()) {
      window.jQuery(window.HTMLWidgets.staticRender);
    } else {
      window.HTMLWidgets.staticRender();
    }
  }

  if (document.addEventListener) {
    document.addEventListener("DOMContentLoaded", function() {
      document.removeEventListener("DOMContentLoaded", arguments.callee, false);
      maybeStaticRenderLater();
    }, false);
  } else if (document.attachEvent) {
    document.attachEvent("onreadystatechange", function() {
      if (document.readyState === "complete") {
        document.detachEvent("onreadystatechange", arguments.callee);
        maybeStaticRenderLater();
      }
    });
  }


  window.HTMLWidgets.getAttachmentUrl = function(depname, key) {
    // If no key, default to the first item
    if (typeof(key) === "undefined")
      key = 1;

    var link = document.getElementById(depname + "-" + key + "-attachment");
    if (!link) {
      throw new Error("Attachment " + depname + "/" + key + " not found in document");
    }
    return link.getAttribute("href");
  };

  window.HTMLWidgets.dataframeToD3 = function(df) {
    var names = [];
    var length;
    for (var name in df) {
        if (df.hasOwnProperty(name))
            names.push(name);
        if (typeof(df[name]) !== "object" || typeof(df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
        } else if (typeof(length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
        }
        length = df[name].length;
    }
    var results = [];
    var item;
    for (var row = 0; row < length; row++) {
        item = {};
        for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
        }
        results.push(item);
    }
    return results;
  };

  window.HTMLWidgets.transposeArray2D = function(array) {
      if (array.length === 0) return array;
      var newArray = array[0].map(function(col, i) {
          return array.map(function(row) {
              return row[i]
          })
      });
      return newArray;
  };
  // Split value at splitChar, but allow splitChar to be escaped
  // using escapeChar. Any other characters escaped by escapeChar
  // will be included as usual (including escapeChar itself).
  function splitWithEscape(value, splitChar, escapeChar) {
    var results = [];
    var escapeMode = false;
    var currentResult = "";
    for (var pos = 0; pos < value.length; pos++) {
      if (!escapeMode) {
        if (value[pos] === splitChar) {
          results.push(currentResult);
          currentResult = "";
        } else if (value[pos] === escapeChar) {
          escapeMode = true;
        } else {
          currentResult += value[pos];
        }
      } else {
        currentResult += value[pos];
        escapeMode = false;
      }
    }
    if (currentResult !== "") {
      results.push(currentResult);
    }
    return results;
  }
  // Function authored by Yihui/JJ Allaire
  window.HTMLWidgets.evaluateStringMember = function(o, member) {
    var parts = splitWithEscape(member, '.', '\\');
    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i];
      // part may be a character or 'numeric' member name
      if (o !== null && typeof o === "object" && part in o) {
        if (i == (l - 1)) { // if we are at the end of the line then evalulate
          if (typeof o[part] === "string")
            o[part] = tryEval(o[part]);
        } else { // otherwise continue to next embedded object
          o = o[part];
        }
      }
    }
  };

  // Retrieve the HTMLWidget instance (i.e. the return value of an
  // HTMLWidget binding's initialize() or factory() function)
  // associated with an element, or null if none.
  window.HTMLWidgets.getInstance = function(el) {
    return elementData(el, "init_result");
  };

  // Finds the first element in the scope that matches the selector,
  // and returns the HTMLWidget instance (i.e. the return value of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with that element, if any. If no element matches the
  // selector, or the first matching element has no HTMLWidget
  // instance associated with it, then null is returned.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.find = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var el = scope.querySelector(selector);
    if (el === null) {
      return null;
    } else {
      return window.HTMLWidgets.getInstance(el);
    }
  };

  // Finds all elements in the scope that match the selector, and
  // returns the HTMLWidget instances (i.e. the return values of
  // an HTMLWidget binding's initialize() or factory() function)
  // associated with the elements, in an array. If elements that
  // match the selector don't have an associated HTMLWidget
  // instance, the returned array will contain nulls.
  //
  // The scope argument is optional, and defaults to window.document.
  window.HTMLWidgets.findAll = function(scope, selector) {
    if (arguments.length == 1) {
      selector = scope;
      scope = document;
    }

    var nodes = scope.querySelectorAll(selector);
    var results = [];
    for (var i = 0; i < nodes.length; i++) {
      results.push(window.HTMLWidgets.getInstance(nodes[i]));
    }
    return results;
  };

  var postRenderHandlers = [];
  function invokePostRenderHandlers() {
    while (postRenderHandlers.length) {
      var handler = postRenderHandlers.shift();
      if (handler) {
        handler();
      }
    }
  }

  // Register the given callback function to be invoked after the
  // next time static widgets are rendered.
  window.HTMLWidgets.addPostRenderHandler = function(callback) {
    postRenderHandlers.push(callback);
  };

  // Takes a new-style instance-bound definition, and returns an
  // old-style class-bound definition. This saves us from having
  // to rewrite all the logic in this file to accomodate both
  // types of definitions.
  function createLegacyDefinitionAdapter(defn) {
    var result = {
      name: defn.name,
      type: defn.type,
      initialize: function(el, width, height) {
        return defn.factory(el, width, height);
      },
      renderValue: function(el, x, instance) {
        return instance.renderValue(x);
      },
      resize: function(el, width, height, instance) {
        return instance.resize(width, height);
      }
    };

    if (defn.find)
      result.find = defn.find;
    if (defn.renderError)
      result.renderError = defn.renderError;
    if (defn.clearError)
      result.clearError = defn.clearError;

    return result;
  }
})();
</script>
<script>/* el is the div, holding the rgl object as el.rglinstance,
     which holds x as el.rglinstance.scene
   x is the JSON encoded rglwidget.
*/


HTMLWidgets.widget({

  name: 'rglWebGL',

  type: 'output',

  factory: function(el, width, height) {
    el.width = width;
    el.height = height;
    var rgl = new rglwidgetClass(),
        onchangeselection = function(e) {
          for (var i = 0; i < rgl.scene.crosstalk.sel_handle.length; i++)
            rgl.clearBrush(except = e.rglSubsceneId);
          rgl.selection(e, false);
        },
        onchangefilter = function(e) {
          rgl.selection(e, true);
        };
    
    return { 
      renderValue: function(x) {
        var i, pel, player, groups,
            inShiny = (typeof Shiny !== "undefined");
      
        x.crosstalk.group = groups = [].concat(x.crosstalk.group);
        x.crosstalk.id = [].concat(x.crosstalk.id);
        x.crosstalk.key = [].concat(x.crosstalk.key);
        x.crosstalk.sel_handle = new Array(groups.length);
        x.crosstalk.fil_handle = new Array(groups.length);
        x.crosstalk.selection = [];
        for (i = 0; i < groups.length; i++) {
          x.crosstalk.sel_handle[i] = new crosstalk.SelectionHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.sel_handle[i].on("change", onchangeselection);
          x.crosstalk.fil_handle[i] = new crosstalk.FilterHandle(groups[i], {sharedId: x.crosstalk.id[i]});
          x.crosstalk.fil_handle[i].on("change", onchangefilter);
        }
        if (inShiny) {
          // Shiny calls this multiple times, so we need extra cleanup
          // between
          rgl.sphere = undefined;
        }
        rgl.initialize(el, x);
        rgl.initGL();
  
  /* We might have been called after (some of) the players were rendered.
     We need to make sure we respond to their initial values. */

        if (typeof x.players !== "undefined") {
          var players = [].concat(x.players);
          for (i = 0; i < players.length; i++) {
            pel = document.getElementById(players[i]);
            if (pel) {
              player = pel.rglPlayer;
              if (player && (!player.initialized || inShiny)) {
                rgl.Player(pel, player);
                player.initialized = true;
              }
            }
          }
        }
        rgl.drag = 0;
        rgl.drawScene();
      },

      resize: function(width, height) {
        el.width = width;
        el.height = height;
        el.rglinstance.resize(el);
        el.rglinstance.drawScene();
      }
    };
  }
});
</script>
<style type="text/css">.rglPlayer {
width: auto;
height: auto;
}
.rglPlayer .rgl-button {
width: auto;
display: inline-block;
font-size: 75%;
}
.rglPlayer .rgl-slider {
display: inline-block;
width: 30%;
}
.rglPlayer .rgl-label {
display: inline;
padding-left: 6px;
padding-right: 6px;
}
</style>
<script>//// To generate the help pages for this library, use

// jsdoc --template /usr/local/lib/node_modules/foodoc/template *.src.js -R README.md -c JSDoc.json

// To test, set environment variable RGL_DEBUGGING=true
// before building.

/* globals rglwidgetClass: true */

/**
 * The class of an rgl widget
 * @class
*/
rglwidgetClass = function() {
    this.canvas = null;
    this.userMatrix = new CanvasMatrix4();
    this.types = [];
    this.prMatrix = new CanvasMatrix4();
    this.mvMatrix = new CanvasMatrix4();
    this.vp = null;
    this.prmvMatrix = null;
    this.origs = null;
    this.gl = null;
    this.scene = null;
    this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
    this.drawing = false;
};

    rglwidgetClass.f_is_lit = 1;
    rglwidgetClass.f_is_smooth = 2;
    rglwidgetClass.f_has_texture = 4;
    rglwidgetClass.f_depth_sort = 8;
    rglwidgetClass.f_fixed_quads = 16;
    rglwidgetClass.f_is_transparent = 32;
    rglwidgetClass.f_is_lines = 64;
    rglwidgetClass.f_sprites_3d = 128;
    rglwidgetClass.f_is_subscene = 256;
    rglwidgetClass.f_is_clipplanes = 512;
    rglwidgetClass.f_fixed_size = 1024;
    rglwidgetClass.f_is_points = 2048;
    rglwidgetClass.f_is_twosided = 4096;
    rglwidgetClass.f_fat_lines = 8192;
    rglwidgetClass.f_is_brush = 16384;
    rglwidgetClass.f_has_fog = 32768;
    rglwidgetClass.f_rotating = 65536;
    
    rglwidgetClass.prototype.fogNone = 0;
    rglwidgetClass.prototype.fogLinear = 1;
    rglwidgetClass.prototype.fogExp = 2;
    rglwidgetClass.prototype.fogExp2 = 3;

    /**
     * Methods related to obsolete approaches.
     * @name ___OBSOLETE_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
       no debug element.
     */
    rglwidgetClass.prototype.start = function() {
      if (typeof this.prefix !== "undefined") {
        this.debugelement = document.getElementById(this.prefix + "debug");
        this.debug("");
      }
      this.drag = 0;
      this.drawScene();
    };
</script>
<script>    /**
     * Utility methods
     * @name ___UTILITY_METHODS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Multiply matrix by vector
     * @returns {number[]}
     * @param M {number[][]} Left operand
     * @param v {number[]} Right operand
     */
    rglwidgetClass.multMV = function(M, v) {
        return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
                 M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
                 M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
                 M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Multiply row vector by Matrix
     * @returns {number[]}
     * @param v {number[]} left operand
     * @param M {number[][]} right operand
     */
    rglwidgetClass.multVM = function(v, M) {
        return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
                 M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
                 M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
                 M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
               ];
    };
    
    /**
     * Euclidean length of a vector
     * @returns {number}
     * @param v {number[]}
     */
    rglwidgetClass.vlen = function(v) {
      return Math.sqrt(rglwidgetClass.dotprod(v, v));
    };

    /**
     * Dot product of two vectors
     * @instance rglwidgetClass
     * @returns {number}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.dotprod = function(a, b) {
      return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    };

    /**
     * Cross product of two vectors
     * @returns {number[]}
     * @param a {number[]}
     * @param b {number[]}
     */
    rglwidgetClass.xprod = function(a, b) {
      return [a[1]*b[2] - a[2]*b[1],
          a[2]*b[0] - a[0]*b[2],
          a[0]*b[1] - a[1]*b[0]];
    };

    /**
     * Bind vectors or matrices by columns
     * @returns {number[][]}
     * @param a {number[][]}
     * @param b {number[]|number[][]}
     */
    rglwidgetClass.cbind = function(a, b) {
      if (b.length < a.length)
        b = rglwidgetClass.repeatToLen(b, a.length);
      else if (a.length < b.length)
        a = rglwidgetClass.repeatToLen(a, b.length);
      return a.map(function(currentValue, index) {
            return [].concat(currentValue).concat(b[index]);
      });
    };

    /**
     * Swap elements
     * @returns {any[]}
     * @param a {any[]}
     * @param i {number} Element to swap
     * @param j {number} Other element to swap
     */
    rglwidgetClass.swap = function(a, i, j) {
      var temp = a[i];
      a[i] = a[j];
      a[j] = temp;
    };

    /**
     * Flatten a matrix into a vector
     * @returns {any[]}
     * @param a {any[][]}
     */
    rglwidgetClass.flatten = function(arr, result) {
      var value;
      if (typeof result === "undefined") result = [];
      for (var i = 0, length = arr.length; i < length; i++) {
        value = arr[i];
        if (Array.isArray(value)) {
          rglwidgetClass.flatten(value, result);
        } else {
          result.push(value);
        }
      }
      return result;
    };

    /**
     * set element of 1d or 2d array as if it was flattened.
     * Column major, zero based!
     * @returns {any[]|any[][]}
     * @param {any[]|any[][]} a - array
     * @param {number} i - element
     * @param {any} value
     */
    rglwidgetClass.prototype.setElement = function(a, i, value) {
      if (Array.isArray(a[0])) {
        var dim = a.length,
            col = Math.floor(i/dim),
            row = i % dim;
        a[row][col] = value;
      } else {
        a[i] = value;
      }
    };

    /**
     * Transpose an array
     * @returns {any[][]}
     * @param {any[][]} a
     */
    rglwidgetClass.prototype.transpose = function(a) {
      var newArray = [],
          n = a.length,
          m = a[0].length,
          i;
      for(i = 0; i < m; i++){
        newArray.push([]);
      }

      for(i = 0; i < n; i++){
        for(var j = 0; j < m; j++){
          newArray[j].push(a[i][j]);
        }
      }
      return newArray;
    };

    /**
     * Calculate sum of squares of a numeric vector
     * @returns {number}
     * @param {number[]} x
     */
    rglwidgetClass.prototype.sumsq = function(x) {
      var result = 0, i;
      for (i=0; i < x.length; i++)
        result += x[i]*x[i];
      return result;
    };

    /**
     * Convert a matrix to a CanvasMatrix4
     * @returns {CanvasMatrix4}
     * @param {number[][]|number[]} mat
     */
    rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
      if (mat instanceof CanvasMatrix4)
        return mat;
      var result = new CanvasMatrix4();
      mat = rglwidgetClass.flatten(this.transpose(mat));
      result.load(mat);
      return result;
    };

    /**
     * Convert an R-style numeric colour string to an rgb vector
     * @returns {number[]}
     * @param {string} s
     */
    /* jshint bitwise:false */ 
    rglwidgetClass.prototype.stringToRgb = function(s) {
      s = s.replace("#", "");
      var bigint = parseInt(s, 16);
      return [((bigint >> 16) & 255)/255,
              ((bigint >> 8) & 255)/255,
               (bigint & 255)/255];
    };
    /* jshint bitwise:true */
    /**
     * Which list does a particular id come from?
     * @returns { string }
     * @param {number} id The id to look up.
     */
    rglwidgetClass.prototype.whichList = function(id) {
      var obj = this.getObj(id),
          flags = obj.flags;
        if (obj.type === "light")
          return "lights";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_subscene))
            return "subscenes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_clipplanes))
            return "clipplanes";
        if (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent))
            return "transparent";
        return "opaque";
    };
    
    /**
     * Take a component-by-component product of two 3 vectors
     * @returns {number[]}
     * @param {number[]} x
     * @param {number[]} y
     */
    rglwidgetClass.prototype.componentProduct = function(x, y) {
      if (typeof y === "undefined") {
        this.alertOnce("Bad arg to componentProduct");
      }
      var result = new Float32Array(3), i;
      for (i = 0; i<3; i++)
        result[i] = x[i]*y[i];
      return result;
    };

    /**
     * Get next higher power of two
     * @returns { number }
     * @param { number } value - input value
     */
    rglwidgetClass.prototype.getPowerOfTwo = function(value) {
      var pow = 1;
      while(pow<value) {
        pow *= 2;
      }
      return pow;
    };

    /**
     * Unique entries
     * @returns { any[] }
     * @param { any[] } arr - An array
     */
    rglwidgetClass.prototype.unique = function(arr) {
      arr = [].concat(arr);
      return arr.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
    };

    /**
     * Shallow compare of arrays
     * @returns { boolean }
     * @param { any[] } a - An array
     * @param { any[] } b - Another array
     */
    rglwidgetClass.prototype.equalArrays = function(a, b) {
      return a === b || (a && b &&
                      a.length === b.length &&
                      a.every(function(v, i) {return v === b[i];}));
    };
    
    /**
     * Repeat an array to a desired length
     * @returns {any[]}
     * @param {any | any[]} arr The input array
     * @param {number} len The desired output length
     */
    rglwidgetClass.repeatToLen = function(arr, len) {
      arr = [].concat(arr);
      if (!arr.length) 
        throw new RangeError("array is length 0");
      while (arr.length < len/2)
        arr = arr.concat(arr);
      return arr.concat(arr.slice(0, len - arr.length));
    };

    /**
     * Give a single alert message, not to be repeated.
     * @param {string} msg  The message to give.
     */
    rglwidgetClass.prototype.alertOnce = function(msg) {
      // debugger;
      if (typeof this.alerted !== "undefined")
        return;
      this.alerted = true;
      alert(msg);
    };

    /**
     * Get an object by id number.
     * @returns { Object }
     * @param {number} id
     */
    rglwidgetClass.prototype.getObj = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("getObj id is "+typeof id);
      }
      return this.scene.objects[id];
    };

    /**
     * Get ids of a particular type from a subscene or the whole scene
     * @returns { number[] }
     * @param {string} type What type of object?
     * @param {number} subscene  Which subscene?  If not given, find in the whole scene
     */
    rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
      var
        result = [], i, self = this, ids;
      if (typeof subscene === "undefined") {
        Object.keys(this.scene.objects).forEach(
          function(key) {
            key = parseInt(key, 10);
            if (self.getObj(key).type === type)
              result.push(key);
          });
      } else {
        ids = this.getObj(subscene).objects;
        for (i=0; i < ids.length; i++) {
          if (this.getObj(ids[i]).type === type) {
            result.push(ids[i]);
          }
        }
      }
      return result;
    };

    /**
     * Get a particular material property for an obj
     * @returns { any }
     * @param {object} obj  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterial = function(obj, property) {
      var mat;
      if (typeof obj.material === "undefined")
        console.error("material undefined");
      mat = obj.material[property];
      if (typeof mat === "undefined")
          mat = this.scene.material[property];
      return mat;
    };
    
   /**
     * Get a particular material property for an id
     * @returns { any }
     * @param {number} id  Which object?
     * @param {string} property Which material property?
     */
    rglwidgetClass.prototype.getMaterialId = function(id, property) {
      var obj = this.getObj(id);
      return this.getMaterial(obj, property);
    };

    rglwidgetClass.prototype.getAdj = function (obj, index, offset, text) {
      var len, pos;
      if (typeof obj.pos === "undefined")
        return rglwidgetClass.flatten(obj.adj);
      pos = obj.pos[index % obj.pos.length];
      switch(pos) {
        case 0: return [0.5, 0.5, 0.5];
        case 1: return [0.5, 1 + offset, 0.5];
        case 3: return [0.5, -offset, 0.5];
        case 5: return [0.5, 0.5, -offset];
        case 6: return [0.5, 0.5, 1 + offset];
        case 2: 
        case 4: if (typeof text === "undefined")
                  len = 1;
                else
                  len = text.length;
                if (pos === 2)
                  return [1 + offset/len, 0.5, 0.5];
                else
                  return [-offset/len, 0.5, 0.5];
      }
    };

    /**
     * Count clipping planes in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplanes = function() {
      var self = this,
          bound = 0;
      
      Object.keys(this.scene.objects).forEach(
        function(key) {
          var obj = self.getObj(parseInt(key, 10));
          if (obj.type === "clipplanes")
            bound = bound + obj.offsets.length;
        });
      return bound;
    };

    /**
     * Count clipping plane objects in a scene
     * @returns {number}
     */
    rglwidgetClass.prototype.countClipplaneObjs = function() {
      return this.countObjs("clipplanes");
    };

    /**
     * Count lights in a scene
     * @returns { number }
     */
    rglwidgetClass.prototype.countLights = function() {
      return this.countObjs("light");
    };

    /**
     * Count objects of specific type in a scene
     * @returns { number }
     * @param { string } type - Type of object to count
     */
    rglwidgetClass.prototype.countObjs = function(type) {
      var self = this,
          bound = 0;

      Object.keys(this.scene.objects).forEach(
        function(key) {
          if (self.getObj(parseInt(key, 10)).type === type)
            bound = bound + 1;
        });
      return bound;
    };

    /**
     * Display a debug message
     * @param { string } msg - The message to display
     * @param { Object } [img] - Image to insert before message
     */
    rglwidgetClass.prototype.debug = function(msg, img) {
      if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
        this.debugelement.innerHTML = msg;
        if (typeof img !== "undefined") {
          this.debugelement.insertBefore(img, this.debugelement.firstChild);
        }
      } else if (msg !== "")
        alert(msg);
    };

    /**
     * If we are in an ioslides or slidy presentation, get the
     * DOM element of the current slide
     * @returns { Object }
     */
    rglwidgetClass.prototype.getSlide = function() {
      var result = this.el, done = false;
      while (result && !done && this.scene.context.rmarkdown) {
      	switch(this.scene.context.rmarkdown) {
          case "ioslides_presentation":
            if (result.tagName === "SLIDE") return result;
            break;
          case "slidy_presentation":
            if (result.tagName === "DIV" && result.classList.contains("slide"))
              return result;
            break;
          default: return null;
      	}
      	result = result.parentElement;
      }
      return null;
    };

    /**
     * Is this scene visible in the browser?
     * @returns { boolean }
     */
    rglwidgetClass.prototype.isInBrowserViewport = function() {
      var rect = this.canvas.getBoundingClientRect(),
          windHeight = (window.innerHeight || document.documentElement.clientHeight),
          windWidth = (window.innerWidth || document.documentElement.clientWidth);
      if (this.scene.context && this.scene.context.rmarkdown !== null) {
      	if (this.slide)
      	  return (this.scene.context.rmarkdown === "ioslides_presentation" &&
      	          this.slide.classList.contains("current")) ||
      	         (this.scene.context.rmarkdown === "slidy_presentation" &&
      	          !this.slide.classList.contains("hidden"));
      }
      return (
      	rect.top >= -windHeight &&
      	rect.left >= -windWidth &&
      	rect.bottom <= 2*windHeight &&
      	rect.right <= 2*windWidth);
    };
    
    rglwidgetClass.keydiff = function(obj1, obj2) {
      var keys = Object.keys(obj1), i, result = [];
      for (i=0;i<keys.length;i++) {
        if (typeof obj1[keys[i]] !== "undefined" &&
            typeof obj2[keys[i]] === "undefined")
          result.push(keys[i]);
      }
      return result;
    };

    rglwidgetClass.isSet = function(flags, flag) {
      /* jshint bitwise: false */
      return (flags & flag) !== 0;
      /* jshint bitwise: true */
    };
    
    rglwidgetClass.prototype.user2window = function(p, subid) {
      var m, v = [].concat(p);
      
      this.setmvMatrix(subid);
      m = new CanvasMatrix4(this.mvMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.setprMatrix(subid);
      m = new CanvasMatrix4(this.prMatrix);
      v = rglwidgetClass.multVM(v, m);
      this.getViewport(subid);
      v[0] = v[0]*0.5/v[3] + 0.5 + this.vp.x/this.vp.width;
      v[1] = v[1]*0.5/v[3] + 0.5 + this.vp.y/this.vp.height;
      v[2] = (1 + v[2]/v[3])*0.5;
      return v.slice(0, 3);
    };

    /**
     * Andrew's convex hull algorithm. 
     * From Wikipedia, used under Creative Commons Attribution-ShareAlike License
     * @returns { Array } Indices of convex hull points
     */
    rglwidgetClass.chull = function(points) {
      function cross(a, b, o) {
        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
      }
        
      points.sort(function(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      });

      var lower = [], upper = [];
      for (var i = 0; i < points.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
          lower.pop();
        }
        lower.push(points[i]);
      }

      for (i = points.length - 1; i >= 0; i--) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
          upper.pop();
        }
        upper.push(points[i]);
      }

      upper.pop();
      lower.pop();
      return lower.concat(upper);
    };
    
    /**
     * Round number to given precision
     * @param { number } x
     * @param { number } digits
     * @returns { number } 
     */
    rglwidgetClass.signif = function(x, digits) { 
      return parseFloat(x.toPrecision(digits));
    };
      
    /**
     * Check for NA, NaN, undefined, or null
     * @param x
     * @returns { bool }
     */
    rglwidgetClass.missing = function(x) {
      return x !== "-Inf" && x !== "Inf" &&
             (isNaN(x) || x === null || typeof(x) === "undefined");
    };

    /**
     * Write matrix to log
     * @param M
     */
    rglwidgetClass.logMatrix = function(M) {
      console.log("matrix(c("+M.m11+","+M.m12+","+M.m13+","+M.m14+",\n"+
                              M.m21+","+M.m22+","+M.m23+","+M.m24+",\n"+
                              M.m31+","+M.m32+","+M.m33+","+M.m34+",\n"+
                              M.m41+","+M.m42+","+M.m43+","+M.m44+"), byrow=TRUE, ncol=4)");
    };
    
    /**
     * Write vector to log
     * @param {vector} v
     */
     
    rglwidgetClass.logVec3 = function(v) {
      console.log("c("+v[0]+","+v[1]+","+v[2]+")");
    };
    
    /**
     * Sum two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vsum = function(x, y) {
       var i, result = [].concat(x);
       for (i = 0; i < y.length; i++)
         result[i] += y[i];
        return result;
     };
     
    /**
     * difference of two vectors
     * @param {vector} x
     * @param {vector} y
     */
     rglwidgetClass.vdiff = function(x, y) {
        return rglwidgetClass.vsum(x, rglwidgetClass.vscale(y, -1));
     };

    /**
     * Scale a vector
     * @param {number} s
     * @param {vector} x
     */
     rglwidgetClass.vscale = function(x, s) {
       var i, result = [].concat(x);
       for (i = 0; i < x.length; i++)
         result[i] *= s;
        return result;
     };
    
    /**
     * Normalize a vector
     * @param {vector} v
     */
    rglwidgetClass.normalize = function(v) {
      return rglwidgetClass.vscale(v, 1/rglwidgetClass.vlen(v));
    };
    
    /**
     * Compute the dimensions of a regular array
     * without checking that it is regular
     */ 
    rglwidgetClass.arrayDim = function(arr) {
      var result = [];
      while (typeof arr.length !== "undefined") {
        result = result.concat(arr.length);
        arr = arr[0];
      }
      return result;
    };
</script>
<script>/**
     * Methods related to buffered data
     * @name ___METHODS_FOR_BUFFERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Detect rglBuffered object
     * @param { Object } obj - vertices or similar 
     */
    rglwidgetClass.prototype.isBuffered = function(obj) {
      return typeof obj === "string";
    };

    /* The next two functions are taken from 
     
     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
     
     They were written by Mozilla Contributors and dedicated
     to the public domain under CC0. */
     
    /* Array of bytes to Base64 string decoding */
    rglwidgetClass.prototype.b64ToUint6 = function(nChr) {
      return nChr > 64 && nChr < 91 ? nChr - 65 : 
             nChr > 96 && nChr < 123 ? nChr - 71 : 
             nChr > 47 && nChr < 58 ? nChr + 4 : 
             nChr === 43 ? 62 : 
             nChr === 47 ? 63 : 
             0;
    };

    /* jshint bitwise:false */
    rglwidgetClass.prototype.base64DecToArr = function(sBase64, nBlocksSize) {
      var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""),
        nInLen = sB64Enc.length, 
        nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
        taBytes = new Uint8Array(nOutLen);
      for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
          for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
            taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
          }
          nUint24 = 0;
        }
      }
      return taBytes;
    };
    /* jshint bitwise:true */
    
    rglwidgetClass.prototype.getArrayBuffer = function(base64) {
      return this.base64DecToArr(base64, 4).buffer;
    };

    rglwidgetClass.prototype.getBufferedData = function(v) {
      return this.readAccessor(parseInt(v, 10), this.scene.buffer);
    };
    
    rglwidgetClass.prototype.readAccessor = function(acc, buf) {
      var typeSignedByte = 5120, 
          typeUnsignedByte = 5121, 
          typeSignedShort = 5122, 
          typeUnsignedShort = 5123, 
          typeSignedInt = 5124, 
          typeUnsignedInt = 5125, 
          typeFloat = 5126, 
          typeDouble = 5130, 
          accessor = buf.accessors[acc], 
          bufferView = buf.bufferViews[accessor.bufferView], 
          buffer = buf.buffers[bufferView.buffer], 
          bytes, 
          lens = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
          }, 
          rowsizes = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 2,
            MAT3: 3,
            MAT4: 4
          }, 
          offset = 0, 
          len = lens[accessor.type], 
          rowsize = rowsizes[accessor.type], 
          count = len * accessor.count, 
          nrows = count / rowsize, 
          values, arr = [], row, i, j, k;
          
      if (typeof buffer.bytes === "string") 
        buffer.bytes = this.getArrayBuffer(buffer.bytes);
        
      bytes = buffer.bytes;
      
      if (typeof accessor.byteOffset !== "undefined") 
        offset += accessor.byteOffset;
        
      if (typeof bufferView.byteOffset !== "undefined") 
        offset += bufferView.byteOffset;
        
      switch (accessor.componentType) {
       case typeSignedByte:
        values = new Int8Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedByte:
        values = new Uint8Array(buffer.bytes, offset, count);
        break;

       case typeSignedShort:
        values = new Int16Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedShort:
        values = new Uint16Array(buffer.bytes, offset, count);
        break;

       case typeSignedInt:
        values = new Int32Array(buffer.bytes, offset, count);
        break;

       case typeUnsignedInt:
        values = new Uint32Array(buffer.bytes, offset, count);
        break;

       case typeFloat:
        values = new Float32Array(buffer.bytes, offset, count);
        break;

       case typeDouble:
        values = new Float64Array(buffer.bytes, offset, count);
        break;
      }

      /* This is all very inefficient, but is convenient
             to work with the old code. */
      k = 0;
      for (i = 0; i < nrows; i++) {
        row = [];
        for (j = 0; j < rowsize; j++) {
          if (accessor.normalized) {
            switch(accessor.componentType) {
              case typeSignedByte:
                row.push(Math.max(values[k++]/127, -1.0));
                break;
              case typeSignedShort:
                row.push(Math.max(values[k++]/32767, -1.0));
                break;
              case typeUnsignedByte:
                row.push(values[k++]/255);
                break;
              case typeUnsignedShort:
                row.push(values[k++]/65535);
                break;
            }
          } else
            row.push(values[k++]);
        }
        arr.push(row);
      }
      return arr;
    };
    
    rglwidgetClass.prototype.expandBufferedFields = function(obj) {
      /* this list needs to match the one in convertScene.R */
      var fields = ["vertices", "normals", "indices", 
                    "texcoords", "colors", "centers"], i, field;
      for (i = 0; i < fields.length; i++) {
        field = obj[fields[i]];
        if (this.isBuffered(field))
          obj[fields[i]] = this.getBufferedData(field);
      }
    };
</script>
<script>    /**
     * Methods related to subscenes
     * @name ___METHODS_FOR_SUBSCENES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */

    /**
     * Is a particular id in a subscene?
     * @returns { boolean }
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.inSubscene = function(id, subscene) {
      return this.getObj(subscene).objects.indexOf(id) > -1;
    };

    /**
     * Translate from window coordinates to viewport coordinates
     * @returns { Object } translated coordinates
     * @param { number } subsceneid - which subscene to use?
     * @param { Object } coords - point to translate
     */
    rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
      var viewport = this.getObj(subsceneid).par3d.viewport;
      return {x: coords.x - viewport.x*this.canvas.width,
              y: coords.y - viewport.y*this.canvas.height};
    };

    /**
     * Check whether point is in viewport of subscene
     * @returns {boolean}
     * @param { Object } coords - screen coordinates of point
     * @param { number } subsceneid - subscene to check
     */
    rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
      var viewport = this.getObj(subsceneid).par3d.viewport,
        x0 = coords.x - viewport.x*this.canvas.width,
        y0 = coords.y - viewport.y*this.canvas.height;
      return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
             0 <= y0 && y0 <= viewport.height*this.canvas.height;
    };

    /**
     * Find which subscene contains a point
     * @returns { number } subscene id
     * @param { Object } coords - coordinates of point
     */
    rglwidgetClass.prototype.whichSubscene = function(coords) {
      var self = this,
          recurse = function(subsceneid) {
            var subscenes = self.getChildSubscenes(subsceneid), i, id;
            for (i=0; i < subscenes.length; i++) {
              id = recurse(subscenes[i]);
              if (typeof(id) !== "undefined")
                return(id);
            }
            if (self.inViewport(coords, subsceneid))
              return(subsceneid);
            else
              return undefined;
          },
          rootid = this.scene.rootSubscene,
          result = recurse(rootid);
      if (typeof(result) === "undefined")
        result = rootid;
      return result;
    };

    /**
     * Add an id to a subscene.
     * @param {number} id Which id?
     * @param {number} subscene Which subscene id?
     */
    rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          ids = [id],
          obj = this.getObj(id), i;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined") {
        ids = ids.concat(obj.newIds);
      }
      thesub.objects = [].concat(thesub.objects);
      for (i = 0; i < ids.length; i++) {
        id = ids[i];
        if (thesub.objects.indexOf(id) === -1) {
          thelist = this.whichList(id);
          thesub.objects.push(id);
          thesub[thelist].push(id);
        }
      }
    };

    /**
     * Delete an id from a subscene
     * @param { number } id - the id to add
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
      var thelist,
          thesub = this.getObj(subscene),
          obj = this.getObj(id),
          ids = [id], i, j;
      if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
        ids = ids.concat(obj.newIds);
      thesub.objects = [].concat(thesub.objects); // It might be a scalar
      for (j=0; j<ids.length;j++) {
        id = ids[j];
        i = thesub.objects.indexOf(id);
        if (i > -1) {
          thesub.objects.splice(i, 1);
          thelist = this.whichList(id);
          i = thesub[thelist].indexOf(id);
          thesub[thelist].splice(i, 1);
        }
      }
    };

    /**
     * Set the ids in a subscene
     * @param { number[] } ids - the ids to set
     * @param { number } subsceneid - the id of the subscene
     */
    rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
      var sub = this.getObj(subsceneid);
      sub.objects = ids;
      this.initSubscene(subsceneid);
    };

    /**
     * Get the ids in a subscene
     * @returns {number[]}
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
      return this.getObj(subscene).objects;
    };

    /**
     * Get the ids of the subscenes within a subscene
     * @returns { number[] }
     * @param { number } subscene - the id of the subscene
     */
    rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
      return this.getObj(subscene).subscenes;
    };

    /**
     * Find a particular subscene by inheritance
     * @returns { number } id of subscene to use
     * @param { number } subsceneid - child subscene
     * @param { string } type - type of inheritance:  "projection" or "model"
     */
    rglwidgetClass.prototype.useid = function(subsceneid, type) {
      var sub = this.getObj(subsceneid);
      if (sub.embeddings[type] === "inherit")
        return(this.useid(sub.parent, type));
      else
        return subsceneid;
    };

    /**
     * Find bboxdeco for a subscene
     * @returns { number } id of bboxdeco, or undefined if none
     * @param { number } sub- subscene
     */
    rglwidgetClass.prototype.getBBoxDeco = function(sub) {
      var objects = sub.objects, i, obj;
      for (i = 0; i < objects.length; i++) {
        obj = this.getObj(objects[i]);
        if (obj.type === "bboxdeco")
          return obj;
      }
      if (sub.parent) 
        return this.getBBoxDeco(this.getObj(sub.parent));
      else
        return undefined;
    };
</script>
<script>    /**
     * Methods related to shaders
     * @name ___METHODS_FOR_SHADERS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get flags that will end up as shader defines.
     * Static method so it can be called from R
     */
    rglwidgetClass.getDefFlags = function(flags, type, normals, round_points) {
      var f = {};
      f.fat_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_fat_lines);
      f.fixed_quads = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads);
      f.fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size);
      f.has_fog = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_fog);
      f.has_normals = (typeof normals !== "undefined") ||
                        type === "spheres";
      f.has_texture = rglwidgetClass.isSet(flags, rglwidgetClass.f_has_texture);
      f.is_brush = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_brush);
      f.is_lines = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lines);
      f.is_lit = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit);
      f.is_points = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_points);
      f.is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
      f.is_twosided = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_twosided);
      f.needs_vnormal = (f.is_lit && !f.fixed_quads && !f.is_brush) || (f.is_twosided && f.has_normals);
      f.rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating);
      f.round_points = round_points;
      return f;
    };
     
    
    /**
     * Generate the defines for the shader code for an object.
     * 
     * This is a static method so it can be called from R.
     * 
     * @returns {string}
     * @param  id - id of object
     * @param  type - type of object
     * @param  flags - object flags
     * @param  nclipplanes - number of clipping planes in scene 
     *         (may not all be active)
     * @param  nlights - number of lights in scene (ditto)
     * @param  normals - normals for object
     * @param  pointSize - point size for object 
     * @param  textype - texture type for object 
     * @param  antialias - use antialiasing?
     */
    rglwidgetClass.getDefines = function(id, type, flags, nclipplanes, nlights, normals, pointSize, textype, antialias, fl) {
      var
        title, defines;
      
      if (typeof fl === "undefined")
        fl = rglwidgetClass.getDefFlags(flags, type, normals, antialias);
        
      title = "  /* ****** "+type+" object "+id+" shader ****** */\n";
      
      defines = "#define NCLIPPLANES " + nclipplanes + "\n"+
                "#define NLIGHTS " + nlights + "\n";
      
      if (fl.fat_lines)
        defines = defines + "#define FAT_LINES 1\n";
      
      if (fl.fixed_quads)
        defines = defines + "#define FIXED_QUADS 1\n";

      if (fl.fixed_size)
        defines = defines + "#define FIXED_SIZE 1\n";

      if (fl.has_fog)
        defines = defines + "#define HAS_FOG 1\n";
        
      if (fl.has_normals)
        defines = defines + "#define HAS_NORMALS 1\n";
        
      if (fl.has_texture) {
        defines = defines + "#define HAS_TEXTURE 1\n";
        defines = defines + "#define TEXTURE_" + textype + "\n";
      }
      
      if (fl.is_brush)
        defines = defines + "#define IS_BRUSH 1\n";  

      if (type === "linestrip")
        defines = defines + "#define IS_LINESTRIP 1\n";         

      if (fl.is_lit)
        defines = defines + "#define IS_LIT 1\n"; 
      
      if (fl.is_points) {
        defines = defines + "#define IS_POINTS 1\n";
        defines = defines + "#define POINTSIZE " + Number.parseFloat(pointSize).toFixed(1) + "\n";
      }
        
      if (type === "sprites")
        defines = defines + "#define IS_SPRITES 1\n";
        
      if (type === "text")
        defines = defines + "#define IS_TEXT 1\n";

      if (fl.is_transparent)
        defines = defines + "#define IS_TRANSPARENT 1\n"; 
        
      if (fl.is_twosided)
        defines = defines + "#define IS_TWOSIDED 1\n";
        
      if (fl.needs_vnormal)
        defines = defines + "#define NEEDS_VNORMAL 1\n";

      if (fl.rotating)
        defines = defines + "#define ROTATING 1\n";
        
      if (fl.round_points)        
        defines = defines + "#define ROUND_POINTS 1\n";   

      // console.log(result);
      return title + defines;
    };

    /**
     * Create code for vertex and fragment shaders
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShaders = function(obj) {
      var header, 
        vertex = obj.userVertexShader, 
        fragment = obj.userFragmentShader;
      
      header = rglwidgetClass.getDefines(
        obj.id, obj.type, obj.flags, 
        this.countClipplanes(), this.countLights(), 
        obj.normals, 
        this.getMaterial(obj, "size"), 
        this.getMaterial(obj, "textype"), 
        this.getMaterial(obj, "point_antialias"),
        obj.defFlags
      );

      if (typeof vertex === "undefined")
        vertex = document.getElementById("rgl-vertex-shader").text;
        
      if (typeof fragment === "undefined") 
        fragment = document.getElementById("rgl-fragment-shader").text;

//      console.log("vertex:");
//      console.log(header + vertex);
//      console.log("fragment:");
//      console.log(header + fragment);
      
      return {vertex: header + vertex,
              fragment: header + fragment};
    };
    
    
    /**
     * Call gl functions to create and compile shader from code
     * @returns {Object}
     * @param { number } shaderType - gl code for shader type
     * @param { string } code - code for the shader
     */
    rglwidgetClass.prototype.getShader = function(shaderType, code) {
        var gl = this.gl, shader;
        shader = gl.createShader(shaderType);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
            alert(gl.getShaderInfoLog(shader));
        return shader;
    };

</script>
<script>    /**
     * Methods related to textures
     * @name ___METHODS_FOR_TEXTURES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getTexFilter = function(filter) {
      var gl = this.gl || this.initGL();
      switch(filter) {
        case "nearest": return gl.NEAREST;
        case "linear": return gl.LINEAR;
        case "nearest.mipmap.nearest": return gl.NEAREST_MIPMAP_NEAREST;
        case "linear.mipmap.nearest": return gl.LINEAR_MIPMAP_NEAREST;
        case "nearest.mipmap.linear": return gl.NEAREST_MIPMAP_LINEAR;
        case "linear.mipmap.linear": return gl.LINEAR_MIPMAP_LINEAR;
        default: console.error("Unknown filter: "+filter);
      }
    };
     
    /**
     * Handle a texture after its image has been loaded
     * @param { Object } texture - the gl texture object
     * @param { Object } textureCanvas - the canvas holding the image
     */
    rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
      var gl = this.gl || this.initGL();
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
      gl.generateMipmap(gl.TEXTURE_2D);

      gl.bindTexture(gl.TEXTURE_2D, null);
    };

    /**
     * Get maximum dimension of texture in current browser.
     * @returns {number}
     */
    rglwidgetClass.prototype.getMaxTexSize = function() {
      var gl = this.gl || this.initGL();	
      return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
    };
    
    /**
     * Load an image to a texture
     * @param { string } uri - The image location
     * @param { Object } texture - the gl texture object
     */
    rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
      var canvas = this.textureCanvas,
          ctx = canvas.getContext("2d"),
          image = new Image(),
          self = this;

       image.onload = function() {

         var w = image.width,
             h = image.height,
             canvasX = self.getPowerOfTwo(w),
             canvasY = self.getPowerOfTwo(h),
             maxTexSize = self.getMaxTexSize();
         while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
           canvasX /= 2;
           canvasY /= 2;
         }
         canvas.width = canvasX;
         canvas.height = canvasY;
         ctx.imageSmoothingEnabled = true;
         ctx.drawImage(image, 0, 0, canvasX, canvasY);
         self.handleLoadedTexture(texture, canvas);
         self.texturesLoading -= 1;
         if (!self.texturesLoading)
           self.drawScene();
       };
       if (!self.texturesLoading)
         self.texturesLoading = 0; // may have been undefined
       self.texturesLoading += 1;
       image.src = uri;
     };

    /**
     * Draw text to the texture canvas
     * @returns { Object } object with text measurements
     * @param { string } text - the text
     * @param { number } cex - expansion
     * @param { string } family - font family
     * @param { number } font - font number
     */
    rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
       var canvasX, canvasY,
           scaling = 20,
           textColour = "white",

           backgroundColour = "rgba(0,0,0,0)",
           canvas = this.textureCanvas,
           ctx = canvas.getContext("2d"),
           i, textHeight = 0, textHeights = [], width, widths = [], 
           offsetx, offsety = 0, line, lines = [], offsetsx = [],
           offsetsy = [], lineoffsetsy = [], fontStrings = [],
           maxTexSize = this.getMaxTexSize(),
           getFontString = function(i) {
             textHeights[i] = scaling*cex[i];
             var fontString = textHeights[i] + "px",
                 family0 = family[i],
                 font0 = font[i];
             if (family0 === "sans")
               family0 = "sans-serif";
             else if (family0 === "mono")
               family0 = "monospace";
             fontString = fontString + " " + family0;
             if (font0 === 2 || font0 === 4)
               fontString = "bold " + fontString;
             if (font0 === 3 || font0 === 4)
               fontString = "italic " + fontString;
             return fontString;
           };
       cex = rglwidgetClass.repeatToLen(cex, text.length);
       family = rglwidgetClass.repeatToLen(family, text.length);
       font = rglwidgetClass.repeatToLen(font, text.length);

       canvasX = 1;
       line = -1;
       offsetx = maxTexSize;
       for (i = 0; i < text.length; i++)  {
         ctx.font = fontStrings[i] = getFontString(i);
         width = widths[i] = ctx.measureText(text[i]).width;
         if (offsetx + width > maxTexSize) {
           offsety = offsety + 2*textHeight;
           if (line >= 0)
             lineoffsetsy[line] = offsety;
           line += 1;
           if (offsety > maxTexSize)
             console.error("Too many strings for texture.");
           textHeight = 0;
           offsetx = 0;
         }
         textHeight = Math.max(textHeight, textHeights[i]);
         offsetsx[i] = offsetx;
         offsetx += width;
         canvasX = Math.max(canvasX, offsetx);
         lines[i] = line;
       }
       offsety = lineoffsetsy[line] = offsety + 2*textHeight;
       for (i = 0; i < text.length; i++) {
       	 offsetsy[i] = lineoffsetsy[lines[i]];
       }
       
       canvasX = this.getPowerOfTwo(canvasX);
       canvasY = this.getPowerOfTwo(offsety);

       canvas.width = canvasX;
       canvas.height = canvasY;

       ctx.fillStyle = backgroundColour;
       ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

       ctx.textBaseline = "alphabetic";
       for(i = 0; i < text.length; i++) {
         ctx.font = fontStrings[i];
         ctx.fillStyle = textColour;
         ctx.textAlign = "left";
         ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
       }
       return {canvasX:canvasX, canvasY:canvasY,
               widths:widths, textHeights:textHeights,
               offsetsx:offsetsx, offsetsy:offsetsy};
     };

</script>
<script>    /**
     * Methods related to projections
     * @name ___METHODS_FOR_PROJECTIONS___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Get the viewport
     */
     
    rglwidgetClass.prototype.getViewport = function(id) {
      var vp = this.getObj(id).par3d.viewport,
         x = vp.x*this.canvas.width,
         y = vp.y*this.canvas.height,
         width = vp.width*this.canvas.width,
         height = vp.height*this.canvas.height;
       this.vp = {x:x, y:y, width:width, height:height};
    };
    
    /**
     * Set the gl viewport and scissor test
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setViewport = function(id) {
       var gl = this.gl || this.initGL();
       this.getViewport(id);
       gl.viewport(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.scissor(this.vp.x, this.vp.y, this.vp.width, this.vp.height);
       gl.enable(gl.SCISSOR_TEST);
     };

    /**
     * Set the projection matrix for a subscene
     * @param { number } id - id of subscene
     */
    rglwidgetClass.prototype.setprMatrix = function(id) {
       var subscene = this.getObj(id),
          embedding = subscene.embeddings.projection;
       if (embedding === "replace")
         this.prMatrix.makeIdentity();
       else
         this.setprMatrix(subscene.parent);
       if (embedding === "inherit")
         return;
       // This is based on the Frustum::enclose code from geom.cpp
       var bbox = subscene.par3d.bbox,
           scale = subscene.par3d.scale,
           ranges = [(bbox[1]-bbox[0])*scale[0]/2,
                     (bbox[3]-bbox[2])*scale[1]/2,
                     (bbox[5]-bbox[4])*scale[2]/2],
           radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
       if (radius <= 0) radius = 1;
       var observer = subscene.par3d.observer,
           distance = observer[2],
           FOV = subscene.par3d.FOV, ortho = FOV === 0,
           t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
           near = distance - radius,
           far = distance + radius,
           hlen,
           aspect = this.vp.width/this.vp.height,
           z = subscene.par3d.zoom,
           userProjection = subscene.par3d.userProjection;
       if (far < 0.0)
         far = 1.0;
       if (near < far/100.0)
         near = far/100.0;
       this.frustum = {near:near, far:far};
       hlen = t*near;
       if (ortho) {
         if (aspect > 1)
           this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.ortho(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       } else {
         if (aspect > 1)
           this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
                          -hlen*z, hlen*z, near, far);
         else
           this.prMatrix.frustum(-hlen*z, hlen*z,
                          -hlen*z/aspect, hlen*z/aspect,
                          near, far);
       }
       this.prMatrix.multRight(userProjection);
     };

    /**
     * Set the model-view matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmvMatrix = function(id) {
       var observer = this.getObj(id).par3d.observer;
       this.mvMatrix.makeIdentity();
       this.setmodelMatrix(id);
       this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);

     };

    /**
     * Set the model matrix for a subscene
     * @param { number } id - id of the subscene
     */
    rglwidgetClass.prototype.setmodelMatrix = function(id) {
      var subscene = this.getObj(id),
          embedding = subscene.embeddings.model;
      if (embedding === "replace") {
        var bbox = subscene.par3d.bbox,
            center = [(bbox[0]+bbox[1])/2,
                      (bbox[2]+bbox[3])/2,
                      (bbox[4]+bbox[5])/2];
        this.mvMatrix.translate(-center[0], -center[1], -center[2]);
      }
      if (embedding !== "inherit") {
        var scale = subscene.par3d.scale;
        this.mvMatrix.scale(scale[0], scale[1], scale[2]);
        this.mvMatrix.multRight( subscene.par3d.userMatrix );
      }
      if (embedding !== "replace")
        this.setmodelMatrix(subscene.parent);
     };

    /**
     * Set the normals matrix for a subscene
     * @param { number } subsceneid - id of the subscene
     */
     rglwidgetClass.prototype.setnormMatrix2 = function() {
       this.normMatrix = new CanvasMatrix4(this.mvMatrix);
       this.normMatrix.invert();
       this.normMatrix.transpose();
     };

    /**
     * Set the combined projection-model-view matrix
     */
    rglwidgetClass.prototype.setprmvMatrix = function() {
       this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
       this.prmvMatrix.multRight( this.prMatrix );
     };

    rglwidgetClass.prototype.setInvPrMatrix = function() {
      this.invPrMatrix = new CanvasMatrix4( this.prMatrix );
      this.invPrMatrix.invert();
      this.invPrMatrix.transpose();
    };
</script>
<script>    /**
     * Methods related to mouse handling
     * @name ___METHODS_FOR_MOUSE_HANDLING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    rglwidgetClass.prototype.getCursor = function(mode) {
      switch(mode) {
        case "none": 
          return "none";
        case "trackball":
        case "xAxis":
        case "yAxis":
        case "zAxis":
        case "polar":
          return "grab";
        case "selecting":
          return "crosshair";
        case "fov":
        case "zoom":
          return "zoom-in";
        case "user":
          return "default";
      }
      return "dragging";
    };
    
    /**
     * Set mouse mode for a subscene
     * @param { string } mode - name of mode
     * @param { number } button - button number (0 to 4)
     * @param { number } subscene - subscene id number
     * @param { number } stayActive - if truthy, don't clear brush
     */
    rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
      var sub = this.getObj(subscene),
          which = ["none", "left", "right", "middle", "wheel"][button];
      if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
        this.clearBrush(null);
      sub.par3d.mouseMode[which] = mode;
      if (button === 1 || (button === 0 && mode !== "none"))
        this.canvas.style.cursor = this.getCursor(mode);
      if (button === 0 && mode !== "none")
        sub.needsBegin = mode;
    };

    /**
     * Compute mouse coordinates relative to current canvas
     * @returns { Object }
     * @param { Object } event - event object from mouse click
     */
    rglwidgetClass.prototype.relMouseCoords = function(event) {
      var rect = this.canvas.getBoundingClientRect();
      return {x:event.clientX-rect.left, y:event.clientY-rect.top};
    };
    
    /**
     * Send mouse selection to Shiny
     */
    rglwidgetClass.prototype.recordSelection = function(subid) {
      var result = {};
      if (typeof this.select !== "undefined" && 
          typeof this.select.state !== "undefined" &&
          this.select.state !== "inactive") {
        result = { subscene: subid,
                   state: this.select.state,
                   region: this.select.region
                 };
        this.setmvMatrix(subid);
        result.model = this.mvMatrix;
        this.setprMatrix(subid);
        result.proj = this.prMatrix;
        this.getViewport(subid);
        result.view = this.vp;
      } else
        result.state = "inactive";
      Shiny.setInputValue(this.scene.selectionInput + ":shinyMouse3d", result);
    }; 

    /**
     * Set mouse handlers for the scene
     */
    rglwidgetClass.prototype.setMouseHandlers = function() {
      var self = this, activeSubscene, handler,
          handlers = {}, drag = 0;

      handlers.rotBase = 0;

      self.screenToVector = function(x, y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
          radius = Math.max(width, height)/2.0,
          cx = width/2.0,
          cy = height/2.0,
          px = (x-cx)/radius,
          py = (y-cy)/radius,
          plen = Math.sqrt(px*px+py*py);
        if (plen > 1.e-6) {
          px = px/plen;
          py = py/plen;
        }
        var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
          z = Math.sin(angle),
          zlen = Math.sqrt(1.0 - z*z);
        px = px * zlen;
        py = py * zlen;
        return [px, py, z];
      };

      handlers.trackballdown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.rotBase = self.screenToVector(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.trackballmove = function(x,y) {
        var rotCurrent = self.screenToVector(x,y),
            rotBase = handlers.rotBase,
            dot = rotBase[0]*rotCurrent[0] +
                  rotBase[1]*rotCurrent[1] +
                  rotBase[2]*rotCurrent[2],
            angle = Math.acos( dot/rglwidgetClass.vlen(rotBase)/rglwidgetClass.vlen(rotCurrent) )*180.0/Math.PI,
            axis = rglwidgetClass.xprod(rotBase, rotCurrent),
            objects = self.scene.objects,
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            l = activeModel.par3d.listeners,
            i;
        if (angle === 0.0)
          return;    
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
        }
        self.drawScene();
      };
      handlers.trackballend = 0;

      self.clamp = function(x, lo, hi) {
      	return Math.max(lo, Math.min(x, hi));
      };

      self.screenToPolar = function(x,y) {
        var viewport = self.getObj(activeSubscene).par3d.viewport,
          width = viewport.width*self.canvas.width,
          height = viewport.height*self.canvas.height,
    	  r = Math.min(width, height)/2,
    	  dx = self.clamp(x - width/2, -r, r),
    	  dy = self.clamp(y - height/2, -r, r);
    	  return [Math.asin(dx/r), Math.asin(-dy/r)];
      };

      handlers.polardown = function(x,y) {
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        handlers.dragBase = self.screenToPolar(x, y);
        self.saveMat = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
          activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
                               Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.polarmove = function(x,y) {
        var dragCurrent = self.screenToPolar(x,y),
            activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            objects = self.scene.objects,
            l = activeModel.par3d.listeners,
            i, j, changepos = [];
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          for (j=0; j<2; j++)
            changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
          activeSub.par3d.userMatrix.makeIdentity();
          activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
          activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
          activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
        }
        self.drawScene();
      };
      handlers.polarend = 0;

      handlers.axisdown = function(x) {
        handlers.rotBase = self.screenToVector(x, self.canvas.height/2);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
        }
        self.canvas.style.cursor = "grabbing";
      };

      handlers.axismove = function(x) {
        var rotCurrent = self.screenToVector(x, self.canvas.height/2),
            rotBase = handlers.rotBase,
            angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
            rotMat = new CanvasMatrix4();
        rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
        var activeSub = self.getObj(activeSubscene),
            activeModel = self.getObj(self.useid(activeSub.id, "model")),
            i, l = activeModel.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.userMatrix.load(activeSub.saveMat);
          activeSub.par3d.userMatrix.multLeft(rotMat);
        }
        self.drawScene();
      };
      handlers.axisend = 0;

      handlers.y0zoom = 0;
      handlers.zoomdown = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        handlers.y0zoom = y;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.zoommove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/self.canvas.height);
        }
        self.drawScene();
      };
      handlers.zoomend = 0;

      handlers.y0fov = 0;
      handlers.fovdown = function(x, y) {
        handlers.y0fov = y;
        var activeSub = self.getObj(activeSubscene),
          activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
          i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.fov0 = activeSub.par3d.FOV;
        }
        self.canvas.style.cursor = "zoom-in";
      };
      handlers.fovmove = function(x, y) {
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            i, l = activeProjection.par3d.listeners;
        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
             180*(y-handlers.y0fov)/self.canvas.height));
        }
        self.drawScene();
      };
      handlers.fovend = 0;
      
      handlers.selectingdown = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height, 
          p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	self.select.region = {p1: p, p2: p};
      	if (self.select.subscene && self.select.subscene !== activeSubscene)
      	  self.delFromSubscene(self.scene.brushId, self.select.subscene);
      	self.select.subscene = activeSubscene;
      	self.addToSubscene(self.scene.brushId, activeSubscene);
      	self.select.state = "changing";
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene); 
      	self.drawScene();
      	self.canvas.style.cursor = "crosshair";
      };
      
      handlers.selectingmove = function(x, y) {
      	var viewport = self.getObj(activeSubscene).par3d.viewport,
      	  width = viewport.width*self.canvas.width,
      	  height = viewport.height*self.canvas.height;
      	if (self.select.state === "inactive") 
      	  return;
      	self.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
      	if (typeof self.scene.brushId !== "undefined")
      	  self.getObj(self.scene.brushId).initialized = false;
      	if (typeof self.scene.selectionInput !== "undefined")
      	  self.recordSelection(activeSubscene);
      	self.drawScene();
      };
      
      handlers.selectingend = 0;
      /* jshint evil:true */
      handlers.userdown = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].begin;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.usermove = function(x, y) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].update;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self, x, y);
        }
      };
      
      handlers.userend = function() {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks[drag].end;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          fn.call(self);
        }
      };

      self.canvas.onpointerdown = function ( ev ){
        // pointers and mice differ in capture rules; 
        // act like a mouse.
        if (ev.target.hasPointerCapture(ev.pointerId))
          ev.target.releasePointerCapture(ev.pointerId);
          
        if (!ev.which) // Use w3c defns in preference to MS
        switch (ev.button) {
          case 0: ev.which = 1; break;
          case 1:
          case 4: ev.which = 2; break;
          case 2: ev.which = 3;
        }
        drag = ["none", "left", "middle", "right", "wheel"][ev.which];
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height-coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f;
        handler = sub.par3d.mouseMode[drag];
        switch (handler) {
        case "xAxis":
          handler = "axis";
          handlers.axis = [1.0, 0.0, 0.0];
          break;
        case "yAxis":
          handler = "axis";
          handlers.axis = [0.0, 1.0, 0.0];
          break;
        case "zAxis":
          handler = "axis";
          handlers.axis = [0.0, 0.0, 1.0];
          break;
        }
        f = handlers[handler + "down"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
          ev.preventDefault();
        } else
          console.warn("Mouse handler '" + handler + "' is not implemented.");

      };

      self.canvas.onpointerup = function ( ev ){
        if ( !drag ) return;
        var f = handlers[handler + "end"];
        if (f) {
          f.call(self);
          ev.preventDefault();
        }
        drag = 0;
        handlers.onpointermove( ev );
      };

      self.canvas.onpointerout = self.canvas.onpointerup;

      handlers.onpointermove = function ( ev ) {
        var coords = self.relMouseCoords(ev), sub, f;
        coords.y = self.canvas.height - coords.y;
        if (ev.buttons === 0) {
          activeSubscene = self.whichSubscene(coords);
          drag = "none";
          sub = self.getObj(activeSubscene);
          handler = sub.par3d.mouseMode.none;
          if (handler !== "none") {
            if (sub.needsBegin) {
              f = handlers[handler + "down"];
              if (f) {
                coords = self.translateCoords(activeSubscene, coords);
                f.call(self, coords.x, coords.y);
              }
              sub.needsBegin = 0;
            }
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.none);
          } else {
            self.canvas.style.cursor = self.getCursor(sub.par3d.mouseMode.left);  
            return;
          }
        }
        f = handlers[handler + "move"];
        if (f) {
          coords = self.translateCoords(activeSubscene, coords);
          f.call(self, coords.x, coords.y);
        }
      };
      

      self.canvas.onpointerenter = function() {
        self.canvas.addEventListener("pointermove",               handlers.onpointermove);
      };
      
      self.canvas.onpointerleave = function() {
        self.canvas.removeEventListener("pointermove",
          handlers.onpointermove);
      };

      handlers.setZoom = function(ds) {
        var i;
        if (typeof activeSubscene === "undefined")
          activeSubscene = self.scene.rootSubscene;
        var activeSub = self.getObj(activeSubscene),
            activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
            l = activeProjection.par3d.listeners;

        for (i = 0; i < l.length; i++) {
          activeSub = self.getObj(l[i]);
          activeSub.par3d.zoom *= ds;
        }
        self.drawScene();
      };
      
      handlers.pushwheel = function(ev) {
        ev.deltaY = -ev.deltaY;
        handlers.pullwheel(ev);
      };
      
      handlers.pullwheel = function(ev) {
        var del = 1.05;
        if (ev.shiftKey) del = 1.005;
        var ds = ev.deltaY < 0 ? del : (1 / del);
        handlers.setZoom(ds);
      };
      
      handlers.user2wheel = function(ev) {
        var sub = self.getObj(activeSubscene),
            code = sub.callbacks.wheel.rotate;
        if (code) {
          var fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
          fn.call(self, ev.deltaY < 0 ? 1 : 2);
        }        
      };
        
      handlers.wheelHandler = function(ev) {
        var coords = self.relMouseCoords(ev);
        coords.y = self.canvas.height - coords.y;
        activeSubscene = self.whichSubscene(coords);
        var sub = self.getObj(activeSubscene), f,
            handler = sub.par3d.mouseMode.wheel,
            evlocal;
            
        ev.deltaY = ev.deltaY || ev.detail || ev.deltaX || ev.wheelDelta;
                      
        switch(handler) {
          case "none": break;
          case "push":
          case "pull":
          case "user2":
            f = handlers[handler + "wheel"];
            if (f) {
              evlocal = {};
              evlocal.deltaY = ev.deltaY;
              evlocal.shiftKey = ev.shiftKey;
              evlocal.preventDefault = function() { ev.preventDefault(); };
              f.call(self, evlocal);
            }
            break;
          default: 
            evlocal = {};
            evlocal.preventDefault = function() { ev.preventDefault(); };
            evlocal.which = 4;
            evlocal.clientX = self.canvas.width/2;
            evlocal.clientY = self.canvas.height/2;
            self.canvas.onpointerdown(evlocal);
            evlocal.clientX += ev.deltaX;
            evlocal.clientY += ev.deltaY;
            handlers.onpointermove(evlocal);
            self.canvas.onpointerup(evlocal);
        }
        ev.preventDefault();
      };
      
      handlers.get_finger_dist = function(ev) {
        var diffX = ev.touches[0].clientX - ev.touches[1].clientX,
            diffY = ev.touches[0].clientY - ev.touches[1].clientY;
        return Math.sqrt(diffX * diffX + diffY * diffY); 
      };
      
      handlers.touchstart = function(ev) {
        var touch = ev.touches[0],
          mouseEvent = new MouseEvent("pointerdown",
            {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
        ev.preventDefault();
        if (ev.touches.length === 2) {
          var coords = self.relMouseCoords(touch);
          coords.y = self.canvas.height-coords.y;
          activeSubscene = self.whichSubscene(coords);
          handlers.finger_dist0 = handlers.get_finger_dist(ev);
          handlers.zoomdown(coords.x, coords.y);
        }
        self.dispatchEvent(mouseEvent);
      };
      
      handlers.touchend = function(ev) {
        var mouseEvent;
        ev.preventDefault();
        if (ev.touches.length === 1) {
          mouseEvent = new MouseEvent("pointerup", {});
          self.dispatchEvent(mouseEvent);
        }
      };
      
      handlers.touchmove = function(ev) {
        var touch = ev.touches[0],
          mouseEvent;
        ev.preventDefault();
        if (ev.touches.length > 1) {
          var coords = self.relMouseCoords(touch),
              new_dist = handlers.get_finger_dist(ev);
          coords.y = self.canvas.height*Math.log(handlers.finger_dist0/new_dist) + handlers.y0zoom;
          handlers.zoommove(coords.x, coords.y);
        } else {
          mouseEvent = new MouseEvent("pointermove",
          {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          self.dispatchEvent(mouseEvent);
        }
      };

      self.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
      self.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
      self.canvas.addEventListener("touchstart", handlers.touchstart, {passive: false});
      self.canvas.addEventListener("touchend", handlers.touchend, {passive: false});
      self.canvas.addEventListener("touchmove", handlers.touchmove, {passive: false});
	  };
</script>
<script>    /**
     * Methods related to initialization
     * @name ___METHODS_FOR_INITIALIZATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Initial test for WebGL
     */
    rglwidgetClass.prototype.initGL0 = function() {
      if (!window.WebGLRenderingContext){
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org");
        return;
      }
    };

    /**
     * Initialize WebGL
     * @returns { Object } the WebGL context
     */
    rglwidgetClass.prototype.initGL = function() {
      var self = this, success = false;
      if (this.gl) {
      	if (!this.drawing && this.gl.isContextLost())
          this.restartCanvas();
        else
          return this.gl;
      }
      // if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
      this.canvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      this.canvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
               this.canvas.getContext("experimental-webgl", this.webGLoptions);
      success = !!(this.gl && this.gl instanceof WebGLRenderingContext);
      if (!success)
        this.alertOnce("Your browser does not support WebGL. See http://get.webgl.org"); 
      this.index_uint = this.gl.getExtension("OES_element_index_uint");
      var save = this.startDrawing();
      Object.keys(this.scene.objects).forEach(function(key){
        self.initObjId(parseInt(key, 10));
        });
      this.stopDrawing(save);
      return this.gl;
    };

    /**
     * Resize the display to match element
     * @param { Object } el - DOM element to match
     */
    rglwidgetClass.prototype.resize = function(el) {
      this.canvas.width = el.width;
      this.canvas.height = el.height;
    };

    /**
     * Initialize the sphere object
     */
    rglwidgetClass.prototype.initSphere = function(sections, segments) {
      var v = [], phi = [], theta = [], it = [], centers = [],
           i, j, k, ind, mod1, pole, result = {};
       
      for (i = 0; i < sections - 1; i++) {
        phi.push((i + 1)/sections - 0.5);
      }

      for (j = 0; j < segments; j++) {
        theta.push(2*j/segments);
        for (i = 0; i < sections - 1; i++) {
          /* These are [x,y,z,s,t]: */
          v.push([Math.sin(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),
                  Math.sin(Math.PI*phi[i]),
                  Math.cos(Math.PI*theta[j]) * Math.cos(Math.PI*phi[i]),                               
                  theta[j]/2,
                  phi[i] + 0.5]);
        }
      }
      pole = v.length;
      v.push([0, -1, 0, 0, 0]); 
      v.push([0,  1, 0, 0, 1]);
      result.values = new Float32Array(rglwidgetClass.flatten(v));
      result.vertexCount = v.length;
      
      mod1 = segments*(sections - 1);
      for (j = 0; j < segments; j++) {
        for (i = 0; i < sections - 2; i++) {
          ind = i + (sections - 1)*j;
          it.push([ind % mod1, 
                   (ind + sections - 1) % mod1,
                   (ind + sections) % mod1]);
          it.push([ind % mod1, 
                   (ind + sections) % mod1,
                   (ind + 1) % mod1]);
        }
        it.push([pole, 
                 ((j + 1)*(sections - 1)) % mod1,
                 ((j + 1)*(sections - 1) - sections + 1) % mod1]);
        it.push([pole + 1, 
                 ((j + 1)*(sections - 1) - 1) % mod1,
                 ((j + 1)*(sections - 1) + sections - 2) % mod1]);
      }
      result.it = new Uint16Array(rglwidgetClass.flatten(it));
      
      for (i = 0; i < it.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 3; k++) {// vertices
            centers[i][j] += v[it[i][k]][j]/3;
          }
        }
      }
      result.centers = centers;
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:0, radofs:-1, oofs:-1,
                         tofs:3, nextofs:-1, pointofs:-1, stride:5};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "sphere";
      this.sphere = result;
      this.initShapeGL(this.sphere);
    };

    /**
     * Initialize the cube object
     */
    rglwidgetClass.prototype.initCube = function() {
   var v = [[0, 0, 0], [1, 0, 0], 
            [0, 1, 0], [1, 1, 0], 
            [0, 0, 1], [1, 0, 1],
            [0, 1, 1], [1, 1, 1]],
          ib = [[0, 2, 3, 1], 
                [2, 6, 7, 3], 
                [1, 3, 7, 5], 
                [0, 4, 6, 2], 
                [0, 1, 5, 4], 
                [4, 5, 7, 6]], 
          centers = [], i, j, k, 
          i0, i1, i2,
          normal, result = {};
       
      for (i = 0; i < ib.length; i++) {
        centers.push([0,0,0]);
        for (j = 0; j < 3; j++) { // x,y,z
          for (k = 0; k < 4; k++) {// vertices
            centers[i][j] += v[ib[i][k]][j]/4;
          }
        }
      }
      result.centers = centers; 
      result.values = new Float32Array(6*4*3*2);
      result.vertexCount = 24;
      result.vertices = new Array(24);
      result.normals = new Array(24);
      for (i=0; i < 6; i++) {
        for (j=0; j < 4; j++) {
          i0 = ib[i][j];
          result.vertices[4*i + j] = v[i0];
          i1 = ib[i][(j + 1) % 4];
          i2 = ib[i][(j + 2) % 4];
          if (j === 0)
            normal = rglwidgetClass.normalize(rglwidgetClass.xprod(rglwidgetClass.vdiff(v[i1], v[i0]),
                                  rglwidgetClass.vdiff(v[i2], v[i0])));
          result.normals[4*i + j] = normal;
          for (k=0; k < 3; k++) {
            result.values[i*24 + j*6 + k] = v[i0][k];
            result.values[i*24 + j*6 + 3 + k] = normal[k];
          }
        }
        for (j=0; j<4; j++)
          ib[i][j] = 4*i + j;
      }
      result.ib = new Uint16Array(rglwidgetClass.flatten(ib));
      
      result.vOffsets = {vofs:0, cofs:-1, nofs:3, radofs:-1, oofs:-1,
                         tofs:-1, nextofs:-1, pointofs:-1, stride:6};

      result.f = [];
      result.indices = {};

      result.colorCount = 1;
      result.type = "quads";
      this.cube = result;
      this.initShapeGL(this.cube);
    };
    

    /**
     * Do the gl part of initializing the sphere and cube
     */
    rglwidgetClass.prototype.initShapeGL = function(shape) {
      var gl = this.gl || this.initGL();
      if (gl.isContextLost()) return;
      shape.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, shape.buf);
      gl.bufferData(gl.ARRAY_BUFFER, shape.values, gl.STATIC_DRAW);
      shape.ibuf = [gl.createBuffer(), gl.createBuffer()];
      return;
    };

    /* Initialize common sphere object from spheres object
    */
    rglwidgetClass.prototype.initShapeFromObj = function(shape, obj) {
      var i, pass, f, mode, self = this,
        /* This function selects things that would be
           the back, ignoring perspective -- this is what 
           we want for the bounding box decoration. */
        is_back = function(i) {
                var normal = [].concat(shape.normals[i]),
                  pt = shape.vertices[i];
                normal.push(-rglwidgetClass.dotprod(normal, pt));
                normal = rglwidgetClass.multVM(normal, self.normMatrix);
                return normal[2] < 0 || (normal[2] === 0 && normal[0] < 0);
              }; 
      shape.ofsLoc = obj.ofsLoc;
      shape.texLoc = obj.texLoc;
      shape.texture = obj.texture;
      shape.sampler = obj.sampler;
      shape.uFogMode = obj.uFogMode;
      shape.uFogColor = obj.uFogColor;
      shape.uFogParms = obj.uFogParms;
      shape.userAttribLocations = obj.userAttribLocations;
      shape.userUniformLocations = obj.userUniformLocations;
      shape.normLoc = obj.normLoc;
      shape.invPrMatLoc = obj.invPrMatLoc;
      shape.clipLoc = obj.clipLoc;
      shape.nextLoc = obj.nextLoc;
      shape.pointLoc = obj.pointLoc;
      shape.aspectLoc = obj.aspectLoc;
      shape.lwdLoc = obj.lwdLoc;
      shape.prog = obj.prog;
      shape.material = obj.material;
      shape.flags = obj.flags;
      shape.defFlags = obj.defFlags;
      shape.someHidden = obj.someHidden;
      shape.fastTransparency = obj.fastTransparency;
      shape.nlights = obj.nlights;
      shape.emission = obj.emission;
      shape.emissionLoc = obj.emissionLoc;
      shape.shininess = obj.shininess;
      shape.shininessLoc = obj.shininessLoc;
      shape.ambient = obj.ambient;
      shape.ambientLoc = obj.ambientLoc;
      shape.specular = obj.specular;
      shape.specularLoc = obj.specularLoc;
      shape.diffuse = obj.diffuse;
      shape.diffuseLoc = obj.diffuseLoc;
      shape.lightDir = obj.lightDir;
      shape.lightDirLoc = obj.lightDirLoc;
      shape.viewpoint = obj.viewpoint;
      shape.viewpointLoc = obj.viewpointLoc;
      shape.finite = obj.finite;
      shape.finiteLoc = obj.finiteLoc;
      shape.prMatLoc = obj.prMatLoc;
      shape.mvMatLoc = obj.mvMatLoc;
      shape.normMatLoc = obj.normMatLoc;
      shape.frontLoc = obj.frontLoc;
      shape.index_uint = false;
      shape.is_transparent = obj.is_transparent;
      shape.ignoreExtent = obj.ignoreExtent;
      if (shape.passes !== obj.passes ||
          JSON.stringify( shape.pmode) !== JSON.stringify(obj.pmode)) {
        shape.passes = obj.passes;
        shape.pmode = obj.pmode;
        for (pass = 0; pass < obj.passes; pass++) {
          mode =  shape.pmode[pass];
          if (typeof  shape.indices[mode] === "undefined") {
            f = [];
            switch (mode) {
            case "culled": break;
            case "points":
              f.length =  shape.vertexCount;
              for (i=0; i < f.length; i++)
                f[i] = i;
              break;
            case "lines":
              if (typeof shape.it !== "undefined") {
                f.length = 2* shape.it.length;
      	        for (i=0; i <  shape.it.length/3; i++) {
      	          f[6*i] =  shape.it[3*i];
      	          f[6*i + 1] =  shape.it[3*i + 1];
      	          f[6*i + 2] =  shape.it[3*i + 1];
      	          f[6*i + 3] =  shape.it[3*i + 2];
      	          f[6*i + 4] =  shape.it[3*i + 2];
      	          f[6*i + 5] =  shape.it[3*i];
      	        }
              } else {
                f.length = 2*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[8*i] = shape.ib[4*i];
                  f[8*i + 1] = shape.ib[4*i + 1];
                  f[8*i + 2] = shape.ib[4*i + 1];
                  f[8*i + 3] = shape.ib[4*i + 2];
                  f[8*i + 4] = shape.ib[4*i + 2];
                  f[8*i + 5] = shape.ib[4*i + 3];
                  f[8*i + 6] = shape.ib[4*i + 3];
                  f[8*i + 7] = shape.ib[4*i];
                }
              }
      	      break;
      	    case "filled":
      	      if (typeof shape.it !== "undefined")
      	        f =  shape.it;
      	      else if (typeof shape.ib !== "undefined") {
      	        f.length = 1.5*shape.ib.length;
                for (i=0; i < shape.ib.length/4; i++) {
                  f[6*i] = shape.ib[4*i];
                  f[6*i+1] = shape.ib[4*i + 1];
                  f[6*i+2] = shape.ib[4*i + 2];
                  f[6*i+3] = shape.ib[4*i];
                  f[6*i+4] = shape.ib[4*i + 2];
                  f[6*i+5] = shape.ib[4*i + 3];
                }      	        
      	      }
      	      break;
      	    }              
            shape.indices[mode] = new Uint16Array(f);
          }
        }
      }       
      for (pass = 0; pass < obj.passes; pass++) {
        mode =  shape.pmode[pass];
        shape.f[pass] =  shape.indices[mode];
        if (typeof obj.draw_front !== "undefined" &&
            !obj.draw_front) {
          shape.f[pass] = shape.f[pass].filter(is_back);   
        }
      }
      // console.log("Names in  shapes not in  shape:"+JSON.stringify(rglwidgetClass.keydiff(obj,  shape)));
       shape.initialized = true;
    };

    /**
     * Initialize a subscene
     * @param { number } id - id of subscene.
     */
    rglwidgetClass.prototype.initSubscene = function(id) {
      var sub = this.getObj(id),
          i, obj;

      if (sub.type !== "subscene")
        return;

      sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
      sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
      sub.par3d.userProjection.transpose();
      sub.par3d.listeners = [].concat(sub.par3d.listeners);
      sub.backgroundId = undefined;
      sub.subscenes = [];
      sub.clipplanes = [];
      sub.transparent = [];
      sub.opaque = [];
      sub.lights = [];
      sub.needsBegin = true;
      if (typeof sub.objects !== "undefined")
        sub.objects = [].concat(sub.objects); /* make sure it's an array */
      for (i=0; i < sub.objects.length; i++) {
        obj = this.getObj(sub.objects[i]);
        if (typeof obj === "undefined") {
          sub.objects.splice(i, 1);
          i--;
        } else if (obj.type === "background")
          sub.backgroundId = obj.id;
        else
          sub[this.whichList(obj.id)].push(obj.id);
      }
    };
    
    rglwidgetClass.prototype.initBBox = function(obj) {
      if (!this.cube)
        this.initCube();
      obj.cube = {id: obj.id + 0.1,
                    type: "quads",
                    flags: obj.flags,
                    material: obj.material,
                    colors: [obj.colors[0]],
                    vertices: this.cube.vertices,
                    normals: this.cube.normals,
                    draw_front: obj.draw_front,
                    initialized: false
        };
      if (this.getMaterial(obj.cube, "front") !==
          this.getMaterial(obj.cube, "back"))
        /* jshint bitwise: false */  
        obj.cube.flags |= rglwidgetClass.f_is_twosided;
        /* jshint bitwise: true */
      this.scene.objects[obj.cube.id] = obj.cube;
      obj.ticks = {id: obj.id + 0.2,
                     type: "lines",
                     flags: rglwidgetClass.f_has_fog,
                     material: obj.material,
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     axes: obj.axes,
                     initialized: false
      };
      this.scene.objects[obj.ticks.id] = obj.ticks;
      obj.labels = {id: obj.id + 0.3,
                     type: "text",
                     flags: rglwidgetClass.f_has_fog + 
                            rglwidgetClass.f_fixed_size + 
                            rglwidgetClass.f_fixed_quads,
                     material: {lit: false},
                     colors: (obj.colors.length > 1 ? [obj.colors[1]] : [obj.colors[0]]),
                     cex: [[1]],
                     family: [["sans"]],
                     font: [[1]],
                     adj: [[0.5, 0.5, 0.5]],
                     ignoreExtent: true,
                     initialized: false
      };
      this.scene.objects[obj.labels.id] = obj.labels;
      obj.initialized = true;
    };
    
    rglwidgetClass.prototype.initBackground = function(obj) {
      var material, fl = obj.defFlags;
      if (typeof obj.ids !== "undefined")
        obj.quad = rglwidgetClass.flatten([].concat(obj.ids));
      else if (obj.sphere) {
        fl.has_normals = true;
        fl.needs_vnormal = true;
        obj.defFlags = fl;
        material = obj.material;
        material.front = "culled";
        obj.vertices = [[0,0,0]];
        obj.texcoords = [[0,0]];
      }  
    };

    /**
     * Initialize object for display
     * @param { number } id - id of object to initialize
     */
    rglwidgetClass.prototype.initObjId = function(id) {
      if (typeof id !== "number") {
        this.alertOnce("initObj id is "+typeof id);
      }
      return this.initObj(this.getObj(id));
    };

    /**
     * Initialize object for display
     * @param { Object } obj - object to initialize
     */
    rglwidgetClass.prototype.initObj = function(obj) {
      var type = obj.type, 
          flags = obj.flags,
          normals = obj.normals,
          round_points = (typeof obj.material === "undefined") ?
            false : this.getMaterial(obj, "point_antialias"),
          has_indices = typeof obj.indices !== "undefined",
          has_spheres = type === "spheres" || 
                        (type === "background" && obj.sphere),
          sprites_3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          depth_sort = rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort),
          gl = this.gl || this.initGL(),
          fl, polygon_offset,
          texinfo, drawtype, nclipplanes, f, nrows, oldrows,
          i,j,v,v1,v2, mat, uri, matobj, pass, pmode,
          dim, nx, nz, nrow, shaders;

    obj.initialized = true;
    
    obj.someHidden = false; // used in selection
    
    this.expandBufferedFields(obj);
    
    if (type === "subscene")
      return;
      
    obj.defFlags = fl = rglwidgetClass.getDefFlags(flags, type, normals, round_points);
  
    obj.is_transparent = fl.is_transparent;
  
    if (type === "bboxdeco")
      return this.initBBox(obj);
      
    if (has_spheres && typeof this.sphere === "undefined")
      this.initSphere(16, 16);

    if (type === "light") {
      obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
      obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
      obj.specular = new Float32Array(obj.colors[2].slice(0,3));
      obj.lightDir = new Float32Array(obj.vertices[0]);
      return;
    }

    if (type === "clipplanes") {
      obj.vClipplane = rglwidgetClass.flatten(rglwidgetClass.cbind(obj.normals, obj.offsets));
      return;
    }

    if (type === "background") {
      this.initBackground(obj);
      if (!obj.sphere)
        return;
    }

    polygon_offset = this.getMaterial(obj, "polygon_offset");
    if (polygon_offset[0] !== 0 || polygon_offset[1] !== 0)
      obj.polygon_offset = polygon_offset;

    if (fl.is_transparent) {
      depth_sort = ["triangles", "quads", "surface",
                    "spheres", "sprites", "text",
                    "planes"].indexOf(type) >= 0;
    }
    
    if (fl.is_brush)
      this.initSelection(obj.id);

    if (typeof obj.vertices === "undefined")
      obj.vertices = [];

    v = obj.vertices;
    if (has_indices)
      obj.vertexCount = obj.indices.length;
    else
      obj.vertexCount = v.length;
      
    if (!obj.vertexCount) return;

    if (fl.is_twosided && !fl.has_normals && type !== "background") {
      if (typeof obj.userAttributes === "undefined")
        obj.userAttributes = {};
      v1 = Array(v.length);
      v2 = Array(v.length);
      if (obj.type === "triangles" || obj.type === "quads") {
      	if (obj.type === "triangles")
      	  nrow = 3;
      	else
      	  nrow = 4;
        for (i=0; i<Math.floor(v.length/nrow); i++)
          for (j=0; j<nrow; j++) {
            v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
            v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
          }
      } else if (obj.type === "surface") {
        dim = obj.dim[0];
        nx = dim[0];
        nz = dim[1];
        for (j=0; j<nx; j++) {
          for (i=0; i<nz; i++) {
            if (i+1 < nz && j+1 < nx) {
              v2[j + nx*i] = v[j + nx*(i+1)];
              v1[j + nx*i] = v[j+1 + nx*(i+1)];
            } else if (i+1 < nz) {
              v2[j + nx*i] = v[j-1 + nx*i];
              v1[j + nx*i] = v[j + nx*(i+1)];
            } else {
              v2[j + nx*i] = v[j + nx*(i-1)];
              v1[j + nx*i] = v[j-1 + nx*(i-1)];
            }
          }
        }
      }
      obj.userAttributes.aPos1 = v1;
      obj.userAttributes.aPos2 = v2;
    }

    if (!sprites_3d) {
      if (gl.isContextLost()) return;
      if (typeof obj.prog !== "undefined") {
        gl.deleteProgram(obj.prog);
        obj.prog = undefined;
      }
      
      shaders = this.getShaders(obj);
      
      obj.prog = gl.createProgram();
      gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
                      shaders.vertex ));
      gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
                      shaders.fragment ));
      //  Force aPos to location 0, aCol to location 1
      gl.bindAttribLocation(obj.prog, 0, "aPos");
      gl.bindAttribLocation(obj.prog, 1, "aCol");
      gl.linkProgram(obj.prog);
      var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
      if (!linked) {

        // An error occurred while linking
        var lastError = gl.getProgramInfoLog(obj.prog);
        console.warn("Error in program linking:" + lastError);

        gl.deleteProgram(obj.prog);
        return;
      }
    }

    if (type === "text") {
      texinfo = this.drawTextToCanvas(obj.texts,
                                      rglwidgetClass.flatten(obj.cex),
                                      rglwidgetClass.flatten(obj.family),
                                      rglwidgetClass.flatten(obj.family));
    }

    if (fl.fixed_quads && !sprites_3d) {
      obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
    }

    if (fl.has_texture || type === "text") {
      if (!obj.texture) {
        obj.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
      }
      obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
      obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
    }
    
    if (fl.has_fog && !sprites_3d) {
      obj.uFogMode = gl.getUniformLocation(obj.prog, "uFogMode");
      obj.uFogColor = gl.getUniformLocation(obj.prog, "uFogColor");
      obj.uFogParms = gl.getUniformLocation(obj.prog, "uFogParms");
    }

    if (fl.has_texture) {
      mat = obj.material;
      if (typeof mat.uri !== "undefined")
        uri = mat.uri;
      else if (typeof mat.uriElementId === "undefined") {
        matobj = this.getObj(mat.uriId);
        if (typeof matobj !== "undefined") {
          uri = matobj.material.uri;
        } else {
          uri = "";
        }
      } else
        uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;

      this.loadImageToTexture(uri, obj.texture);
    }

    if (type === "text") {
      this.handleLoadedTexture(obj.texture, this.textureCanvas);
    }

    var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
        nextofs = -1, pointofs = -1, alias, colors, key, selection,
        filter, adj, offset, attr, last, options;

    obj.alias = undefined;
    
    colors = obj.colors;

    j = this.scene.crosstalk.id.indexOf(obj.id);
    if (j >= 0) {
      key = this.scene.crosstalk.key[j];
      options = this.scene.crosstalk.options[j];
      colors = colors.slice(0); 
      for (i = 0; i < v.length; i++)
        colors[i] = obj.colors[i % obj.colors.length].slice(0);
      if ( (selection = this.scene.crosstalk.selection) &&
           (selection.length || !options.selectedIgnoreNone) )
        for (i = 0; i < v.length; i++) {
          if (!selection.includes(key[i])) {
            if (options.deselectedColor)
              colors[i] = options.deselectedColor.slice(0);
            colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
          } else if (options.selectedColor)
            colors[i] = options.selectedColor.slice(0);
        }
      if ( (filter = this.scene.crosstalk.filter) )
        for (i = 0; i < v.length; i++) 
          if (!filter.includes(key[i])) {
            if (options.filteredColor)
              colors[i] = options.filteredColor.slice(0);
            colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
          }
    }  
    
    nc = obj.colorCount = colors.length;
    if (nc > 1) {
      cofs = stride;
      stride = stride + 4;
      v = rglwidgetClass.cbind(v, colors);
    } else {
      cofs = -1;
      obj.onecolor = rglwidgetClass.flatten(colors);
    }

    if (fl.has_normals && !has_spheres) {
      nofs = stride;
      stride = stride + 3;
      v = rglwidgetClass.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
    } else
      nofs = -1;

    if (typeof obj.radii !== "undefined") {
      radofs = stride;
      stride = stride + 1;
      // FIXME:  always concat the radii?
      if (obj.radii.length === v.length) {
        v = rglwidgetClass.cbind(v, obj.radii);
      } else if (obj.radii.length === 1) {
        v = v.map(function(row) { return row.concat(obj.radii[0]);});
      }
    } else
      radofs = -1;
      
    // Add default indices
    if (has_indices) {
      f = Array(obj.indices.length);
      for (i = 0; i < f.length; i++)
        f[i] = obj.indices[i] - 1;
    } else {
      f = Array(v.length);
      for (i = 0; i < v.length; i++)
        f[i] = i;
    }
    obj.f = [f,f];

    if (type === "sprites" && !sprites_3d) {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      fnew = new Array(4*v.length);
      alias = new Array(v.length);
      var rescale = fl.fixed_size ? 72 : 1,
          size = obj.radii, s = rescale*size[0]/2;
      last = v.length;
      f = obj.f[0];
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = obj.adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset);
        if (size.length > 1)
          s = rescale*size[i]/2;
        adj[0] = 2*s*(adj[0] - 0.5);
        adj[1] = 2*s*(adj[1] - 0.5);
        adj[2] = 2*s*(adj[2] - 0.5);
        vnew[i]  = v[i].concat([0,0]).concat([-s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i] = f[i];
        vnew[last]= v[i].concat([1,0]).concat([s-adj[0],
                                              -s-adj[1],
                                              -adj[2]]);
        fnew[4*i+1] = last++;
        vnew[last]= v[i].concat([1,1]).concat([s-adj[0],
                                               s-adj[1],
                                               -adj[2]]);
        fnew[4*i+2] = last++;
        vnew[last]= v[i].concat([0,1]).concat([-s-adj[0],
                                                s-adj[1],
                                                -adj[2]]);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (type === "text") {
      tofs = stride;
      stride += 2;
      oofs = stride;
      stride += 3;
      vnew = new Array(4*v.length);
      f = obj.f[0];
      fnew = new Array(4*f.length);
      alias = new Array(v.length);
      last = v.length;
      adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        offset = adj[0];
      } else
        offset = 0;
      for (i=0; i < v.length; i++) {
        adj = this.getAdj(obj, i, offset, obj.texts[i]);
        vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
        fnew[4*i] = f[i];
        vnew[last] = v[i].concat([1,-0.5]).concat(adj);
        fnew[4*i+1] = last++;
        vnew[last] = v[i].concat([1, 1.5]).concat(adj);
        fnew[4*i+2] = last++;
        vnew[last] = v[i].concat([0, 1.5]).concat(adj);
        fnew[4*i+3] = last++;
        alias[i] = [last-3, last-2, last-1];
        for (j=0; j < 4; j++) {
          v1 = vnew[fnew[4*i+j]];
          v1[oofs] = 2*(v1[tofs]-v1[oofs])*texinfo.widths[i];
          v1[oofs+1] = 2*(v1[tofs+1]-v1[oofs+1])*texinfo.textHeights[i];
          v1[oofs+2] = 2*(0.5-v1[oofs+2])*texinfo.textHeights[i]/1000.0;
          v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
          v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
              v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
          vnew[fnew[4*i+j]] = v1;
        }
      }
      v = vnew;
      obj.vertexCount = v.length;
      obj.f = [fnew, fnew];
    } else if (typeof obj.texcoords !== "undefined") {
      tofs = stride;
      stride += 2;
      oofs = -1;
      v = rglwidgetClass.cbind(v, obj.texcoords);
    } else {
      tofs = -1;
      oofs = -1;
    }
    
    obj.alias = alias;
                          
    if (typeof obj.userAttributes !== "undefined") {
      obj.userAttribOffsets = {};
      obj.userAttribLocations = {};
      obj.userAttribSizes = {};
      for (attr in obj.userAttributes) {
      	obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
      	if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
      	  obj.userAttribOffsets[attr] = stride;
      	  v = rglwidgetClass.cbind(v, obj.userAttributes[attr]);
      	  stride = v[0].length;
      	  obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
      	} else
      	  console.warn("attribute '"+attr+"' not found in object "+obj.id+".");
      }
    }

    if (typeof obj.userUniforms !== "undefined" ||
        typeof obj.userTextures !== "undefined") {
      obj.userUniformLocations = {};
      for (attr in obj.userUniforms) {
        obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
        if (obj.userUniformLocations[attr] === null)
          console.warn("uniform '"+attr+"' not found in object "+obj.id+".");
      }
      for (attr in obj.userTextures) {
        var texture = obj.userTextures[attr];
        texture.texture = gl.createTexture();
        // This is a trick from https://stackoverflow.com/a/19748905/2554330 to avoid warnings
        gl.bindTexture(gl.TEXTURE_2D, texture.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
              new Uint8Array([255,255,255, 255])); // white
        texture.sampler = gl.getUniformLocation(obj.prog, attr);
        if (texture.sampler === null)
          console.warn("sampler '"+attr+"' not found in object "+obj.id+".");
        uri = texture.uri;
        this.loadImageToTexture(uri, texture.texture);
      }
    }

    if (sprites_3d) {
      obj.userMatrix = new CanvasMatrix4();
      obj.userMatrix.load(rglwidgetClass.flatten(obj.usermatrix));
      obj.objects = rglwidgetClass.flatten([].concat(obj.ids));
      fl.is_lit = false;
      obj.adj = rglwidgetClass.flatten(obj.adj);
      if (typeof obj.pos !== "undefined") {
        obj.pos = rglwidgetClass.flatten(obj.pos);
        obj.offset = obj.adj[0];
      } else
        obj.offset = 0;
        
      for (i=0; i < obj.objects.length; i++)
        this.initObjId(obj.objects[i]);
    }

    nclipplanes = this.countClipplanes();
    if (nclipplanes && !sprites_3d) {
      obj.clipLoc = gl.getUniformLocation(obj.prog,"vClipplane");
    }

    if (fl.is_lit) {
      obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
      obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(obj, "emission")));
      obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
      obj.shininess = this.getMaterial(obj, "shininess");
      obj.nlights = this.countLights();
      if (obj.nlights > 0) {
        obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(obj, "ambient")));
        obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(obj, "specular")));
        obj.ambientLoc = gl.getUniformLocation(obj.prog, "ambient");
        obj.specularLoc = gl.getUniformLocation(obj.prog, "specular");
        obj.diffuseLoc = gl.getUniformLocation(obj.prog, "diffuse" );
        obj.lightDirLoc = gl.getUniformLocation(obj.prog, "lightDir");
        obj.viewpointLoc = gl.getUniformLocation(obj.prog, "viewpoint");
        obj.finiteLoc = gl.getUniformLocation(obj.prog, "finite" );
      }
    }
    
    obj.passes = fl.is_twosided + 1;
    obj.pmode = new Array(obj.passes);
    for (pass = 0; pass < obj.passes; pass++) {
      if (type === "triangles" || type === "quads" || type === "surface" || has_spheres)
      	pmode = this.getMaterial(obj, (pass === 0) ? "front" : "back");
      else pmode = "filled";
      obj.pmode[pass] = pmode;
    }
    if (!has_spheres) {
      obj.f.length = obj.passes;
      for (pass = 0; pass < obj.passes; pass++) {
      	f = fnew = obj.f[pass];
        pmode = obj.pmode[pass];
      	if (pmode === "culled")
      	  f = [];
        else if (pmode === "points") {
          // stay with default
        } else if ((type === "quads" || type === "text" ||
             type === "sprites") && !sprites_3d) {
          nrows = Math.floor(obj.vertexCount/4);
          if (pmode === "filled") {
            fnew = Array(6*nrows);
            for (i=0; i < nrows; i++) {
              fnew[6*i] = f[4*i];
              fnew[6*i+1] = f[4*i + 1];
              fnew[6*i+2] = f[4*i + 2];
              fnew[6*i+3] = f[4*i];
              fnew[6*i+4] = f[4*i + 2];
              fnew[6*i+5] = f[4*i + 3];
            }
          } else {
            fnew = Array(8*nrows);
            for (i=0; i < nrows; i++) {
              fnew[8*i] = f[4*i];
              fnew[8*i+1] = f[4*i + 1];
              fnew[8*i+2] = f[4*i + 1];
              fnew[8*i+3] = f[4*i + 2];
              fnew[8*i+4] = f[4*i + 2];
              fnew[8*i+5] = f[4*i + 3];
              fnew[8*i+6] = f[4*i + 3];
              fnew[8*i+7] = f[4*i];
            }
          }
        } else if (type === "triangles") {
          nrows = Math.floor(obj.vertexCount/3);
          if (pmode === "filled") {
            fnew = Array(3*nrows);
            for (i=0; i < fnew.length; i++) {
              fnew[i] = f[i];
            }
          } else if (pmode === "lines") {
            fnew = Array(6*nrows);
      	    for (i=0; i < nrows; i++) {
      	      fnew[6*i] = f[3*i];
      	      fnew[6*i + 1] = f[3*i + 1];
      	      fnew[6*i + 2] = f[3*i + 1];
      	      fnew[6*i + 3] = f[3*i + 2];
      	      fnew[6*i + 4] = f[3*i + 2];
      	      fnew[6*i + 5] = f[3*i];
      	    }
          }
        } else if (has_spheres) {
          // default
        } else if (type === "surface") {
          dim = obj.dim[0];
          nx = dim[0];
          nz = dim[1];
          if (pmode === "filled") {
            fnew = [];
            for (j=0; j<nx-1; j++) {
              for (i=0; i<nz-1; i++) {
                fnew.push(f[j + nx*i],
                       f[j + nx*(i+1)],
                       f[j + 1 + nx*(i+1)],
                       f[j + nx*i],
                       f[j + 1 + nx*(i+1)],
                       f[j + 1 + nx*i]);
              }
            }
          } else if (pmode === "lines") {
            fnew = [];
            for (j=0; j<nx; j++) {
              for (i=0; i<nz; i++) {
                if (i+1 < nz)
                  fnew.push(f[j + nx*i],
                         f[j + nx*(i+1)]);
                if (j+1 < nx)
                  fnew.push(f[j + nx*i],
                         f[j+1 + nx*i]);
              }
            }
          }
        }
        obj.f[pass] = fnew;
        if (depth_sort) {
          drawtype = "DYNAMIC_DRAW";
        } else {
          drawtype = "STATIC_DRAW";
        }
      }
    }
    
    if (fl.fat_lines) {
      alias = undefined;
      obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
      obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
      obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
      obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
      // Expand vertices to turn each segment into a pair of triangles
        
      	for (pass = 0; pass < obj.passes; pass++) {
      	  f = obj.f[pass];	
          oldrows = f.length;
      	  if (obj.pmode[pass] === "lines") 
      	    break;
      	}
      
      if (type === "linestrip") 
        nrows = 4*(oldrows - 1); 
      else
        nrows = 2*oldrows;
      vnew = new Array(nrows);
      fnew = new Array(1.5*nrows);
      
      // We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
      // added.
      // We do this by copying the originals in the first pass, adding the new attributes, then in a 
      // second pass add new vertices at the end.

      for (i = 0; i < v.length; i++) {
        vnew[i] = v[i].concat([0,0,0,0,0]); 
      }

      nextofs = stride;
      pointofs = stride + 3;
      stride = stride + 5;
            
      // Now add the extras
      var ind, k;
      last = v.length - 1;
      ind = 0;
      alias = new Array(f.length);
      for (i = 0; i < f.length; i++)
        alias[i] = [];
      for (i = 0; i < f.length - 1; i++) {
      	if (type !== "linestrip" && i % 2 === 1)
      	  continue;
      	k = ++last;
      	vnew[k] = vnew[f[i]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i+1]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = -1;
      	fnew[ind] = k;
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+1] = last;
      	alias[f[i]].push(last-1, last);
      	last++;
      	k = last;
      	vnew[k] = vnew[f[i+1]].slice();
      	for (j=0; j<3; j++)
      	  vnew[k][nextofs + j] = vnew[f[i]][j];
      	vnew[k][pointofs] = -1;
      	vnew[k][pointofs+1] = 1;
      	fnew[ind+2] = k;
      	fnew[ind+3] = fnew[ind+1];
      	last++;
      	vnew[last] = vnew[k].slice();
      	vnew[last][pointofs] = 1;
      	fnew[ind+4] = last;
      	fnew[ind+5] = fnew[ind+2];
      	ind += 6;
      	alias[f[i+1]].push(last-1, last);
      }
      vnew.length = last+1;
      v = vnew;
      obj.vertexCount = v.length;
      if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
        var oldalias = obj.alias, newalias = Array(obj.alias.length);
        for (i = 0; i < newalias.length; i++) {
          newalias[i] = oldalias[i].slice();
          for (j = 0; j < oldalias[i].length; j++)
            Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
        }
        obj.alias = newalias;
      } else
        obj.alias = alias;
      
      for (pass = 0; pass < obj.passes; pass++)
      	if (type === "lines" || type === "linestrip" || obj.pmode[pass] === "lines") {
          obj.f[pass] = fnew;
        }
      
      if (depth_sort) 
        drawtype = "DYNAMIC_DRAW";
      else
        drawtype = "STATIC_DRAW";
    }
    
      for (pass = 0; pass < obj.passes; pass++) {
        if (obj.vertexCount > 65535) {
          if (this.index_uint) {
            obj.f[pass] = new Uint32Array(obj.f[pass]);
            obj.index_uint = true;
          } else
            this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
        } else {
          obj.f[pass] = new Uint16Array(obj.f[pass]);
          obj.index_uint = false;
        }
      }
    
    if (stride !== v[0].length) {
      this.alertOnce("problem in stride calculation");
    }

    obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
                    nextofs:nextofs, pointofs:pointofs, stride:stride};

    obj.values = new Float32Array(rglwidgetClass.flatten(v));

    if (!has_spheres && !sprites_3d) {
      obj.buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
      gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
      obj.ibuf = Array(obj.passes);
      obj.ibuf[0] = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
      if (fl.is_twosided) {
      	obj.ibuf[1] = gl.createBuffer();
      	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
      	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
      }
    }

    if (!sprites_3d) {
      obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
      obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");

      if (fl.fixed_size) {
        obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
      }
    }

    if (fl.needs_vnormal) {
      obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
      obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
    }

    if (fl.is_twosided) {
      obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
      if (fl.has_normals)
        obj.invPrMatLoc = gl.getUniformLocation(obj.prog, "invPrMatrix");
    }
  };
    
    /**
     * Initialize the DOM object
     * @param { Object } el - the DOM object
     * @param { Object } x - the scene data sent by JSON from R
     */
    rglwidgetClass.prototype.initialize = function(el, x) {
      this.textureCanvas = document.createElement("canvas");
      this.textureCanvas.style.display = "block";
      this.scene = x;
      this.normMatrix = new CanvasMatrix4();
      this.invPrMatrix = new CanvasMatrix4();
      this.saveMat = {};
      this.distance = null;
      this.posLoc = 0;
      this.colLoc = 1;
      if (el) {
        el.rglinstance = this;
        this.el = el;
        this.webGLoptions = el.rglinstance.scene.webGLoptions;
        this.initCanvas();
      }
      if (typeof Shiny !== "undefined") {
        var self = this;
        Shiny.addCustomMessageHandler("shinyGetPar3d",
          function(message) {
            var i, param, 
                subscene = self.getObj(message.subscene),
                parameters = [].concat(message.parameters),
                result = {tag: message.tag, subscene: message.subscene};
            if (typeof subscene !== "undefined") {
              for (i = 0; i < parameters.length; i++) {
                param = parameters[i];
                result[param] = subscene.par3d[param];
              }
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
            Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
          });
          
        Shiny.addCustomMessageHandler("shinySetPar3d",
          function(message) {
            var param = message.parameter, 
                subscene = self.getObj(message.subscene);
            if (typeof subscene !== "undefined") {
              subscene.par3d[param] = message.value;
              subscene.initialized = false;
              self.drawScene();
            } else {
              console.log("subscene "+message.subscene+" undefined.");
            }
          });
          
        Shiny.addCustomMessageHandler("resetBrush",
          function(message) {
            if (message === self.scene.selectionInput) {
              self.clearBrush(null);
              self.recordSelection(0);
            }
          });
      }
    };
    
    /**
     * Restart the WebGL canvas
     */
    rglwidgetClass.prototype.restartCanvas = function() {
      var newcanvas = document.createElement("canvas"),
          self = this;
      newcanvas.width = this.el.width;
      newcanvas.height = this.el.height;
      newcanvas.addEventListener("webglcontextrestored",
        this.onContextRestored, false);
      newcanvas.addEventListener("webglcontextlost",
        this.onContextLost, false);
      while (this.el.firstChild) {
        this.el.removeChild(this.el.firstChild);
      }
      this.el.appendChild(newcanvas);
      this.canvas = newcanvas;
      if (this.scene.javascript) {
        /* jshint evil:true */
        Function('"use strict";' + this.scene.javascript)();
        /* jshint evil:false */
      }
      this.setMouseHandlers();
      if (this.gl) 
        Object.keys(this.scene.objects).forEach(function(key){
          self.getObj(parseInt(key, 10)).texture = undefined; 
          });
      this.gl = null;
    };

    /**
     * Initialize the WebGL canvas
     */
    rglwidgetClass.prototype.initCanvas = function() {
      this.restartCanvas();
      var objs = this.scene.objects,
          self = this;
          
      /* These hold context specific data.  In Shiny, they   
         need to be deleted.  Elsewhere, they don't exist
         and these are no-ops. */
         
      delete this.cube;
      delete this.sphere;
      
      Object.keys(objs).forEach(function(key){
        self.initSubscene(parseInt(key, 10));
      });

      this.onContextRestored = function() {
        self.initGL();
        self.drawScene();
      };

      this.onContextLost = function(event) {
        if (!self.drawing)
          this.gl = null;
        event.preventDefault();
      };

      this.initGL0();
      this.lazyLoadScene = function() {
      	if (typeof self.slide === "undefined")
      	  self.slide = self.getSlide();
      	if (self.isInBrowserViewport()) {
      	  if (!self.gl || self.gl.isContextLost())
      	    self.initGL();
      	  self.drawScene();
      	}
      };
      window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
      window.addEventListener("load", this.lazyLoadScene, false);
      window.addEventListener("resize", this.lazyLoadScene, false);
      window.addEventListener("scroll", this.lazyLoadScene, false);
      this.slide = this.getSlide();
      if (this.slide) {
        if (typeof this.slide.rgl === "undefined")
          this.slide.rgl = [this];
        else
          this.slide.rgl.push(this);
        if (this.scene.context.rmarkdown) 
          if (this.scene.context.rmarkdown === "ioslides_presentation") {
            this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
          } else if (this.scene.context.rmarkdown === "slidy_presentation") {
            // This method would also work in ioslides, but it gets triggered
            // something like 5 times per slide for every slide change, so
            // you'd need a quicker function than lazyLoadScene.
            var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
            observer = new MutationObserver(function(mutations) {
              mutations.forEach(function() {
                self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
            observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
          }
      }
    };
</script>
<script>/**
 * Methods related to drawing transparent objects
 * @name ___METHODS_FOR_TRANSPARENCY___
 * @memberof rglwidgetClass
 * @kind function
 * @instance

 * These functions order the centers of displayed objects so they
 * can be drawn using the painters algorithm, necessary to support
 * transparency.  

 * Note that objid is not obj.id when drawing spheres.
 */

/**
 * Break objects into pieces
 * @returns { array } Array of pieces
 */
    rglwidgetClass.prototype.getPieces = function(context, objid, subid, obj) {
      var n = obj.centers.length,
          depth,
          result = new Array(n),
          z, w, i;
      context = context.slice();
          
      for(i=0; i<n; i++) {
        z = this.prmvMatrix.m13*obj.centers[i][0] +
            this.prmvMatrix.m23*obj.centers[i][1] +
            this.prmvMatrix.m33*obj.centers[i][2] +
            this.prmvMatrix.m43;
        w = this.prmvMatrix.m14*obj.centers[i][0] +
            this.prmvMatrix.m24*obj.centers[i][1] +
            this.prmvMatrix.m34*obj.centers[i][2] +
            this.prmvMatrix.m44;
        depth = z/w;
        result[i] = {context: context, 
                     objid: objid,
                     subid: subid,
                     index: i, 
                     depth: depth};
      }
      return result;    
    };
    
    /**
     * Get pieces from sphere
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getSpherePieces = function(context, subid, obj)
    {
      if (obj.fastTransparency) 
        if (subid === 0) // Only compute pieces once
          return this.getPieces(context, obj.id, -1, obj);
        else
          return [];
      else
        return this.getPieces(context, obj.id, subid, this.sphere);
    };
    
   /**
     * Get pieces from cube
     * @returns { object }
     * @param { array } context - 
     * @param { numeric } subid - subscene
     * @param { object } obj - spheres object
     */
    rglwidgetClass.prototype.getCubePieces = function(context, obj)
    {
      return this.getPieces(context, obj.id, 0, this.cube);
    };
    
    /**
     * Merge pieces that can be drawn in one call
     * @returns { object }
     * @param { array } pieces - The pieces to merge
     */
    rglwidgetClass.prototype.mergePieces = function(pieces) {
      var result = [];
      if (pieces.length > 0) {
        var i,
          thiscontext = pieces[0].context, 
          thisobjid = pieces[0].objid, 
          thissubid = pieces[0].subid,
          indices = [];
        for (i= 0; i < pieces.length; i++) {
          if (pieces[i].context !== thiscontext || 
              pieces[i].objid !== thisobjid ||
              pieces[i].subid !== thissubid) {
            result.push({context: thiscontext, objid: thisobjid,
                         subid: thissubid, indices: indices});
            thiscontext = pieces[i].context;
            thisobjid = pieces[i].objid;
            thissubid = pieces[i].subid;
            indices = [];
          }
          indices.push(pieces[i].index);
        }
        result.push({context: thiscontext, objid: thisobjid,
                                subid: thissubid,
                                indices: indices});
      }
      return result;
    };

    /**
     * Sort pieces by depth
     * @returns { array }
     * @param { array } pieces - array of pieces 
     */
    rglwidgetClass.prototype.sortPieces = function(pieces) {
      var compare = function(i,j) {
        var diff = j.depth - i.depth;
        // We want to avoid context or obj changes,
        // so sort on those next.
        if (diff === 0) {
          var c1 = j.context.slice(),
              c2 = i.context.slice();
          diff = c1.length - c2.length; 
          while (diff === 0 && c1.length > 0) {
            diff = c1.pop() - c2.pop();
          }
          if (diff === 0)
            diff = j.objid - i.objid;
          if (diff === 0)
            diff = j.subid - i.subid;
        }
        return diff;
      }, result = [];
      if (pieces.length) 
        result = pieces.sort(compare);
      return result;
    };
</script>
<script>    /**
     * Methods related to drawing
     * @name ___METHODS_FOR_DRAWING___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Start drawing
     * @returns { boolean } Previous state
     */
    rglwidgetClass.prototype.startDrawing = function() {
    	var value = this.drawing;
    	this.drawing = true;
    	return value;
    };

    /**
     * Stop drawing and check for context loss
     * @param { boolean } saved - Previous state
     */
    rglwidgetClass.prototype.stopDrawing = function(saved) {
      this.drawing = saved;
      if (!saved && this.gl && this.gl.isContextLost())
        this.restartCanvas();
    };

    /**
     * Update the triangles used to display a plane
     * @param { number } id - id of the plane
     * @param { Object } bbox - bounding box in which to display the plane
     */
    rglwidgetClass.prototype.planeUpdateTriangles = function(obj, bbox) {
      var perms = [[0,0,1], [1,2,2], [2,1,0]],
          x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
          face1 = [], face2 = [], normals = [],
          nPlanes = obj.normals.length, idx, center;
      obj.bbox = bbox;
      obj.vertices = [];
      obj.centers = [];
      obj.initialized = false;
      for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
        x = [];
        A = obj.normals[elem];
        d = obj.offsets[elem][0];
        nhits = 0;
        for (i=0; i<3; i++)
          for (j=0; j<2; j++)
            for (k=0; k<2; k++) {
              u = perms[0][i];
              v = perms[1][i];
              w = perms[2][i];
              if (A[w] !== 0.0) {
                intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
                if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
                  xrow = [];
                  xrow[u] = bbox[j+2*u];
                  xrow[v] = bbox[k+2*v];
                  xrow[w] = intersect;
                  x.push(xrow);
                  face1[nhits] = j + 2*u;
                  face2[nhits] = k + 2*v;
                  nhits++;
                }
              }
            }

            if (nhits > 3) {
            /* Re-order the intersections so the triangles work */
              for (i=0; i<nhits-2; i++) {
                which = 0; /* initialize to suppress warning */
                for (j=i+1; j<nhits; j++) {
                  if (face1[i] === face1[j] || face1[i] === face2[j] ||
                      face2[i] === face1[j] || face2[i] === face2[j] ) {
                    which = j;
                    break;
                  }
                }
                if (which > i+1) {
                  rglwidgetClass.swap(x, i+1, which);
                  rglwidgetClass.swap(face1, i+1, which);
                  rglwidgetClass.swap(face2, i+1, which);
                }
              }
            }
            if (nhits >= 3) {
      /* Put in order so that the normal points out the FRONT of the faces */
              v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
              v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
              /* cross-product */
              vx = rglwidgetClass.xprod(v0, v2);
              reverse = rglwidgetClass.dotprod(vx, A) > 0;

              for (i=0; i<nhits-2; i++) {
                obj.vertices.push(x[0]);
                center = [];
                for (k = 0; k<3; k++)
                  center.push(x[0][k]/3);
                normals.push(A);
                for (j=1; j<3; j++) {
                  idx = i + (reverse ? 3-j : j);
                  obj.vertices.push(x[idx]);
                  for (k=0; k<3; k++)
                    center[k] += x[idx][k]/3;
                  normals.push(A);
                }
                obj.centers.push(center);
              }
            }
      }
      obj.pnormals = normals;
    };
    
    rglwidgetClass.prototype.mode4type = {points : "POINTS",
                     linestrip : "LINE_STRIP",
                     abclines : "LINES",
                     lines : "LINES",
                     sprites : "TRIANGLES",
                     planes : "TRIANGLES",
                     text : "TRIANGLES",
                     quads : "TRIANGLES",
                     surface : "TRIANGLES",
                     triangles : "TRIANGLES",
                     sphere : "TRIANGLES"
    };
    
    /**
     * Disable unused arrays
     * @param { Object } obj - Object to work with
     * @param { Array } enabled - Array indicating which are enabled
     */
    rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
      var gl = this.gl || this.initGL(),
          objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
          thisLocs = ["posLoc", "colLoc"], i, attr;
      for (i = 0; i < objLocs.length; i++) 
        if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
      for (i = 0; i < thisLocs.length; i++)
        if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
      if (typeof obj.userAttributes !== "undefined") {
      	for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
      	}
      }
    };

    /**
     * Start drawing the scene
     */    
    rglwidgetClass.prototype.doStartScene = function() {
      var gl = this.gl || this.initGL();
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearDepth(1.0);
      gl.clearColor(1,1,1,1);
      gl.depthMask(true); // Must be true before clearing depth buffer
      /* jshint bitwise: false */
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      /* jshint bitwise: true */
    };
    
    /**
     * Set gl depth test based on object's material
     * @param { Object } obj - object to use
     */
    rglwidgetClass.prototype.doDepthTest = function(obj) {
      var gl = this.gl,
          tests = {never: gl.NEVER,
                   less:  gl.LESS,
                   equal: gl.EQUAL,
                   lequal:gl.LEQUAL,
                   greater: gl.GREATER,
                   notequal: gl.NOTEQUAL,
                   gequal: gl.GEQUAL,
                   always: gl.ALWAYS},
           test = tests[this.getMaterial(obj, "depth_test")];
      gl.depthFunc(test);
    };    
    
    /**
     * Set polygon offset for an obj
     * @param { object } obj - object to use
     */
    rglwidgetClass.prototype.doPolygonOffset = function(obj) { 
      var gl = this.gl;
      if (typeof obj.polygon_offset !== "undefined") {
        gl.polygonOffset(obj.polygon_offset[0],
                          obj.polygon_offset[1]);
        gl.enable(gl.POLYGON_OFFSET_FILL);
      } else
        gl.disable(gl.POLYGON_OFFSET_FILL);
    };
    
    /**
     * Do code for clipping
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doClipping = function(obj, subscene) {
      var gl = this.gl,
          clipcheck = 0,
          clipplaneids = subscene.clipplanes,
          clip, i,j, n = this.countClipplanes(),
          clipplanedata; 
          
      if (n > 0) {
        clipplanedata = new Float32Array(4*n);
        for (i=0; i < clipplaneids.length; i++) {
          clip = this.getObj(clipplaneids[i]);
          for (j=0; j < clip.offsets.length; j++) {
            clipplanedata.set(clip.IMVClip[j], clipcheck);
            clipcheck += 4;
          }
        }
      
        // Leftovers are initialized to zero, which is fine
        gl.uniform4fv(obj.clipLoc, clipplanedata);
      }
    };
    
    /**
     * Do code for lighting
     * @param { object } obj - Object to work with
     * @param { object } subscene - Subscene to work with
     */
    rglwidgetClass.prototype.doLighting = function(obj, subscene) {
    var gl = this.gl, i, j, n, light,
      ambient, specular, diffuse, lightDir, viewpoint, finite,
      ambient0, specular0;

      gl.uniform3fv( obj.emissionLoc, obj.emission);
      gl.uniform1f( obj.shininessLoc, obj.shininess);
      while ((typeof subscene.lights === "undefined" ||
              subscene.lights.length === 0) && 
             typeof subscene.parent !== "undefined")
        subscene = this.getObj(subscene.parent);

      if (typeof subscene.lights === "undefined")
        return;
        
      n = subscene.lights.length;
        
      ambient = new Float32Array(3*n);
      specular = new Float32Array(3*n);
      diffuse = new Float32Array(3*n);
      lightDir = new Float32Array(3*n);
      viewpoint = new Int32Array(n);
      finite = new Int32Array(n);
          
      for (i=0; i < n; i++) {
        light = this.getObj(subscene.lights[i]);
        if (!light.initialized) this.initObj(light);
        ambient0 = this.componentProduct(light.ambient, obj.ambient);
        specular0 = this.componentProduct(light.specular, obj.specular);
        for (j=0; j < 3; j++) {
          ambient[3*i + j] = ambient0[j];
          specular[3*i + j] = specular0[j];
          diffuse[3*i + j] = light.diffuse[j];
          lightDir[3*i + j] = light.lightDir[j];
        }
        viewpoint[i] = light.viewpoint;
        finite[i] = light.finite;
      }
        
      for (i = n; i < obj.nlights; i++) {
        for (j = 0; j < 3; j++) {
          ambient[3*i + j] = 0.0;
          specular[3*i + j] = 0.0;
          diffuse[3*i + j] = 0.0;
        }
      }
        
      gl.uniform3fv( obj.ambientLoc, ambient);
      gl.uniform3fv( obj.specularLoc, specular);
      gl.uniform3fv( obj.diffuseLoc, diffuse);
      gl.uniform3fv( obj.lightDirLoc, lightDir);
      gl.uniform1iv( obj.viewpointLoc, viewpoint);
      gl.uniform1iv( obj.finiteLoc, finite);
    };
    
    /**
     * Do code for colors
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doColors = function(obj) {
      var gl = this.gl;
      if (obj.colorCount === 1) {
        gl.disableVertexAttribArray( this.colLoc );
        gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
        return false;
      } else {
        gl.enableVertexAttribArray( this.colLoc );
        gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
        return true;
      }
    };
    
    /**
     * Do code for normals
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormals = function(obj) {
      var gl = this.gl;
      if (obj.vOffsets.nofs >= 0) {
        gl.enableVertexAttribArray( obj.normLoc );
        gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
        return true;
      } else
        return false;
    };
    
    /**
     * Do code for vNormal
     * @param { object } obj - Object to work with
     */
    rglwidgetClass.prototype.doNormMat = function(obj) {
      var gl = this.gl;
        
      gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
    };
    
    /**
     * Do code for textures
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doTexture = function(obj) {
      var gl = this.gl, 
          is_sphere = obj.type === "sphere";
        gl.enableVertexAttribArray( obj.texLoc );
        if (is_sphere)
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride, 4*this.sphere.vOffsets.tofs);
        else
          gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, obj.texture);
        gl.uniform1i( obj.sampler, 0);
        return true;
    };
    
    /**
     * Do code for user attributes
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserAttributes = function(obj) {
      if (typeof obj.userAttributes !== "undefined") {
        var gl = this.gl;
      	for (var attr in obj.userAttribSizes) {  // Not all attributes may have been used
      	  gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
      	  gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
      	  			  gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
      	}
      }
    };

    /**
     * Do code for user uniforms
     * @param { object } obj - Object to work with
     */    
    rglwidgetClass.prototype.doUserUniforms = function(obj) {
      var gl = this.gl, attr;
      if (typeof obj.userUniforms !== "undefined") {
      	for (attr in obj.userUniformLocations) {
      	  var loc = obj.userUniformLocations[attr];
      	  if (loc !== null) {
      	    var uniform = obj.userUniforms[attr];
      	    if (typeof uniform !== "undefined") {
      	      var dim = rglwidgetClass.arrayDim(uniform);
      	      if (dim.length === 0)
      	        gl.uniform1f(loc, uniform);
      	      else if (dim.length === 1) {
      	        uniform = new Float32Array(uniform);
      	        switch(uniform.length) {
      	      	  case 2: gl.uniform2fv(loc, uniform); break;
      	      	  case 3: gl.uniform3fv(loc, uniform); break;
      	      	  case 4: gl.uniform4fv(loc, uniform); break;
      	      	  default: console.warn("bad uniform length");
      	        }
      	      } else if (dim.length === 2 && dim[0] === 4 && dim[1] === 4)
      	        gl.uniformMatrix4fv(loc, false, new Float32Array(rglwidgetClass.flatten(uniform)));
      	      else if (dim.length === 2) {
      	        uniform = new Float32Array(rglwidgetClass.flatten(uniform));
      	        switch(dim[[1]]) {
      	          case 1: gl.uniform1fv(loc, uniform); break;
      	          case 2: gl.uniform2fv(loc, uniform); break;
      	          case 3: gl.uniform3fv(loc, uniform); break;
      	          case 4: gl.uniform4fv(loc, uniform); break;
      	          default: console.warn("bad uniform column count");
      	        }
      	      } else
      	        console.warn("unsupported uniform shape");
      	    }
      	  }
      	}
      }
      if (typeof obj.userTextures !== "undefined") {
        var has_texture = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_has_texture),
              texnum = has_texture - 1;
        for (attr in obj.userTextures) {
      	  var texture = obj.userTextures[attr];
      	  if (texture.sampler !== null) {
      	    texnum += 1;
      	    gl.activeTexture(gl.TEXTURE0 + texnum);
            gl.bindTexture(gl.TEXTURE_2D, texture.texture);
            gl.uniform1i( texture.sampler, texnum);
      	  }
      	}
      }
    };

    /**
     * Load indices for complex drawing
     * @param { object } obj - Object to work with
     * @param { numeric } pass - Which pass of drawing?
     * @param { array } indices - Indices to draw
     */    
    rglwidgetClass.prototype.doLoadIndices = function(obj, pass, indices) {
      var gl = this.gl,
          f = obj.f[pass],
          type = obj.type,
          fat_lines = rglwidgetClass.isSet(obj.flags, rglwidgetClass.f_fat_lines),
          fnew, step;
      switch(type){
        case "points":
          step = 1;
          break;
        case "abclines":
        case "lines":
          if (fat_lines)
            step = 6;
          else
            step = 2;
          break;
        case "linestrip":
          if (fat_lines)
            step = 6;
          else
            step = 1;
          break;
        case "sphere":
        case "planes":
        case "triangles":
          step = 3;
          break;
        case "text":
        case "sprites":
        case "quads":
        case "surface":
          step = 6;
          break;
        default:
          console.error("loadIndices for "+type);
          return 0;
      }
      if (obj.index_uint)
        fnew = new Uint32Array(step * indices.length);
      else
        fnew = new Uint16Array(step * indices.length);
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < step; j++) {
          fnew[step*i + j] = f[step*indices[i] + j];
        }
      }
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, fnew, gl.DYNAMIC_DRAW);
      return fnew.length;
    };

    /**
     * Do code for depth masking
     * @param { boolean } mask - whether to mask
     */
    rglwidgetClass.prototype.doMasking = function(mask) {
      var gl = this.gl;
      gl.depthMask(mask);
    };

    /**
     * Do code for alpha blending
     * @param { boolean }  blend - Whether to blend.
     * @param { integer }  objid - Object id
     */    
    rglwidgetClass.prototype.doBlending = function(blend, objid) {
      var gl = this.gl, blendfunc, obj, 
        blends =  {zero: gl.ZERO,
                   one:  gl.ONE,
                   src_color: gl.SRC_COLOR,
                   one_minus_src_color: gl.ONE_MINUS_SRC_COLOR,
                   dst_color: gl.DST_COLOR,
                   one_minus_dst_color: gl.ONE_MINUS_DST_COLOR,
                   src_alpha: gl.SRC_ALPHA,
                   one_minus_src_alpha: gl.ONE_MINUS_SRC_ALPHA,
                   dst_alpha: gl.DST_ALPHA,
                   one_minus_dst_alpha: gl.ONE_MINUS_DST_ALPHA,
                   constant_color: gl.CONSTANT_COLOR,
                   one_minus_constant_color: gl.ONE_MINUS_CONSTANT_COLOR,
                   constant_alpha: gl.CONSTANT_ALPHA,
                   one_minus_constant_alpha: gl.ONE_MINUS_CONSTANT_ALPHA,
                   src_alpha_saturate: gl.SRC_ALPHA_SATURATE};
      if (blend) {
        obj = this.getObj(objid);
        blendfunc = this.getMaterial(obj, "blend");
        gl.blendFuncSeparate(blends[blendfunc[0]],
                             blends[blendfunc[1]],
                             gl.ONE, gl.ONE);
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
    };
    
    /**
     * Set up for fog in the subscene
     * @param { object } obj - background object
     * @param { object } subscene - which subscene
     */
    rglwidgetClass.prototype.doFog = function(obj, subscene) {
      var gl = this.gl, fogmode, color, 
          observer = subscene.par3d.observer[2],
          sintheta = Math.sin(subscene.par3d.FOV*Math.PI/180/2),
          parms = [this.frustum.near - 2*observer,
                   this.frustum.far - 2*observer,
                   this.fogScale,
                   (1-sintheta)/(1+sintheta)];
      if (typeof this.fogType === "undefined")
        this.fogType = "none";
      if (typeof this.fogScale === "undefined")
        parms[2] = 1;
      if (sintheta === 0)
        parms[3] = 1/3;
      switch(this.fogType){
        case "none": fogmode = 0; break;
        case "linear": 
          fogmode = 1; break;
        case "exp":  
          fogmode = 2; break;
        case "exp2": 
          fogmode = 3;
          break;
        default: console.error("Unknown fogtype "+this.fogType);
      }
      gl.uniform1i(obj.uFogMode, fogmode);
      color = this.fogColor;
      gl.uniform3f(obj.uFogColor, color[0], color[1], color[2]);
      gl.uniform4f(obj.uFogParms, parms[0], parms[1], parms[2], parms[3]);
    };

    /* The draw methods are called twice.  When 
       this.opaquePass is true, they should draw opaque parts
       of the scene, and return the list of transparent
       pieces.  Here context is the context array on input,
       modified when the matrices are changed.
       When this.opaquePass is false, the context argument
       contains a "piece", i.e. an ordered list of parts
       of the object to draw. */

    /**
     * Draw simple object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */       
    rglwidgetClass.prototype.drawSimple = function(obj, subscene, context) {
      var 
          fl,
          is_transparent,
          type = obj.type,
          gl = this.gl || this.initGL(),
          count,
          pass, mode, pmode,
          enabled = {};
        
      if (!obj.initialized)
        this.initObj(obj);
        
      if (this.texturesLoading)
        return[];

      count = obj.vertexCount;
      if (!count)
        return [];
    
      fl = obj.defFlags;
      is_transparent = fl.is_transparent || obj.someHidden;
      
      if (is_transparent && this.opaquePass)
        return this.getPieces(context, obj.id, 0, obj);

      this.doDepthTest(obj);
      
      this.doMasking(this.getMaterial(obj, "depth_mask"));
            
      gl.useProgram(obj.prog);

      this.doPolygonOffset(obj);

      gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);

      gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
      gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );

      this.doClipping(obj, subscene);

      if (fl.needs_vnormal)
        this.doNormMat(obj);
        
      if (fl.is_lit)
        this.doLighting(obj, subscene);

      if (fl.has_fog)
        this.doFog(obj, subscene);

      this.doUserAttributes(obj);

      this.doUserUniforms(obj);
 
      gl.enableVertexAttribArray( this.posLoc );
      enabled.posLoc = true;
        
      if (fl.has_texture || obj.type === "text")
        enabled.texLoc = this.doTexture(obj);

      enabled.colLoc = this.doColors(obj);
      enabled.normLoc = this.doNormals(obj);

      if (fl.fixed_size) {
        gl.uniform3f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height, 1.0);
      }
      
      if (fl.fixed_quads) {
        gl.enableVertexAttribArray( obj.ofsLoc );
        enabled.ofsLoc = true;
        gl.vertexAttribPointer(obj.ofsLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
      }

      for (pass = 0; pass < obj.passes; pass++) {
      	pmode = obj.pmode[pass];
        if (pmode === "culled")
          continue;

      	mode = fl.fat_lines && (fl.is_lines || pmode === "lines") ? "TRIANGLES" : this.mode4type[type];

      	if (fl.is_twosided) {
      	  gl.uniform1i(obj.frontLoc, pass !== 0);
      	  if (fl.has_normals) {
      	    gl.uniformMatrix4fv(obj.invPrMatLoc, false, new Float32Array(this.invPrMatrix.getAsArray()));
      	  }
      	}

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
        if (!this.opaquePass) {
          if (type === "sphere" && obj.fastTransparency)
            count = this.doLoadIndices(obj, pass, this.sphere.fastpieces[0].indices);
          else
            count = this.doLoadIndices(obj, pass, context.indices);
        } else {
          count = obj.f[pass].length;
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[pass], gl.STATIC_DRAW);
        }
      	if (!fl.is_lines && pmode === "lines" && !fl.fat_lines) {
          mode = "LINES";
        } else if (pmode === "points") {
          mode = "POINTS";
        }
                          
        if ((fl.is_lines || pmode === "lines") && fl.fat_lines) {
          gl.enableVertexAttribArray(obj.pointLoc);
          enabled.pointLoc = true;
          gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
          gl.enableVertexAttribArray(obj.nextLoc );
          enabled.nextLoc = true;
          gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
          gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
          gl.uniform1f(obj.lwdLoc, this.getMaterial(obj, "lwd")/this.vp.height);
        }

        gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);

        gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
      }
      this.disableArrays(obj, enabled);
      return [];
    };

    /**
     * Draw planes object
     * @param { object } obj - Object to draw
     * @param { object } subscene - which subscene
     * @param { array } context - Which context are we in?
     */      
    rglwidgetClass.prototype.drawPlanes = function(obj, subscene, context) {
      if (obj.bbox !== subscene.par3d.bbox || !obj.initialized) {
          this.planeUpdateTriangles(obj, subscene.par3d.bbox);
      }
      return this.drawSimple(obj, subscene, context);
   };

    /**
     * @param { object } obj - object to draw
     * @param { object } subscene 
     * @param { array } context 
     * @description
     * Draw spheres in a subscene<br>
     * 
     * Drawing spheres happens in six ways:<br>
     * 1 opaquepass, not transparent:  transform and draw this.sphere count times<br>
     * 2 opaquepass, transparent, not fast: transform & collect sphere pieces count times<br>
     * 3 opaquepass, transparent, fast:  order the centres into separate pieces, order this.sphere once<br>
     * 4 not opaquepass, not transparent:  do nothing<br>
     * 5 not opaquepass, transparent, not fast:  transform for one sphere, draw one merged piece<br>
     * 6 not opaquepass, transparent, fast:  transform for one sphere, draw this.sphere in fixed order.<br>
     **/

    rglwidgetClass.prototype.drawSpheres = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sphereMV, baseofs, ofs, sscale, i,
          count, nc, scount, scale, indices, sphereNorm,
          enabled = {}, drawing,
          saveNorm = new CanvasMatrix4(this.normMatrix),
          saveMV = new CanvasMatrix4(this.mvMatrix),
          savePRMV = null,
          result = [], idx, margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!obj.initialized)
        this.initObj(obj);

      count = obj.vertexCount;
      if (!count) 
        return [];
        
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return [];
        
      if (this.prmvMatrix !== null)
        savePRMV = new CanvasMatrix4(this.prmvMatrix);
      
      scale = subscene.par3d.scale;        
      sphereNorm = new CanvasMatrix4();
      sphereNorm.scale(scale[0], scale[1], scale[2]);
      sphereNorm.multRight(saveNorm);
      this.normMatrix = sphereNorm;

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      if (drawing) {
        nc = obj.colorCount;
        if (nc === 1) {
          this.sphere.onecolor = obj.onecolor;
        }
      }
      
      this.initShapeFromObj(this.sphere, obj);

      if (!this.opaquePass && obj.fastTransparency && typeof this.sphere.fastpieces === "undefined") {
        this.sphere.fastpieces = this.getPieces(context.context, obj.id, 0, this.sphere);
        this.sphere.fastpieces = this.sortPieces(this.sphere.fastpieces);
        this.sphere.fastpieces = this.mergePieces(this.sphere.fastpieces);
      }

      if (this.opaquePass)
        scount = count;
      else {
        indices = context.indices;
        if (obj.fastTransparency)
          scount = indices.length;  /* Each item gives the center of a whole sphere */
        else
          scount = 1;               /* Each item is a fragment of the sphere, at location subid */
      }
      for (i = 0; i < scount; i++) {
        sphereMV = new CanvasMatrix4();
        if (this.opaquePass)
          idx = i;
        else if (obj.fastTransparency)
          idx = indices[i];
        else
          idx = context.subid;
        if (typeof idx === "undefined")
          console.error("idx is undefined");
        baseofs = idx*obj.vOffsets.stride;
        ofs = baseofs + obj.vOffsets.radofs;
        sscale = obj.values[ofs];

        sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
        sphereMV.translate(obj.values[baseofs],
                             obj.values[baseofs+1],
                             obj.values[baseofs+2]);
        sphereMV.multRight(saveMV);
        this.mvMatrix = sphereMV;
        this.setnormMatrix2();
        this.setprmvMatrix();
        if (drawing) {
          if (nc > 1) {
            this.sphere.onecolor = obj.values.slice(baseofs + obj.vOffsets.cofs, baseofs + obj.vOffsets.cofs + 4);
          }
          this.drawSimple(this.sphere, subscene, context);
        } else 
          result = result.concat(this.getSpherePieces(context, i, obj));
      }
      if (drawing)
        this.disableArrays(obj, enabled);
      this.normMatrix = saveNorm;
      this.mvMatrix = saveMV;
      this.prmvMatrix = savePRMV;
        
      return result;
    };
    
    /**
     * Prepare clipplanes for drawing
     * @param { object } obj - clip planes object
     */
    rglwidgetClass.prototype.drawClipplanes = function(obj) {
      var count = obj.offsets.length,
        IMVClip = [];
      for (var i=0; i < count; i++) {
        IMVClip[i] = rglwidgetClass.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
      }
      obj.IMVClip = IMVClip;
      return [];
    };

    /**
     * Prepare linestrip for drawing
     * @param { object } obj - line strip object
     * @param { object } subscene 
     * @param { array } context 
     */    
    rglwidgetClass.prototype.drawLinestrip = function(obj, subscene, context) {
      var origIndices, i, j, margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      if (this.opaquePass)
        return this.drawSimple(obj, subscene, context);
      origIndices = context.indices.slice();
      for (i=0; i < origIndices.length; i++) {
        j = origIndices[i];
        if (j < obj.centers.length - 1) {
          context.indices = [j, j+1];
          this.drawSimple(obj, subscene, context);
        }
      }
      context.indices = origIndices;
      return [];
    };
          
    /**
     * Draw a sprites object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { object } context
     */
    rglwidgetClass.prototype.drawSprites = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          sprites3d = rglwidgetClass.isSet(flags, rglwidgetClass.f_sprites_3d),
          fixed_size = rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_size),
          rotating = rglwidgetClass.isSet(flags, rglwidgetClass.f_rotating),
          i,j,
          origMV = new CanvasMatrix4( this.mvMatrix ),
          origPRMV = null,
          origPR,
          pos, radius, userMatrix,
          result = [], margin = obj.material.margin;
 
      if (typeof margin !== "undefined")
        if (!this.marginVecToDataVec(obj, subscene))
          return [];

      if (!sprites3d) 
        return this.drawSimple(obj, subscene, context);
      
      if (!obj.initialized)
        this.initObj(obj);

      if (!obj.vertexCount)
        return [];
    
      is_transparent = is_transparent || obj.someHidden;
      
      var norigs = obj.vertices.length,
          savenorm = new CanvasMatrix4(this.normMatrix),
          iOrig, adj, offset;

      userMatrix = obj.userMatrix;
                   
      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } else
        norigs = 1;
          
      if (this.prmvMatrix !== null)
         origPRMV = new CanvasMatrix4( this.prmvMatrix );

      offset = obj.offset;
      
      if (fixed_size && !rotating) {
        origPR = this.prMatrix;
        this.prMatrix = new CanvasMatrix4();
      }
        
      for (iOrig=0; iOrig < norigs; iOrig++) {
        if (this.opaquePass)
          j = iOrig;
        else
          j = context.subid;
        pos = [].concat(obj.vertices[j]).concat(1.0);
        radius = obj.radii.length > 1 ? obj.radii[j][0] : obj.radii[0][0];
        this.mvMatrix = new CanvasMatrix4(userMatrix);
        adj = this.getAdj(obj, j, offset);
        this.mvMatrix.translate(1 - 2*adj[0], 1 - 2*adj[1], 1 - 2*adj[2]);
        this.mvMatrix.scale(radius, radius, radius);
        
        if (fixed_size) {
          var viewport = subscene.par3d.viewport,
            winwidth = viewport.width*this.canvas.width,
            winheight = viewport.height*this.canvas.height,
            scalex = 27/winwidth, scaley = 27/winheight,
              scale = Math.sqrt(scalex * scaley);
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            pos = rglwidgetClass.multVM(pos, origPR);
            this.mvMatrix.scale(scalex, scaley, scale);
          } else {
            scale = 4.0 * scale * subscene.par3d.zoom;
            this.mvMatrix.scale(scale, scale, scale);
          }
          this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          if (rotating)
            this.mvMatrix.multRight(origMV);
        } else {
          if (!rotating) {
            pos = rglwidgetClass.multVM(pos, origMV);
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
          } else {
            this.mvMatrix.translate(pos[0]/pos[3], pos[1]/pos[3], pos[2]/pos[3]);
            this.mvMatrix.multRight(origMV);
          }
        }
        this.setnormMatrix2();
        this.setprmvMatrix();
      
        for (i=0; i < obj.objects.length; i++)
          if (this.opaquePass)
            result = result.concat(this.drawObjId(obj.objects[i], subscene.id, context.concat(j)));
          else
            this.drawObjId(obj.objects[i], subscene.id, context);
      }
      this.normMatrix = savenorm;
      this.mvMatrix = origMV;
      if (fixed_size && !rotating)
        this.prMatrix = origPR;
      if (origPRMV !== null)
        this.prmvMatrix = origPRMV;
      return result;
    };
    
    /**
     * Draw object that might be in margin
     * @param { Object } obj - text object to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawMarginal = function(obj, subscene, context) {
      var margin = obj.material.margin;
 
      if (typeof margin !== "undefined") 
        if (!this.marginVecToDataVec(obj, subscene))
          return [];
          
      return this.drawSimple(obj, subscene, context);
    };
    
    /**
     * Draw bounding box and decorations
     * @param { Object } obj - bboxdeco to draw
     * @param { Object } subscene - subscene holding it
     * @param { Object } context - context for drawing
     */
    rglwidgetClass.prototype.drawBBox = function(obj, subscene, context) {
      var flags = obj.flags,
          is_transparent = rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent),
          scale, bbox, indices,
          enabled = {}, drawing,
          result = [], idx, center, edges,
          saved;

      if (!obj.initialized)
        this.initBBox(obj);
      
      is_transparent = is_transparent || obj.someHidden;

      if (!this.opaquePass && !is_transparent)
        return result;
      
      this.setBbox(obj, subscene);
      
      saved = this.setBBoxMatrices(obj);
      
      bbox = obj.bbox;
      center = obj.center;

      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];

      if (!obj.cube.initialized) {
        this.initObj(obj.cube);
      }

      if (this.opaquePass) {
        context = context.slice();
        context.push(obj.id);
      } 
      
      drawing = this.opaquePass !== is_transparent;
      this.cube.onecolor = obj.cube.onecolor;
      this.initShapeFromObj(this.cube, obj.cube);

      if (!this.opaquePass)
        indices = context.indices;

      if (this.opaquePass)
        idx = 0;
      else
        idx = context.subid;
      if (typeof idx === "undefined")
        console.error("idx is undefined");

      if (drawing) {
        this.drawSimple(this.cube, subscene, context);
      } else 
        result = result.concat(this.getCubePieces(context, obj));

      if (!obj.ticks.initialized) {
        obj.ticks.locations = this.getTickLocations(obj);
        obj.ticks.edges = undefined;
      }
      edges = this.getTickEdges(this.prmvMatrix);
      if (obj.needsAxisCallback) 
        this.doAxisCallback(obj, edges);
      if (!obj.ticks.edges || edges.toString() !== obj.ticks.edges.toString()) {
        obj.ticks.edges = edges;
        this.getTickVertices(obj.ticks);
        this.placeTickLabels(obj);
        this.setTickLabels(obj);
      }
      if (!obj.ticks.initialized) {
        this.initObj(obj.ticks);
        this.initObj(obj.labels);
      }
        
      if (drawing) {
        this.drawSimple(obj.ticks, subscene, context);
        this.drawSimple(obj.labels, subscene, context);

        this.disableArrays(obj, enabled);
      } else {
        result = result.concat(this.drawSimple(obj.ticks, subscene, context));
        result = result.concat(this.drawSimple(obj.labels, subscene, context));
      }

      this.restoreBBoxMatrices(saved);
        
      return result;
    };
    
    /**
     * Use ids to choose object to draw
     * @param { numeric } id - object to draw
     * @param { numeric } subscene
     * @param { array } context
     */   
    rglwidgetClass.prototype.drawObjId = function(id, subsceneid, context) {
      if (typeof id !== "number")
        this.alertOnce("drawObjId id is "+typeof id);

      return this.drawObj(this.getObj(id), this.getObj(subsceneid), context);
   };
   
    /**
     * Draw an object in a subscene
     * @param { object } obj - object to draw
     * @param { object } subscene
     * @param { array } context
     */
    rglwidgetClass.prototype.drawObj = function(obj, subscene, context) {
      switch(obj.type) {
        case "abclines":
        case "surface":
          return this.drawSimple(obj, subscene, context);
        case "points":
        case "lines":  
        case "triangles":
        case "quads":
        case "text":
          return this.drawMarginal(obj, subscene, context);
        case "linestrip":
          return this.drawLinestrip(obj, subscene, context);
        case "planes":
          return this.drawPlanes(obj, subscene, context);
        case "spheres":
          return this.drawSpheres(obj, subscene, context);
        case "clipplanes":
          return this.drawClipplanes(obj);
        case "sprites":
          return this.drawSprites(obj, subscene, context);
        case "light":
          return [];
        case "bboxdeco":
          return this.drawBBox(obj, subscene, context);
      }
      
      console.error("drawObj for type = "+obj.type);
    };

    /**
     * Draw the background for a subscene
     * @param { number } id - id of background object
     * @param { number } subsceneid - id of subscene
     */
    rglwidgetClass.prototype.drawBackground = function(id, subsceneid, context) {
      var gl = this.gl || this.initGL(),
          obj = this.getObj(id),
          subscene,
          bg, i, savepr, saveinvpr, savemv, savenorm, m, bbox, result = [], 
          savedm = gl.getParameter(gl.DEPTH_WRITEMASK),
          savedt = gl.isEnabled(gl.DEPTH_TEST),
          saveblend = gl.isEnabled(gl.BLEND);

      if (!obj.initialized)
        this.initObj(obj);

      if (obj.colors.length) {
        bg = obj.colors[0];
        gl.depthMask(true);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.fogColor = bg;
      } else {
        this.fogColor = [0,0,0,0];
        obj.colors = [[0,0,0,0]];
      }
  
      this.fogType = obj.fogtype;
      this.fogScale = obj.fogscale;
      gl.disable(gl.BLEND);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      if (typeof obj.quad !== "undefined") {
        savepr = this.prMatrix;
        saveinvpr = this.invPrMatrix;
        savemv = this.mvMatrix;
        this.prMatrix = new CanvasMatrix4();
        this.invPrMatrix = new CanvasMatrix4();
        this.mvMatrix = new CanvasMatrix4();
        for (i=0; i < obj.quad.length; i++)
          result = result.concat(this.drawObjId(obj.quad[i], subsceneid));
        this.prMatrix = savepr;
        this.invPrMatrix = saveinvpr;
        this.mvMatrix = savemv;

      } else if (obj.sphere) {
        subscene = this.getObj(subsceneid);
        savemv = this.mvMatrix;
        savenorm = this.normMatrix;
        bbox = subscene.par3d.bbox;
        var center = [(bbox[0] + bbox[1])/2, 
                  (bbox[2] + bbox[3])/2, 
                  (bbox[4] + bbox[5])/2, 1],
            scale = subscene.par3d.scale,
            ranges = [bbox[1] - bbox[0], 
                  bbox[3] - bbox[2],
                  bbox[5] - bbox[4]],
            avgscale = rglwidgetClass.vlen(ranges)/Math.sqrt(3),
            aspect = [ranges[0]*scale[0]/avgscale,
                      ranges[1]*scale[1]/avgscale,
                      ranges[2]*scale[2]/avgscale],
            maxaspect = Math.max(aspect[0], aspect[1], aspect[2]),
            zoom = subscene.par3d.zoom;
        m = new CanvasMatrix4();
        m.rotate(90, 1, 0, 0);
        m.scale(zoom*2.0*maxaspect*ranges[0]/aspect[0], 
                zoom*2.0*maxaspect*ranges[1]/aspect[1],
                zoom*2.0*maxaspect*ranges[2]/aspect[2]);
        m.translate(center[0], center[1], center[2]);
        m.multRight(savemv);
        center = rglwidgetClass.multVM(center, savemv);
        m.translate(-center[0], -center[1], -center[2]);
        m.scale(1, 1, 0.25/zoom);
        m.translate(center[0], center[1], center[2]);
        this.mvMatrix = m;
        this.initShapeFromObj(this.sphere, obj);
        this.sphere.onecolor = obj.colors.length > 1 ? obj.colors[1] : obj.colors[0];
        
        this.normMatrix = new CanvasMatrix4();
        
        this.setnormMatrix2();
        this.setprmvMatrix();
        
        result = result.concat(this.drawSimple(this.sphere, subscene, context));
        this.mvMatrix = savemv;
        this.normMatrix = savenorm;
      }
      gl.depthMask(savedm);
      if (savedt)
        gl.enable(gl.DEPTH_TEST);
      if (saveblend)
        gl.enable(gl.BLEND);
      return result;
    };

    /**
     * Draw a subscene
     * @param { number } subsceneid - id of subscene
     * @param { array } context 
     */
    rglwidgetClass.prototype.drawSubscene = function(subsceneid, context) {
      var sub = this.getObj(subsceneid),
          objects = this.scene.objects,
          clipids = sub.clipplanes,
          subids = sub.objects,
          subscene_has_faces = false,
          subscene_needs_sorting = false,
          flags, i, obj, result = [];
          
      if (sub.par3d.skipRedraw)
        return result;
      
      if (this.opaquePass) {
        for (i=0; i < subids.length; i++) {
      	  obj = objects[subids[i]];
          flags = obj.flags;
          if (typeof flags !== "undefined") {
            subscene_has_faces = subscene_has_faces || 
                            (rglwidgetClass.isSet(flags, rglwidgetClass.f_is_lit) &&
                            !rglwidgetClass.isSet(flags, rglwidgetClass.f_fixed_quads));
            obj.is_transparent = obj.someHidden || 
              rglwidgetClass.isSet(flags, rglwidgetClass.f_is_transparent);
            subscene_needs_sorting = subscene_needs_sorting || 
              obj.is_transparent ||
              rglwidgetClass.isSet(flags, rglwidgetClass.f_depth_sort);
          }
        }
      }

      this.setViewport(subsceneid);

      this.setprMatrix(subsceneid);
      this.setInvPrMatrix();
      this.setmvMatrix(subsceneid);
      this.setnormMatrix2();
      this.setprmvMatrix();
      this.invMatrix = new CanvasMatrix4(this.mvMatrix);
      this.invMatrix.invert();
      
      if (this.opaquePass) {
        context = context.slice();
        context.push(subsceneid);
        
        this.doBlending(false);
        this.subsceneid = subsceneid;
        if (typeof this.sphere !== "undefined") // reset this.sphere.fastpieces; it will be recreated if needed
          this.sphere.fastpieces = undefined;
        if (typeof sub.backgroundId !== "undefined")
          result = result.concat(this.drawBackground(sub.backgroundId, subsceneid, context));
      }

      if (subids.length) {
            
        if (clipids.length > 0) {
          for (i = 0; i < clipids.length; i++)
            this.drawObjId(clipids[i], subsceneid);
        }
        
        subids = sub.opaque.concat(sub.transparent);
        if (this.opaquePass) {
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawObjId(subids[i], subsceneid, context));
          subids = sub.subscenes;
          for (i = 0; i < subids.length; i++)
            result = result.concat(this.drawSubscene(subids[i], context));
        }
      }
      return result;
    };
    
    /**
     * Set the context for drawing transparently
     * @param { array } context
     */
    rglwidgetClass.prototype.setContext = function(context) {
      var result = [], objid, obj, type;
      context = context.slice();
      context.reverse();
      while (context.length > 0) {
        objid = context.pop();
        obj = this.getObj(objid);
        type = obj.type;
        switch (type) {
          case "subscene":
            this.drawSubscene(objid, false);
            break;
          case "sprites":
            result = result.concat(context.pop());
            break;
          case "spheres":
            // this.initSphereFromObj(obj);  // FIXME:  not needed?
            break;
          case "bboxdeco":
            result = result.concat(context.pop());
            break;
          default:
            console.error("bad type '", type, "' in setContext");
        }
      }
      return result;
    };
    
    /**
     * Draw the transparent pieces of a scene
     * @param {object} pieces
     */
    rglwidgetClass.prototype.drawPieces = function(pieces) {
      var i, prevcontext = [], context;
      for (i = 0; i < pieces.length; i++) {
        context = pieces[i].context.slice();
        if (context !== prevcontext) {
          prevcontext = context.slice();
          context = this.setContext(context);
          this.doBlending(true, pieces[i].objid);
        }
        this.drawObjId(pieces[i].objid, this.subsceneid, 
                       pieces[i]);
      }
    };
 
    /**
     * Draw the whole scene
     */
    rglwidgetClass.prototype.drawScene = function() {
      var wasDrawing = this.startDrawing(),
          pieces;
      if (!wasDrawing) {
        if (this.select.state !== "inactive")
          this.selectionChanged();

        this.doStartScene();
        this.opaquePass = true;
        pieces = this.drawSubscene(this.scene.rootSubscene, []);
        this.opaquePass = false;
        pieces = this.sortPieces(pieces);
        pieces = this.mergePieces(pieces);
        this.drawPieces(pieces);
      }
      this.stopDrawing(wasDrawing);
    };
</script>
<script>
    /**
     * Change the displayed subset
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The subset control data.
     */
    rglwidgetClass.prototype.subsetSetter = function(el, control) {
      if (typeof control.subscenes === "undefined" ||
          control.subscenes === null)
        control.subscenes = this.scene.rootSubscene;
      var value = Math.round(control.value),
          subscenes = [].concat(control.subscenes),
          fullset = [].concat(control.fullset),
          i, j, subsceneid,
          adds = [], deletes = [];
      if (rglwidgetClass.missing(value))
        value = control.value = 0;
      if (control.accumulate)
        for (i=0; i <= value; i++)
          adds = adds.concat(control.subsets[i]);
      else
        adds = adds.concat(control.subsets[value]);
      deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
      for (i = 0; i < subscenes.length; i++) {
        subsceneid = subscenes[i];
        if (typeof this.getObj(subsceneid) === "undefined")
          this.alertOnce("typeof object is undefined");
        for (j = 0; j < adds.length; j++)
          this.addToSubscene(adds[j], subsceneid);
        for (j = 0; j < deletes.length; j++)
          this.delFromSubscene(deletes[j], subsceneid);
      }
    };

    /**
     * Change the requested property
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The property setter control data.
     */
    rglwidgetClass.prototype.propertySetter = function(el, control)  {
      var value = control.value,
          values = [].concat(control.values),
          svals = [].concat(control.param),
          direct = values[0] === null,
          entries = [].concat(control.entries),
          ncol = entries.length,
          nrow = values.length/ncol,
          properties = rglwidgetClass.repeatToLen(control.properties, ncol),
          objids = rglwidgetClass.repeatToLen(control.objids, ncol),
          property, objid = objids[0],
          obj = this.getObj(objid),
          propvals, i, j, v1, v2, p, entry, gl, needsBinding,
          newprop, newid,

          getPropvals = function() {
            if (property === "userMatrix")
              return obj.par3d.userMatrix.getAsArray();
            else if (property === "scale" || property === "FOV" || property === "zoom")
              return [].concat(obj.par3d[property]);
            else
              return [].concat(obj[property]);
          },

          putPropvals = function(newvals) {
            if (newvals.length === 1)
              newvals = newvals[0];
            if (property === "userMatrix")
              obj.par3d.userMatrix.load(newvals);
            else if (property === "scale" || property === "FOV" || property === "zoom")
              obj.par3d[property] = newvals;
            else
              obj[property] = newvals;
          };

      if (direct && typeof value === "undefined")
        return;

      if (control.interp) {
        values = values.slice(0, ncol).concat(values).
                 concat(values.slice(ncol*(nrow-1), ncol*nrow));
        svals = [-Infinity].concat(svals).concat(Infinity);
        for (i = 1; i < svals.length; i++) {
          if (value <= svals[i]) {
            if (svals[i] === Infinity)
              p = 1;
            else
              p = (svals[i] - value)/(svals[i] - svals[i-1]);
            break;
          }
        }
      } else if (!direct) {
        value = Math.round(value);
      }

      for (j=0; j<entries.length; j++) {
        entry = entries[j];
        newprop = properties[j];
        newid = objids[j];

        if (newprop !== property || newid !== objid) {
          if (typeof property !== "undefined")
            putPropvals(propvals);
          property = newprop;
          objid = newid;
          obj = this.getObj(objid);
          propvals = getPropvals();
        }
        if (control.interp) {
          v1 = values[ncol*(i-1) + j];
          v2 = values[ncol*i + j];
          this.setElement(propvals, entry, p*v1 + (1-p)*v2);
        } else if (!direct) {
          this.setElement(propvals, entry, values[ncol*value + j]);
        } else {
          this.setElement(propvals, entry, value[j]);
        }
      }
      putPropvals(propvals);

      needsBinding = [];
      for (j=0; j < entries.length; j++) {
        if (properties[j] === "values" &&
            needsBinding.indexOf(objids[j]) === -1) {
          needsBinding.push(objids[j]);
        }
      }
      for (j=0; j < needsBinding.length; j++) {
        gl = this.gl || this.initGL();
        obj = this.getObj(needsBinding[j]);
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertices
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The vertext setter control data.
     */
    rglwidgetClass.prototype.vertexSetter = function(el, control)  {
      var svals = [].concat(control.param),
          j, k, p, a, propvals, stride, ofs, obj, entry,
          attrib, vertex, varies,
          ofss    = {x:"vofs", y:"vofs", z:"vofs",
                     red:"cofs", green:"cofs", blue:"cofs",
                     alpha:"cofs", radii:"radofs",
                     nx:"nofs", ny:"nofs", nz:"nofs",
                     ox:"oofs", oy:"oofs", oz:"oofs",
                     ts:"tofs", tt:"tofs"},
          pos     = {x:0, y:1, z:2,
                     red:0, green:1, blue:2,
                     alpha:3,radii:0,
                     nx:0, ny:1, nz:2,
                     ox:0, oy:1, oz:2,
                     ts:0, tt:1},
        values = control.values,
        direct = values === null,
        ncol,
        interp = control.interp,
        vertices = [].concat(control.vertices),
        attributes = [].concat(control.attributes),
        value = control.value, newval, aliases, alias;

      ncol = Math.max(vertices.length, attributes.length);

      if (!ncol)
        return;

      vertices = rglwidgetClass.repeatToLen(vertices, ncol);
      attributes = rglwidgetClass.repeatToLen(attributes, ncol);

      if (direct)
        interp = false;

      /* JSON doesn't pass Infinity */
      svals[0] = -Infinity;
      svals[svals.length - 1] = Infinity;

      for (j = 1; j < svals.length; j++) {
        if (value <= svals[j]) {
          if (interp) {
            if (svals[j] === Infinity)
              p = 1;
            else
              p = (svals[j] - value)/(svals[j] - svals[j-1]);
          } else {
            if (svals[j] - value > value - svals[j-1])
              j = j - 1;
          }
          break;
        }
      }

      obj = this.getObj(control.objid);
      // First, make sure color attributes vary in original
      if (typeof obj.vOffsets !== "undefined") {
      	varies = true;
        for (k = 0; k < ncol; k++) {
          attrib = attributes[k];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[attrib]];
            if (ofs < 0) {
              switch(attrib) {
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(control.objid);
      }
      propvals = obj.values;
      aliases = obj.alias;
      if (typeof aliases === "undefined")
        aliases = [];
      for (k=0; k<ncol; k++) {
        if (direct) {
          newval = value;
        } else if (interp) {
          newval = p*values[j-1][k] + (1-p)*values[j][k];
        } else {
          newval = values[j][k];
        }      	
        attrib = attributes[k];
        vertex = vertices[k];
        alias = aliases[vertex];
        if (obj.type === "planes" || obj.type === "clipplanes") {
          ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
          if (ofs >= 0) {
            if (ofs < 3) {
              if (obj.normals[vertex][ofs] !== newval) {  // Assume no aliases here...
              	obj.normals[vertex][ofs] = newval;
              	obj.initialized = false;
              }
            } else {
              if (obj.offsets[vertex][0] !== newval) {
              	obj.offsets[vertex][0] = newval;
              	obj.initialized = false;
              }
            }
            continue;
          }
        }
        // Not a plane setting...
        ofs = obj.vOffsets[ofss[attrib]];
        if (ofs < 0)
          this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
        else {
          stride = obj.vOffsets.stride;
          ofs = ofs + pos[attrib];
          entry = vertex*stride + ofs;
          propvals[entry] = newval;
          if (typeof alias !== "undefined")
            for (a = 0; a < alias.length; a++)
              propvals[alias[a]*stride + ofs] = newval;
        }
      }
      if (typeof obj.buf !== "undefined") {
        var gl = this.gl || this.initGL();
        gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
        gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
      }
    };

    /**
     * Change the requested vertex properties by age
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The age setter control data.
     */
    rglwidgetClass.prototype.ageSetter = function(el, control) {
      var objids = [].concat(control.objids),
          nobjs = objids.length,
          time = control.value,
          births = [].concat(control.births),
          ages = [].concat(control.ages),
          steps = births.length,
          j = Array(steps),
          p = Array(steps),
          i, k, l, age, j0, propvals, stride, ofs, objid, obj,
          attrib, dim, varies, alias, aliases, a, d,
          attribs = ["colors", "alpha", "radii", "vertices",
                     "normals", "origins", "texcoords",
                     "x", "y", "z",
                     "red", "green", "blue"],
          ofss    = ["cofs", "cofs", "radofs", "vofs",
                     "nofs", "oofs", "tofs",
                     "vofs", "vofs", "vofs",
                     "cofs", "cofs", "cofs"],
          dims    = [3,1,1,3,
                     3,2,2,
                     1,1,1,
                     1,1,1],
          pos     = [0,3,0,0,
                     0,0,0,
                     0,1,2,
                     0,1,2];
      /* Infinity doesn't make it through JSON */
      ages[0] = -Infinity;
      ages[ages.length-1] = Infinity;
      for (i = 0; i < steps; i++) {
        if (births[i] !== null) {  // NA in R becomes null
          age = time - births[i];
          for (j0 = 1; age > ages[j0]; j0++);
          if (ages[j0] === Infinity)
            p[i] = 1;
          else if (ages[j0] > ages[j0-1])
            p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
          else
            p[i] = 0;
          j[i] = j0;
        }
      }
      // First, make sure color attributes vary in original
      for (l = 0; l < nobjs; l++) {
      	objid = objids[l];
      	obj = this.getObj(objid);
      	varies = true;
        if (typeof obj.vOffsets === "undefined")
          continue;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs < 0) {
              switch(attribs[k]) {
              	case "colors":
              	case "alpha":
              	case "red":
              	case "green":
              	case "blue":
              	  obj.colors = [obj.colors[0], obj.colors[0]];
              	  break;
              }
              varies = false;
            }
          }
        }
        if (!varies)
          this.initObjId(objid);
      }
      for (l = 0; l < nobjs; l++) {
        objid = objids[l];
        obj = this.getObj(objid);
        if (typeof obj.vOffsets === "undefined")
          continue;
        aliases = obj.alias;
        if (typeof aliases === "undefined")
          aliases = [];
        propvals = obj.values;
        stride = obj.vOffsets.stride;
        for (k = 0; k < attribs.length; k++) {
          attrib = control[attribs[k]];
          if (typeof attrib !== "undefined") {
            ofs = obj.vOffsets[ofss[k]];
            if (ofs >= 0) {
              dim = dims[k];
              ofs = ofs + pos[k];
              for (i = 0; i < steps; i++) {
              	alias = aliases[i];
                if (births[i] !== null) {
                  for (d=0; d < dim; d++) {
                    propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
                    if (typeof alias !== "undefined")
                      for (a=0; a < alias.length; a++)
                        propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
                  }
                }
              }
            } else
              this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
          }
        }
        obj.values = propvals;
        if (typeof obj.buf !== "undefined") {
          var gl = this.gl || this.initGL();
          gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
          gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
        }
      }
    };

    /**
     * Bridge to old style control
     * @param { Object } el - Element of the control; not used.
     * @param { Object } control - The bridge control data.
     */
    rglwidgetClass.prototype.oldBridge = function(el, control) {
      var attrname, global = window[control.prefix + "rgl"];
      if (global)
        for (attrname in global)
          this[attrname] = global[attrname];
      window[control.prefix + "rgl"] = this;
    };

    /**
     * Set up a player control
     * @param { Object } el - The player control element
     * @param { Object } control - The player data.
     */
    rglwidgetClass.prototype.Player = function(el, control) {
      var
        self = this,
        components = [].concat(control.components),
        buttonLabels = [].concat(control.buttonLabels),

        Tick = function() { /* "this" will be a timer */
          var i,
              nominal = this.value,
              slider = this.Slider,
              labels = this.outputLabels,
              output = this.Output,
              step;
          if (typeof slider !== "undefined" && nominal !== slider.value)
            slider.value = nominal;
          if (typeof output !== "undefined") {
            step = Math.round((nominal - output.sliderMin)/output.sliderStep);
            if (labels !== null) {
              output.innerHTML = labels[step];
            } else {
              step = step*output.sliderStep + output.sliderMin;
              output.innerHTML = step.toPrecision(output.outputPrecision);
            }
          }
          for (i=0; i < this.actions.length; i++) {
            this.actions[i].value = nominal;
          }
          self.applyControls(el, this.actions, false);
          self.drawScene();
        },

        OnSliderInput = function() { /* "this" will be the slider */
          this.rgltimer.value = Number(this.value);
          this.rgltimer.Tick();
        },

        addSlider = function(min, max, step, value) {
          var slider = document.createElement("input");
          slider.type = "range";
          slider.min = min;
          slider.max = max;
          slider.step = step;
          slider.value = value;
          slider.oninput = OnSliderInput;
          slider.sliderActions = control.actions;
          slider.sliderScene = this;
          slider.className = "rgl-slider";
          slider.id = el.id + "-slider";
          el.rgltimer.Slider = slider;
          slider.rgltimer = el.rgltimer;
          el.appendChild(slider);
        },

        addLabel = function(labels, min, step, precision) {
          var output = document.createElement("output");
          output.sliderMin = min;
          output.sliderStep = step;
          output.outputPrecision = precision;
          output.className = "rgl-label";
          output.id = el.id + "-label";
          el.rgltimer.Output = output;
          el.rgltimer.outputLabels = labels;
          el.appendChild(output);
        },

        addButton = function(which, label, active) {
          var button = document.createElement("input"),
              onclicks = {Reverse: function() { this.rgltimer.reverse();},
                    Play: function() { this.rgltimer.play();
                                       this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
                   Slower: function() { this.rgltimer.slower(); },
                   Faster: function() { this.rgltimer.faster(); },
                   Reset: function() { this.rgltimer.reset(); },
              	   Step:  function() { this.rgltimer.step(); }
              };
          button.rgltimer = el.rgltimer;
          button.type = "button";
          button.value = label;
          button.activeValue = label;
          button.inactiveValue = active;
          if (which === "Play")
            button.rgltimer.PlayButton = button;
          button.onclick = onclicks[which];
          button.className = "rgl-button";
          button.id = el.id + "-" + which;
          el.appendChild(button);
        };

        if (typeof control.reinit !== "undefined" && control.reinit !== null) {
          control.actions.reinit = control.reinit;
        }
        el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
                                        control.step, control.value, control.rate, control.loop, control.actions);
        for (var i=0; i < components.length; i++) {
          switch(components[i]) {
            case "Slider": addSlider(control.start, control.stop,
                                   control.step, control.value);
              break;
            case "Label": addLabel(control.labels, control.start,
                                   control.step, control.precision);
              break;
            default:
              addButton(components[i], buttonLabels[i], control.pause);
          }
        }
        el.rgltimer.Tick();
    };

    /**
     * Apply all registered controls
     * @param { Object } el - DOM element of the control
     * @param { Object } x - List of actions to apply
     * @param { boolean } [draw=true] - Whether to redraw after applying
     */
    rglwidgetClass.prototype.applyControls = function(el, x, draw) {
      var self = this, reinit = x.reinit, i, control, type;
      for (i = 0; i < x.length; i++) {
        control = x[i];
        type = control.type;
        self[type](el, control);
      }
      if (typeof reinit !== "undefined" && reinit !== null) {
        reinit = [].concat(reinit);
        for (i = 0; i < reinit.length; i++)
          self.getObj(reinit[i]).initialized = false;
      }
      if (typeof draw === "undefined" || draw)
        self.drawScene();
    };

    /**
     * Handler for scene change
     * @param { Object } message - What sort of scene change to do?
     */
    rglwidgetClass.prototype.sceneChangeHandler = function(message) {
      var self = document.getElementById(message.elementId).rglinstance,
          objs = message.objects, mat = message.material,
          root = message.rootSubscene,
          initSubs = message.initSubscenes,
          redraw = message.redrawScene,
          skipRedraw = message.skipRedraw,
          deletes, subs, allsubs = [], i,j;
      if (typeof message.delete !== "undefined") {
        deletes = [].concat(message.delete);
        if (typeof message.delfromSubscenes !== "undefined")
          subs = [].concat(message.delfromSubscenes);
        else
          subs = [];
        for (i = 0; i < deletes.length; i++) {
          for (j = 0; j < subs.length; j++) {
            self.delFromSubscene(deletes[i], subs[j]);
          }
          delete self.scene.objects[deletes[i]];
        }
      }
      if (typeof objs !== "undefined") {
        Object.keys(objs).forEach(function(key){
          key = parseInt(key, 10);
          self.scene.objects[key] = objs[key];
          self.initObjId(key);
          var obj = self.getObj(key),
              subs = [].concat(obj.inSubscenes), k;
          allsubs = allsubs.concat(subs);
          for (k = 0; k < subs.length; k++)
            self.addToSubscene(key, subs[k]);
        });
      }
      if (typeof mat !== "undefined") {
        self.scene.material = mat;
      }
      if (typeof root !== "undefined") {
        self.scene.rootSubscene = root;
      }
      if (typeof initSubs !== "undefined")
        allsubs = allsubs.concat(initSubs);
      allsubs = self.unique(allsubs);
      for (i = 0; i < allsubs.length; i++) {
        self.initSubscene(allsubs[i]);
      }
      if (typeof skipRedraw !== "undefined") {
        root = self.getObj(self.scene.rootSubscene);
        root.par3d.skipRedraw = skipRedraw;
      }
      if (redraw)
        self.drawScene();
    };
</script>
<script>    /**
     * Methods related to selection
     * @name ___METHODS_FOR_SELECTION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Respond to brush change
     */
    rglwidgetClass.prototype.selectionChanged = function() {
      var i, j, k, id, subid = this.select.subscene, subscene,
          objids, obj,
          p1 = this.select.region.p1, p2 = this.select.region.p2,
          filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
          someHidden;
      if (!subid)
        return;
      subscene = this.getObj(subid);
      objids = subscene.objects;
      filter = this.scene.crosstalk.filter;
      this.setmvMatrix(subid);
      this.setprMatrix(subid);
      this.setprmvMatrix();
      xmin = Math.min(p1.x, p2.x);
      xmax = Math.max(p1.x, p2.x);
      ymin = Math.min(p1.y, p2.y);
      ymax = Math.max(p1.y, p2.y);
      for (i = 0; i < objids.length; i++) {
      	id = objids[i];
      	j = this.scene.crosstalk.id.indexOf(id);
      	if (j >= 0) {
      	  keys = this.scene.crosstalk.key[j];
      	  obj = this.getObj(id);
      	  someHidden = false;
      	  for (k = 0; k < keys.length; k++) {
      	    if (filter && filter.indexOf(keys[k]) < 0) {
      	      someHidden = true;
      	      continue;
      	    }
      	    v = [].concat(obj.vertices[k]).concat(1.0);
            v = rglwidgetClass.multVM(v, this.prmvMatrix);
            x = v[0]/v[3];
            y = v[1]/v[3];
            z = v[2]/v[3];
            if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
              selection.push(keys[k]);
            } else
              someHidden = true;
      	  }
      	  obj.someHidden = someHidden && (filter || selection.length);
      	  obj.initialized = false;
      	  /* Who should we notify?  Only shared data in the current subscene, or everyone? */
      	  if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
      	    handle = this.scene.crosstalk.sel_handle[j];
      	    handle.set(selection, {rglSubsceneId: this.select.subscene});
      	  }
      	}
      }
    };
    
    /**
     * Respond to selection or filter change from crosstalk
     * @param { Object } event - crosstalk event
     * @param { boolean } filter - filter or selection?
     */
    rglwidgetClass.prototype.selection = function(event, filter) {
      	var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
      	    selection, someHidden;

      	// Record the message and find out if this event makes some objects have mixed values:
      	
      	crosstalk = this.scene.crosstalk;
      	
      	if (filter) {
      	  filter = crosstalk.filter = event.value;
      	  selection = crosstalk.selection;
      	} else {  
          selection = crosstalk.selection = event.value;
          filter = crosstalk.filter;
      	}
        ids = crosstalk.id;
        for (i = 0; i < ids.length ; i++) {
          obj = this.getObj(ids[i]);
          obj.initialized = false;
          keys = crosstalk.key[i];
          someHidden = false;
          for (j = 0; j < keys.length && !someHidden; j++) {
            if ((filter && filter.indexOf(keys[j]) < 0) ||
                (selection.length && selection.indexOf(keys[j]) < 0))
                someHidden = true;
          }
          obj.someHidden = someHidden;
        }
        this.drawScene();
    };
    
    /**
     * Clear the selection brush
     * @param { number } except - Subscene that should ignore this request
     */
    rglwidgetClass.prototype.clearBrush = function(except) {
      if (this.select.subscene !== except) {
        this.select.region = {p1: {x:Infinity, y:Infinity}, 
                              p2: {x:Infinity, y:Infinity}};
        this.selectionChanged();
        this.select.state = "inactive";
        this.delFromSubscene(this.scene.brushId, this.select.subscene);
      }
      this.drawScene();
    };
    
    /**
     * Set the vertices in the selection box object
     */
    rglwidgetClass.prototype.initSelection = function(id) {
      if (typeof this.select.region === "undefined")
        return;
      var obj = this.getObj(id),
          p1 = this.select.region.p1,
          p2 = this.select.region.p2;
          
      obj.vertices = [[p1.x, p1.y, 0.0],
                      [p2.x, p1.y, 0.0],
                      [p2.x, p2.y, 0.0],
                      [p1.x, p2.y, 0.0],
                      [p1.x, p1.y, 0.0]];
    };
</script>
<script>
/* globals rgltimerClass: true */

/**
 * The class of an rgl timer object
 * @class
*/

/**
 * Construct an rgltimerClass object
 * @constructor
 * @param { function } Tick - action when timer fires
 * @param { number } startTime - nominal start time in seconds
 * @param { number } interval - seconds between updates
 * @param { number } stopTime - nominal stop time in seconds
 * @param { number } stepSize - nominal step size
 * @param { number } value - current nominal time
 * @param { number } rate - nominal units per second
 * @param { string } loop - "none", "cycle" or "oscillate"
 * @param { Object } actions - list of actions
 */
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
  this.enabled = false;
  this.timerId = 0;
  /** nominal start time in seconds */
  this.startTime = startTime;   
  /** current nominal time */      
  this.value = value;
  /** seconds between updates */                 
  this.interval = interval;
  /** nominal stop time */           
  this.stopTime = stopTime;
  /** nominal step size */           
  this.stepSize = stepSize;
  /** nominal units per second */           
  this.rate = rate;
  /** "none", "cycle", or "oscillate" */                   
  this.loop = loop;
  /** real world start time */                   
  this.realStart = undefined;
  /** multiplier for fast-forward or reverse */         
  this.multiplier = 1;                
  this.actions = actions;
  this.Tick = Tick;
};


    /**
     * Methods related to players
     * @name ___METHODS_FOR_PLAYERS___
     * @memberof rgltimerClass
     * @kind function
     * @instance
     */

  /**
   * Start playing
   * @memberof rgltimerClass
   */
  rgltimerClass.prototype.play = function() {
    if (this.enabled) {
      this.enabled = false;
      window.clearInterval(this.timerId);
      this.timerId = 0;
      return;
    }
    var tick = function(self) {
      var now = new Date();
      self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
      self.forceToRange();
      if (typeof self.Tick !== "undefined") {
        self.Tick(self.value);
      }

    };
    this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
    this.timerId = window.setInterval(tick, 1000*this.interval, this);
    this.enabled = true;
  };

  /**
   * Force value into legal range
   */
  rgltimerClass.prototype.forceToRange = function() {
    if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
      if (!this.loop) {
        this.reset();
      } else {
        var cycle = this.stopTime - this.startTime + this.stepSize,
            newval = (this.value - this.startTime) % cycle + this.startTime;
        if (newval < this.startTime) {
          newval += cycle;
        }
        this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
        this.value = newval;
      }
    }
  };

  /**
   * Reset to start values
   */
  rgltimerClass.prototype.reset = function() {
    this.value = this.startTime;
    this.newmultiplier(1);
    if (typeof this.Tick !== "undefined") {
        this.Tick(this.value);
    }
    if (this.enabled)
      this.play();  /* really pause... */
    if (typeof this.PlayButton !== "undefined")
      this.PlayButton.value = "Play";
  };

  /**
   * Increase the multiplier to play faster
   */
  rgltimerClass.prototype.faster = function() {
    this.newmultiplier(Math.SQRT2*this.multiplier);
  };

  /**
   * Decrease the multiplier to play slower
   */
  rgltimerClass.prototype.slower = function() {
    this.newmultiplier(this.multiplier/Math.SQRT2);
  };

  /**
   * Change sign of multiplier to reverse direction
   */
  rgltimerClass.prototype.reverse = function() {
    this.newmultiplier(-this.multiplier);
  };

  /**
   * Set multiplier for play speed
   * @param { number } newmult - new value
   */
  rgltimerClass.prototype.newmultiplier = function(newmult) {
    if (newmult !== this.multiplier) {
      this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
      this.multiplier = newmult;
    }
  };

  /**
   * Take one step
   */
  rgltimerClass.prototype.step = function() {
    this.value += this.rate*this.multiplier;
    this.forceToRange();
    if (typeof this.Tick !== "undefined")
      this.Tick(this.value);
  };
</script>
<script>/**
 * Pretty function from R
 * @name ___PRETTY_FROM_R___
 * @memberof rglwidgetClass
 * @kind function
 * @instance
 */


/* This file is translated from pretty.c, which was
 taken from the R sources, r61744 of src/appl/pretty.c,
 with minimal changes */

/*
 *  R : A Computer Language for Statistical Data Analysis
 *  Copyright (C) 1995-2012  The R Core Team
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, a copy is available at
 *  http://www.r-project.org/Licenses/
 */

/**     
 * Construct pretty values to cover an interval
 * @param { number } lo - lower end of interval
 * @param { number } up - upper end of interval
 * @param { number } ndiv - requested number of divisions
 * @param { number } min_n - minimum divisions
 * @param { number } shrink_sml - if too many cells, amount to shrink by
 * @param { number } high_u_fact - bias in favour of larger units
 * @param { number } eps_correction - correction to bounds
 * @param { Boolean } return_bounds - whether to return bounds
 * @description
 * Pretty Intervals

 * Constructs m "pretty" values which cover the given interval	*lo <= *up
 *	m ~= *ndiv + 1	(i.e., ndiv := approximate number of INTERVALS)
 *
 * It is not quite clear what should happen for	 *lo = *up;
 * S itself behaves quite funilly, then.
 *
 * In my opinion, a proper 'pretty' should always ensure
 * *lo < *up, and hence *ndiv >=1 in the result.
 * However, in S and here, we allow  *lo == *up, and *ndiv = 0.
 * Note however, that we are NOT COMPATIBLE to S. [Martin M.]
 *
 * NEW (0.63.2): ns, nu are double (==> no danger of integer overflow)
 *
 * We determine
 * if the interval (up - lo) is ``small'' [<==>	 i_small == TRUE, below].
 * For the ``i_small'' situation, there is a parameter  shrink_sml,
 * the factor by which the "scale" is shrunk.		~~~~~~~~~~
 * It is advisable to set it to some (smaller) integer power of 2,
 * since this enables exact floating point division.
 */
rglwidgetClass.prototype.R_pretty = function(
  lo, up, ndiv, min_n, shrink_sml, high_u_fact,
  eps_correction, return_bounds) {
  /* From version 0.65 on, we had rounding_eps := 1e-5, before, r..eps = 0
   * 1e-7 is consistent with seq.default() */
  var rounding_eps = 1e-7,  h = high_u_fact[0],
                                           h5 = high_u_fact[1], 
                                                           dx, cell, unit, base, U, ns, nu, k, i_small,
                                                           DBL_EPSILON = Number.EPSILON,
                                                           DBL_MIN = Number.MIN_VALUE,
                                                           DBL_MAX = Number.MAX_VALUE;
  
  dx = up - lo;
  /* cell := "scale"	here */
  if (dx === 0 && up === 0) { /*  up == lo == 0	 */
  cell = 1;
    i_small = true;
  } else {
    cell = Math.max(Math.abs(lo), Math.abs(up));
    /* U = upper bound on cell/unit */
    U = (1 + (h5 >= 1.5*h+0.5)) ? 1/(1+h) : 1.5/(1+h5);
    /* added times 3, as several calculations here */
    i_small = dx < cell * U * Math.max(1,ndiv) * DBL_EPSILON *3;
  }
  
  /*OLD: cell = FLT_EPSILON+ dx / *ndiv; FLT_EPSILON = 1.192e-07 */
  if(i_small) {
    if(cell > 10)
      cell = 9 + cell/10;
    cell *= shrink_sml;
    if(min_n > 1) cell /= min_n;
  } else {
    cell = dx;
    if(ndiv > 1) cell /= ndiv;
  }
  
  if(cell < 20*DBL_MIN) {
    /* warning(_("Internal(pretty()): very small range.. corrected")); */
    cell = 20*DBL_MIN;
  } else if(cell * 10 > DBL_MAX) {
    /* warning(_("Internal(pretty()): very large range.. corrected")); */
    cell = 0.1*DBL_MAX;
  }
  base = Math.pow(10, Math.floor(Math.log10(cell))); /* base <= cell < 10*base */
    
    /* unit : from { 1,2,5,10 } * base
     *	 such that |u - cell| is small,
     * favoring larger (if h > 1, else smaller)  u  values;
     * favor '5' more than '2'  if h5 > h  (default h5 = .5 + 1.5 h) */
    unit = base;
    if((U = 2*base)-cell <  h*(cell-unit)) { unit = U;
      if((U = 5*base)-cell < h5*(cell-unit)) { unit = U;
        if((U =10*base)-cell <  h*(cell-unit)) unit = U; }}
    /* Result: c := cell,  u := unit,  b := base
     *	c in [	1,	      (2+ h) /(1+h) ] b ==> u=  b
     *	c in ( (2+ h)/(1+h),  (5+2h5)/(1+h5)] b ==> u= 2b
     *	c in ( (5+2h)/(1+h), (10+5h) /(1+h) ] b ==> u= 5b
     *	c in ((10+5h)/(1+h),	         10 ) b ==> u=10b
     *
     *	===>	2/5 *(2+h)/(1+h)  <=  c/u  <=  (2+h)/(1+h)	*/
    
    ns = Math.floor(lo/unit+rounding_eps);
    nu = Math.ceil (up/unit-rounding_eps);
    
    if(eps_correction && (eps_correction > 1 || !i_small)) {
      if(lo !== 0.0) lo *= (1- DBL_EPSILON); else lo = -DBL_MIN;
      if(up !== 0.0) up *= (1+ DBL_EPSILON); else up = +DBL_MIN;
    }
    
    while(ns*unit > lo + rounding_eps*unit) ns--;
    
    while(nu*unit < up - rounding_eps*unit) nu++;
    
    k = Math.floor(0.5 + nu - ns);
    if(k < min_n) {
      /* ensure that	nu - ns	 == min_n */
      
      k = min_n - k;
      if(ns >= 0) {
        nu += k/2;
        ns -= k/2 + k%2;/* ==> nu-ns = old(nu-ns) + min_n -k = min_n */
      } else {
        ns -= k/2;
        nu += k/2 + k%2;
      }
      ndiv = min_n;
    } else {
      ndiv = k;
    }
    if(return_bounds) { /* if()'s to ensure that result covers original range */
      if(ns * unit < lo) lo = ns * unit;
      if(nu * unit > up) up = nu * unit;
    } else {
      lo = ns;
      up = nu;
    }
    return {lo:lo, up:up, ndiv:ndiv, unit:unit};
};
</script>
<script>    /**
     * Methods related to axes
     * @name ___METHODS_FOR_AXES___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
     
    /**
     * Choose edges for ticks
     * @param { Matrix } prmv - projection-model-view matrix
     */
    rglwidgetClass.prototype.getTickEdges = function(prmv){
      var vertices = [[0,0,0,1], [0,0,1,1],
                      [0,1,0,1], [0,1,1,1],
                      [1,0,0,1], [1,0,1,1],
                      [1,1,0,1], [1,1,1,1]], 
           dim, i, j, k, edges, hull, step, result = [], proj = [],

        // Filter to edges that are on sides that would
        // be shown with a filled backing.
        
      has_back = function(edge) {
          var normals = [[], []],
              verts = [vertices[edge[0]], 
                       vertices[edge[1]]], 
              normal, m, n;
          n = 0;
          for (m=0; m<3; m++) {
            if (verts[0][m] === verts[1][m]) {
              normals[n] = [0,0,0,1];
              normals[n][m] = 2*verts[0][m] - 1;
              n++;
            }
          }
          for (n=0; n<2; n++) {
            normal = rglwidgetClass.multVM(normals[n], self.normMatrix);
            if (normal[2] < 0 ||
                (normal[2] === 0 && normal[0] < 0))
              return true;
          }
          return false;
        }, self = this;
        
      for (i = 0; i < vertices.length; i++) {
        proj[i] = rglwidgetClass.multVM(vertices[i], prmv);
        proj[i][0] = proj[i][0]/proj[i][3];
        proj[i][1] = proj[i][1]/proj[i][3];
        proj[i][2] = i;
      }
      hull = rglwidgetClass.chull(proj.slice());  
      for (i = 0; i < hull.length; i++)
        hull[i] = hull[i][2];
      hull.push(hull[0]);
      for (dim = 0; dim < 3; dim++) { 
        edges = [];
        step = Math.pow(2, 2-dim);
        for (i = 0; i < 4; i++) {
          j = (dim === 0) ? i : (dim === 1) ? i + 2*(i>1) : 2*i;
          for (k = 0; k < hull.length - 1; k++) {
            if ((hull[k] === j && hull[k+1] === j + step) ||
                (hull[k] === j+step && hull[k+1] === j))
          
              edges.push([j, j+step], [j+step, j]);
          }
        }

        edges = edges.filter(has_back);
        
        // Find the edge with a vertex closest
        // to the bottom left corner
        if (edges.length) {
          var best, best2, val = Infinity, newval;
          for (i = 0; i < edges.length; i++) {
            j = edges[i][0];
            newval = proj[j][0] + proj[j][1];
            if (newval < val) {
              best = j;
              best2 = edges[i][1];
              val = newval;
            }
          }
          if (typeof best !== "undefined") {
            result[dim] = vertices[best].slice(0,3);
            result[dim][dim] = undefined;
          } else
            result[dim] = undefined;
        }
      }
      return result;
    };
    
    /**
     * Choose tick locations
     * @param { Object } obj - The bboxdeco
    */
    rglwidgetClass.prototype.getTickLocations = function(obj){
      var dim, i, limits, locations = [], result = [[],[],[]], value,
          len, delta, range, bbox = obj.bbox;
      obj.needsAxisCallback = false;
      for (dim = 0; dim < 3; dim++) {
        limits = bbox.slice(2*dim, 2*dim + 2);
        range = limits[1] - limits[0];
        switch(obj.axes.mode[dim]) {
        case "custom":
          for (i=0; i < obj.vertices.length; i++) {
            value = (obj.vertices[i][dim] - limits[0])/range;
            if (typeof value !== "undefined" &&
                !isNaN(value))
              result[dim].push(value);
          }
          break;
        case "fixedstep":
          len = Math.floor(range/obj.axes.step[dim]);
          delta = obj.axes.step[dim];
          for (i = 0; i < len; i++)
            result[dim].push(i*delta);          
          break;
        case "fixednum":
          len = obj.axes.nticks[dim];
          delta = (len > 1) ? range/(len-1) : 0;
          for (i = 0; i < len; i++)
            result[dim].push(i*delta/range);
          break;
        case "pretty":
          locations = this.R_pretty(limits[0], limits[1], 5,
                                  2, // min_n
                                  0.75, // shrink_sml
                                  [1.5, 2.75], // high_u_fact
                                  0, // eps_correction
                                  0); // return_bounds)  
          for (i = locations.lo; i <= locations.up; i++) {
            value = (i*locations.unit - limits[0])/range;
            if (0 < value && value < 1)
              result[dim].push(value);
          }
          break;
        case "user":
          obj.needsAxisCallback = true;
          break;
        }
      }
      return result;
    };
    
    /**
     * Set tick vertices
     * @param { Object } ticks - the tick object
     * @param { Array }  edges - Which edges get the ticks?
    */
    rglwidgetClass.prototype.getTickVertices = function(ticks) {
      var dim, i, j, vertices = [], locations, 
          edges = ticks.edges, edge;
      for (dim = 0; dim < 3; dim++) {
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) 
            if (typeof edges[dim] !== "undefined") {
              edge = edges[dim].slice();
              edge[dim] = locations[i];
              vertices.push(edge);
              edge = edge.slice();
              for (j = 0; j < 3; j++)       
                if ((dim < 2 && j === 1 - dim) || 
                    (dim === 2 && j === 0))
                  edge[j] += 2*(edge[j] - 0.5)/ticks.axes.marklen[dim];
              vertices.push(edge);
            }
        }
      ticks.vertices = vertices;
      ticks.vertexCount = vertices.length;
      ticks.values = new Float32Array(rglwidgetClass.flatten(vertices));
      ticks.initialized = false;
    };
    
    /**
     * Set tick label positions
     * @param { Object } obj - the bbox object
    */
    rglwidgetClass.prototype.placeTickLabels = function(obj) {
      var ticks = obj.ticks, labels = obj.labels, i,j,k,
          vertices = [], tickvertices = ticks.vertices, 
          vertex, locations, dim, edges = obj.ticks.edges;
      j = 0;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        locations = ticks.locations[dim];
        if (locations.length)
          for (i = 0; i < locations.length; i++) {
            if (isNaN(locations[i]))
              continue;
            while (j < tickvertices.length && 
                   tickvertices[j][dim] !== locations[i]) j++;
            if (j >= tickvertices.length)
              break;
            vertex = tickvertices[j].slice();
            for (k = 0; k < 3; k++)
              vertex[k] += 2*(tickvertices[j+1][k] - vertex[k]);
            vertices.push(vertex);
            j += 2;
          }
        }
      labels.vertices = vertices;
      labels.centers = labels.vertices;
      labels.initialized = false;
    };  
     
    /**
     * Set tick labels
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setTickLabels = function(obj) {
      var ticks = obj.ticks, mode, locations, labels = [],
      start = 0, nticks, dim, i, limits, range, values, max,
      edges = obj.ticks.edges;
      for (dim = 0; dim < 3; dim++) {
        if (typeof edges[dim] === "undefined") 
          continue;
        mode = obj.axes.mode[dim];
        nticks = obj.axes.nticks[dim]; // used on input only for custom!
        if (mode === "custom") 
          labels = labels.concat(obj.texts.slice(start, start + nticks));
        else {
          limits = obj.bbox.slice(2*dim, 2*(dim+1));
          range = limits[1] - limits[0];
          locations = ticks.locations[dim];
          max = -Infinity;
          values = [];
          for (i = 0; i < locations.length; i++) {
            values.push(limits[0] + range*locations[i]);
            max = Math.max(max, Math.abs(values[i]));
          }
          for (i = 0; i < locations.length; i++) {
            if (Math.abs(values[i])/max < Math.pow(10, -5))
              values[i] = 0;
            labels.push(rglwidgetClass.signif(values[i], 4).toString());
          }
          obj.axes.nticks[dim] = locations.length;  
        }
        start += nticks;
      }
      obj.labels.texts = labels;
    };

    /**
     * Set bboxdeco bbox and center vector 
     * @param { Object } obj - the bbox object
     */ 
    rglwidgetClass.prototype.setBbox = function(obj, subscene) {
      var i, expand, center = [], bbox;
      if (!obj.initialized)
        this.initBBox(obj);
        
      bbox = [].concat(subscene.par3d.bbox);
      for (i = 0; i < 3; i++) {
        expand = obj.axes.expand[i];
        center[i] = (bbox[2*i] + bbox[2*i + 1])/2;
        bbox[2*i] = center[i] - expand*(bbox[2*i + 1] - center[i]);
        bbox[2*i+1] = center[i] + expand*(bbox[2*i + 1] - center[i]);
      }
      obj.bbox = bbox;
      obj.center = center;
    };

    rglwidgetClass.prototype.setBBoxMatrices = function(obj) {
      var saved = {normMatrix: new CanvasMatrix4(this.normMatrix),
                   mvMatrix: new CanvasMatrix4(this.mvMatrix)},
          bboxNorm, bboxMV, bbox = obj.bbox, scale;
          
      bboxNorm = new CanvasMatrix4();
      scale = [bbox[1]-bbox[0], bbox[3]-bbox[2], bbox[5]-bbox[4]];
      bboxNorm.scale(1/scale[0], 1/scale[1], 1/scale[2]);
      bboxNorm.multRight(saved.normMatrix);
      this.normMatrix = bboxNorm;

      bboxMV = new CanvasMatrix4();
      bboxMV.scale(scale[0], scale[1], scale[2]);
      bboxMV.translate(bbox[0], bbox[2], bbox[4]);
      bboxMV.multRight(saved.mvMatrix);
      this.mvMatrix = obj.mvMatrix = bboxMV;
      
      if (this.prmvMatrix === null)
        saved.prmvMatrix = null;
      else
        saved.prmvMatrix = new CanvasMatrix4(this.prmvMatrix);
        
      this.setprmvMatrix();
      obj.prmvMatrix = this.prmvMatrix;
      
      return saved;
    };
    
    rglwidgetClass.prototype.restoreBBoxMatrices = function(saved) {
      this.normMatrix = saved.normMatrix;
      this.mvMatrix   = saved.mvMatrix;
      this.prmvMatrix = saved.prmvMatrix;
    };
    
    rglwidgetClass.prototype.getMarginParameters = function(bboxdeco, material) {
      // Assume we've run this.setBbox(bboxdeco, subscene);
      var bbox = bboxdeco.bbox,
          edge = [].concat(material.edge),
          saved, edges, i, 
          at = material.margin, line, level, trans, scale;

      if (material.floating) {
        saved = this.setBBoxMatrices(bboxdeco);
        edges = this.getTickEdges(this.prmvMatrix)[at];
        this.restoreBBoxMatrices(saved);
        if (typeof edges !== "undefined")
          for (i = 0; i < 3; i++) {
            if (edges[i] < 1) edges[i] = -1;
              edge[i] = edge[i]*edges[i];
        } else
          return undefined;
      }
      switch(at) {
      case 0: line = 1;
              level = 2;
              break;
      case 1: line = 0;
              level = 2;
              break;
      case 2: line = 0;
              level = 1;
              break;
      }
      scale = [edge[0]*(bbox[1]-bbox[0])/bboxdeco.axes.marklen[0], 
               edge[1]*(bbox[3]-bbox[2])/bboxdeco.axes.marklen[1], 
               edge[2]*(bbox[5]-bbox[4])/bboxdeco.axes.marklen[2]];
      trans = [edge[0] === 1 ? bbox[1] : bbox[0],
               edge[1] === 1 ? bbox[3] : bbox[2],
               edge[2] === 1 ? bbox[5] : bbox[4]];
      return {at: at, line: line, level: level, trans: trans, scale: scale};        
    };
    
    rglwidgetClass.prototype.fixVertex = function(orig, parms, center, bbox) {
      var vertex = [0,0,0];
      if (rglwidgetClass.missing(orig[0]))
        vertex[parms.at] = center[parms.at];
      else if (orig[0] === "-Inf")
        vertex[parms.at] = bbox[2*parms.at];
      else if (orig[0] === "Inf")
        vertex[parms.at] = bbox[2*parms.at + 1];
      else
        vertex[parms.at] = orig[0];
      vertex[parms.line] = parms.scale[parms.line]*orig[1] + 
          parms.trans[parms.line];
      vertex[parms.level] = parms.scale[parms.level]*orig[2] + 
          parms.trans[parms.level];
      return vertex;
    };
    
    rglwidgetClass.prototype.fixNormal = function(orig, parms) {
      var vertex = [0,0,0];
      vertex[parms.at] = orig[0];
      vertex[parms.line] = orig[1]/parms.scale[parms.line];
      vertex[parms.level] = orig[2]/parms.scale[parms.level];
      return vertex;
    };

    rglwidgetClass.prototype.marginVecToDataVec = function(obj, subscene) {
      var bboxdeco = this.getBBoxDeco(subscene),
          center, bbox, parms, parmsjson,
          orig = obj.orig, 
          vertices = [], normals = [],
          centers = [], i, vertex;
      if (typeof orig === "undefined") {
        orig = {vert: obj.vertices,
                norm: obj.normals,
                cent: obj.centers,
                doNormals: typeof obj.normals !== "undefined",
                doCenters: typeof obj.centers !== "undefined",
                parms: ""
               };
        obj.orig = orig;
      }

      if (typeof bboxdeco !== "undefined") {
        this.setBbox(bboxdeco, subscene);
        center = bboxdeco.center;
        bbox = bboxdeco.bbox;
        parms = this.getMarginParameters(bboxdeco, obj.material);
        if (typeof parms === "undefined")
          return false;  /* axis is not currently shown */
        
        parmsjson = JSON.stringify(parms);
        if (parmsjson === orig.parms)
          return true;  /* nothing has changed */
    
        orig.parms = parmsjson;
        
        for (i=0; i < orig.vert.length; i++) {
          vertex = this.fixVertex(orig.vert[i], parms, center, bbox);
          vertices.push(vertex);
        }
        obj.vertices = vertices;
        if (orig.doNormals) {
          for (i=0; i < orig.norm.length; i++) {
            vertex = this.fixNormal(orig.norm[i], parms);
            normals.push(vertex);
          }
          obj.normals = normals;
        }
        if (orig.doCenters) {
          for (i=0; i < orig.cent.length; i++) {
            vertex = this.fixVertex(orig.cent[i], parms, center, bbox);
            centers.push(vertex);
          }
          obj.centers = centers;
        }
        
        obj.initialized = false;
        return true;
      } else {
        console.warn("bboxdeco not found");
        return false;
      }
    };

    rglwidgetClass.prototype.doAxisCallback = function(obj, edges) {
      var i, j, code, axis, fn;
      for (i = 0; i < 3; i++) {
        if (obj.axes.mode[i] === "user") {
          axis = ["x", "y", "z"][i];
          if (typeof obj.callbacks !== "undefined" &&
              typeof (code = obj.callbacks[axis]) !== "undefined") {
            if (typeof edges[i] !== "undefined")
              for (j = 0; j < 3; j++)
                if (typeof edges[i][j] !== "undefined")
                  axis = axis + (edges[i][j] > 0 ? "+" : "-");
            
          /* jshint evil:true */
            fn = Function('"use strict";return (' + code + ')')();
          /* jshint evil:false */
            fn.call(this, axis);
          }
        }
      }
    };
</script>
<script>/**
     * Methods related to animations
     * @name ___METHODS_FOR_ANIMATION___
     * @memberof rglwidgetClass
     * @kind function
     * @instance
     */
    /**
     * Binary search
     * @param x - x coordinates in increasing order
     * @param newx - value to find, assumed to be in the range of x
     * @result index of largest x value below newx
     */
    rglwidgetClass.bisect = function(x, newx) {
      var lo = 0, hi = x.length - 1, mid;
      while (lo < hi - 1) {
        mid = Math.round((lo + hi)/2);
        if (x[mid] < newx)
          lo = mid;
        else
          hi = mid;
      }
      return lo;
    };
    
    /**
     * Step interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.step = function(x, v, newx) {
      var n, lo;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      return v[lo];
    };
    
    /**
     * Linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - values at x; either a vector or matrix
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.lerp = function(x, v, newx) {
      var i, n, lo, hi, alpha, result;
      if (newx <= x[0])
        return v[0];    
      n = x.length;
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      alpha = (newx - x[lo])/(x[hi] - x[lo]);
      result = v[lo];
      n = result.length;
      if (typeof n !== "undefined") {
        for (i = 0; i < n; i++)
          result[i] = (1 - alpha)*result[i] + alpha*v[hi][i];
      } else
        result = (1 - alpha)*result + alpha*v[hi];
      return result;
    };
    
    /**
     * Spherical linear interpolation (constant outside bounds)
     * @param x - x coordinates in increasing order
     * @param v - a matrix of unit quaternions
     * @param newx - value at which to evaluate
     */
    rglwidgetClass.slerp = function(x, v, newx) {
      var n, lo, hi, alpha, result,
          p0, p1, dot, Omega, alpha0, alpha1, len;
      if (newx <= x[0])
        return v[0];    
      if (newx >= x[n-1])
        return v[n-1];
      lo = this.bisect(x, newx);
      if (newx === x[lo])
        return v[lo];
      hi = lo + 1;
      if (newx === x[hi])
        return v[hi];
      p0 = v[lo];
      p1 = v[hi];
      dot = p0[0]*p1[0] + 
            p0[1]*p1[1] +
            p0[2]*p1[2] +
            p0[3]*p1[3];
      if (dot < 0) {
        p1 = [-p1[0], -p1[1], -p1[2], -p1[3]];
        dot = -dot;
      }
      if (dot >= 1)
        result = p1;
      else {
        alpha = (newx - x[lo])/(x[hi] - x[lo]);
        Omega = Math.acos(dot);
        alpha0 = Math.sin((1 - alpha)*Omega);
        alpha1 = Math.sin(alpha*Omega);
        result = [alpha0*p0[0] + alpha1*p1[0],
                  alpha0*p0[1] + alpha1*p1[1],
                  alpha0*p0[2] + alpha1*p1[2],
                  alpha0*p0[3] + alpha1*p1[3]];
      }
      len = Math.sqrt(result[0]*result[0] +
                      result[1]*result[1] +
                      result[2]*result[2] +
                      result[3]*result[3]);
      return [result[0]/len,
              result[1]/len,
              result[2]/len,
              result[3]/len];
    };

    /**
     * Rotate using unit quaternion
     * @param q - a single unit quaternion
     */
    rglwidgetClass.rotateByQuaternion = function(M, q) {

    var xx = q[0]*q[0],
        xy = q[0]*q[1],
        xz = q[0]*q[2],
        xw = q[0]*q[3],
        yy = q[1]*q[1],
        yz = q[1]*q[2],
        yw = q[1]*q[3],
        zz = q[2]*q[2],
        zw = q[2]*q[3],
        matrix = new CanvasMatrix4();
      matrix.m11 = 1 - 2*(yy + zz);
      matrix.m12 = 2*(xy + zw);
      matrix.m13 = 2*(xz - yw);
        
      matrix.m21 = 2*(xy - zw);
      matrix.m22 = 1 - 2*(xx + zz);
      matrix.m23 = 2*(yz + xw);

      matrix.m31 = 2*(xz + yw);
      matrix.m32 = 2*(yz - xw);
      matrix.m33 = 1 - 2*(xx + yy);

      M.multRight(matrix);      
    };
</script>
<!--html_preserve--><script type="text/plain" id="rgl-vertex-shader">
#line 2 1
// File 1 is the vertex shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif

attribute vec3 aPos;
attribute vec4 aCol;
uniform mat4 mvMatrix;
uniform mat4 prMatrix;
varying vec4 vCol;
varying vec4 vPosition;

#ifdef NEEDS_VNORMAL
attribute vec3 aNorm;
uniform mat4 normMatrix;
varying vec4 vNormal;
#endif

#if defined(HAS_TEXTURE) || defined (IS_TEXT)
attribute vec2 aTexcoord;
varying vec2 vTexcoord;
#endif

#ifdef FIXED_SIZE
uniform vec3 textScale;
#endif

#ifdef FIXED_QUADS
attribute vec3 aOfs;
#endif

#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
varying float normz;
uniform mat4 invPrMatrix;
#else
attribute vec3 aPos1;
attribute vec3 aPos2;
varying float normz;
#endif
#endif // IS_TWOSIDED

#ifdef FAT_LINES
attribute vec3 aNext;
attribute vec2 aPoint;
varying vec2 vPoint;
varying float vLength;
uniform float uAspect;
uniform float uLwd;
#endif


void main(void) {
  
#ifndef IS_BRUSH
#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)
  vPosition = mvMatrix * vec4(aPos, 1.);
#endif
  
#ifndef FIXED_QUADS
  gl_Position = prMatrix * vPosition;
#endif
#endif // !IS_BRUSH
  
#ifdef IS_POINTS
  gl_PointSize = POINTSIZE;
#endif
  
  vCol = aCol;
  
#ifdef NEEDS_VNORMAL
  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));
#endif
  
#ifdef IS_TWOSIDED
#ifdef HAS_NORMALS
  /* normz should be calculated *after* projection */
  normz = (invPrMatrix*vNormal).z;
#else
  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));
  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;
  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));
  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;
  normz = pos1.x*pos2.y - pos1.y*pos2.x;
#endif
#endif // IS_TWOSIDED
  
#ifdef NEEDS_VNORMAL
  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);
#endif
  
#if defined(HAS_TEXTURE) || defined(IS_TEXT)
  vTexcoord = aTexcoord;
#endif
  
#if defined(FIXED_SIZE) && !defined(ROTATING)
  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w;
  gl_Position = pos + vec4(aOfs*textScale, 0.);
#endif
  
#if defined(IS_SPRITES) && !defined(FIXED_SIZE)
  vec4 pos = mvMatrix * vec4(aPos, 1.);
  pos = pos/pos.w + vec4(aOfs,  0.);
  gl_Position = prMatrix*pos;
#endif
  
#ifdef FAT_LINES
  /* This code was inspired by Matt Deslauriers' code in 
   https://mattdesl.svbtle.com/drawing-lines-is-hard */
  vec2 aspectVec = vec2(uAspect, 1.0);
  mat4 projViewModel = prMatrix * mvMatrix;
  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);
  currentProjected = currentProjected/currentProjected.w;
  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);
  vec2 currentScreen = currentProjected.xy * aspectVec;
  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;
  float len = uLwd;
  vec2 dir = vec2(1.0, 0.0);
  vPoint = aPoint;
  vLength = length(nextScreen - currentScreen)/2.0;
  vLength = vLength/(vLength + len);
  if (vLength > 0.0) {
    dir = normalize(nextScreen - currentScreen);
  }
  vec2 normal = vec2(-dir.y, dir.x);
  dir.x /= uAspect;
  normal.x /= uAspect;
  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);
  gl_Position = currentProjected + offset;
#endif
  
#ifdef IS_BRUSH
  gl_Position = vec4(aPos, 1.);
#endif
}
</script>
<script type="text/plain" id="rgl-fragment-shader">
#line 2 2
// File 2 is the fragment shader
#ifdef GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif
varying vec4 vCol; // carries alpha
varying vec4 vPosition;
#if defined(HAS_TEXTURE) || defined (IS_TEXT)
varying vec2 vTexcoord;
uniform sampler2D uSampler;
#endif

#ifdef HAS_FOG
uniform int uFogMode;
uniform vec3 uFogColor;
uniform vec4 uFogParms;
#endif

#if defined(IS_LIT) && !defined(FIXED_QUADS)
varying vec4 vNormal;
#endif

#if NCLIPPLANES > 0
uniform vec4 vClipplane[NCLIPPLANES];
#endif

#if NLIGHTS > 0
uniform mat4 mvMatrix;
#endif

#ifdef IS_LIT
uniform vec3 emission;
uniform float shininess;
#if NLIGHTS > 0
uniform vec3 ambient[NLIGHTS];
uniform vec3 specular[NLIGHTS]; // light*material
uniform vec3 diffuse[NLIGHTS];
uniform vec3 lightDir[NLIGHTS];
uniform bool viewpoint[NLIGHTS];
uniform bool finite[NLIGHTS];
#endif
#endif // IS_LIT

#ifdef IS_TWOSIDED
uniform bool front;
varying float normz;
#endif

#ifdef FAT_LINES
varying vec2 vPoint;
varying float vLength;
#endif

void main(void) {
  vec4 fragColor;
#ifdef FAT_LINES
  vec2 point = vPoint;
  bool neg = point.y < 0.0;
  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :
                 -(point.y - vLength)/(1.0 - vLength);
#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)
  if (neg && length(point) <= 1.0) discard;
#endif
  point.y = min(point.y, 0.0);
  if (length(point) > 1.0) discard;
#endif // FAT_LINES
  
#ifdef ROUND_POINTS
  vec2 coord = gl_PointCoord - vec2(0.5);
  if (length(coord) > 0.5) discard;
#endif
  
#if NCLIPPLANES > 0
  for (int i = 0; i < NCLIPPLANES; i++)
    if (dot(vPosition, vClipplane[i]) < 0.0) discard;
#endif
    
#ifdef FIXED_QUADS
    vec3 n = vec3(0., 0., 1.);
#elif defined(IS_LIT)
    vec3 n = normalize(vNormal.xyz);
#endif
    
#ifdef IS_TWOSIDED
    if ((normz <= 0.) != front) discard;
#endif
    
#ifdef IS_LIT
    vec3 eye = normalize(-vPosition.xyz/vPosition.w);
    vec3 lightdir;
    vec4 colDiff;
    vec3 halfVec;
    vec4 lighteffect = vec4(emission, 0.);
    vec3 col;
    float nDotL;
#ifdef FIXED_QUADS
    n = -faceforward(n, n, eye);
#endif
    
#if NLIGHTS > 0
    for (int i=0;i<NLIGHTS;i++) {
      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);
      lightdir = lightDir[i];
      if (!viewpoint[i])
        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;
      if (!finite[i]) {
        halfVec = normalize(lightdir + eye);
      } else {
        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);
        halfVec = normalize(lightdir + eye);
      }
      col = ambient[i];
      nDotL = dot(n, lightdir);
      col = col + max(nDotL, 0.) * colDiff.rgb;
      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];
      lighteffect = lighteffect + vec4(col, colDiff.a);
    }
#endif
    
#else // not IS_LIT
    vec4 colDiff = vCol;
    vec4 lighteffect = colDiff;
#endif
    
#ifdef IS_TEXT
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef HAS_TEXTURE
#ifdef TEXTURE_rgb
    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);
#endif
    
#ifdef TEXTURE_rgba
    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);
#endif
    
#ifdef TEXTURE_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;
    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);
#endif
    
#ifdef TEXTURE_luminance
    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);
#endif
    
#ifdef TEXTURE_luminance_alpha
    vec4 textureColor = texture2D(uSampler, vTexcoord);
    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;
    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);
#endif
    
    fragColor = textureColor;

#elif defined(IS_TEXT)
    if (textureColor.a < 0.1)
      discard;
    else
      fragColor = textureColor;
#else
    fragColor = lighteffect;
#endif // HAS_TEXTURE
    
#ifdef HAS_FOG
    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))
    // In Exp and Exp2: use density = density/far
    // fogF will be the proportion of fog
    // Initialize it to the linear value
    float fogF;
    if (uFogMode > 0) {
      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);
      if (uFogMode > 1)
        fogF = mix(uFogParms.w, 1.0, fogF);
      fogF = fogF*uFogParms.z;
      if (uFogMode == 2)
        fogF = 1.0 - exp(-fogF);
      // Docs are wrong: use (density*c)^2, not density*c^2
      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58
      else if (uFogMode == 3)
        fogF = 1.0 - exp(-fogF*fogF);
      fogF = clamp(fogF, 0.0, 1.0);
      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);
    } else gl_FragColor = fragColor;
#else
    gl_FragColor = fragColor;
#endif // HAS_FOG
    
}
</script><!--/html_preserve-->
<script>/* globals CanvasMatrix4: true */
/* globals WebGLFloatArray */
/* jshint eqeqeq: false */
/*
 * Copyright (C) 2009 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
 * cleaned up.
 */
/*
    CanvasMatrix4 class

    This class implements a 4x4 matrix. It has functions which
    duplicate the functionality of the OpenGL matrix stack and
    glut functions.

    IDL:

    [
        Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
        Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
        Constructor()                                   // create new CanvasMatrix4 with identity matrix
    ]
    interface CanvasMatrix4 {
        attribute float m11;
        attribute float m12;
        attribute float m13;
        attribute float m14;
        attribute float m21;
        attribute float m22;
        attribute float m23;
        attribute float m24;
        attribute float m31;
        attribute float m32;
        attribute float m33;
        attribute float m34;
        attribute float m41;
        attribute float m42;
        attribute float m43;
        attribute float m44;

        void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
        void load(in sequence<float> array);                // copy 16 floats into the matrix
        sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
        WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
        void makeIdentity();                                // replace the matrix with identity
        void transpose();                                   // replace the matrix with its transpose
        void invert();                                      // replace the matrix with its inverse

        void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
        void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
        void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
                    in float x, in float y, in float z);    // (angle is in degrees)
        void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
        void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
        void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
                   in float bottom, in float top,
                   in float near, in float far);
        void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
                     in float bottom, in float top,
                     in float near, in float far);
        void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
                         in float zNear, in float zFar);
        void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
                    in float ctrx, in float ctry, in float ctrz,    // values on the right
                    in float upx, in float upy, in float upz);
    }
*/

CanvasMatrix4 = function(m)
{
    if (typeof m == 'object') {
        if ("length" in m && m.length >= 16) {
            this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
            return;
        }
        else if (m instanceof CanvasMatrix4) {
            this.load(m);
            return;
        }
    }
    this.makeIdentity();
};

CanvasMatrix4.prototype.load = function()
{
    if (arguments.length == 1 && typeof arguments[0] == 'object') {
        var matrix = arguments[0];

        if ("length" in matrix && matrix.length == 16) {
            this.m11 = matrix[0];
            this.m12 = matrix[1];
            this.m13 = matrix[2];
            this.m14 = matrix[3];

            this.m21 = matrix[4];
            this.m22 = matrix[5];
            this.m23 = matrix[6];
            this.m24 = matrix[7];

            this.m31 = matrix[8];
            this.m32 = matrix[9];
            this.m33 = matrix[10];
            this.m34 = matrix[11];

            this.m41 = matrix[12];
            this.m42 = matrix[13];
            this.m43 = matrix[14];
            this.m44 = matrix[15];
            return;
        }

        if (arguments[0] instanceof CanvasMatrix4) {

            this.m11 = matrix.m11;
            this.m12 = matrix.m12;
            this.m13 = matrix.m13;
            this.m14 = matrix.m14;

            this.m21 = matrix.m21;
            this.m22 = matrix.m22;
            this.m23 = matrix.m23;
            this.m24 = matrix.m24;

            this.m31 = matrix.m31;
            this.m32 = matrix.m32;
            this.m33 = matrix.m33;
            this.m34 = matrix.m34;

            this.m41 = matrix.m41;
            this.m42 = matrix.m42;
            this.m43 = matrix.m43;
            this.m44 = matrix.m44;
            return;
        }
    }

    this.makeIdentity();
};

CanvasMatrix4.prototype.getAsArray = function()
{
    return [
        this.m11, this.m12, this.m13, this.m14,
        this.m21, this.m22, this.m23, this.m24,
        this.m31, this.m32, this.m33, this.m34,
        this.m41, this.m42, this.m43, this.m44
    ];
};

CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
    return new WebGLFloatArray(this.getAsArray());
};

CanvasMatrix4.prototype.makeIdentity = function()
{
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;

    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;

    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;

    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
};

CanvasMatrix4.prototype.transpose = function()
{
    var tmp = this.m12;
    this.m12 = this.m21;
    this.m21 = tmp;

    tmp = this.m13;
    this.m13 = this.m31;
    this.m31 = tmp;

    tmp = this.m14;
    this.m14 = this.m41;
    this.m41 = tmp;

    tmp = this.m23;
    this.m23 = this.m32;
    this.m32 = tmp;

    tmp = this.m24;
    this.m24 = this.m42;
    this.m42 = tmp;

    tmp = this.m34;
    this.m34 = this.m43;
    this.m43 = tmp;
};

CanvasMatrix4.prototype.invert = function()
{
    // Calculate the 4x4 determinant
    // If the determinant is zero,
    // then the inverse matrix is not unique.
    var det = this._determinant4x4();

    if (Math.abs(det) < 1e-8)
        return null;

    this._makeAdjoint();

    // Scale the adjoint matrix to get the inverse
    this.m11 /= det;
    this.m12 /= det;
    this.m13 /= det;
    this.m14 /= det;

    this.m21 /= det;
    this.m22 /= det;
    this.m23 /= det;
    this.m24 /= det;

    this.m31 /= det;
    this.m32 /= det;
    this.m33 /= det;
    this.m34 /= det;

    this.m41 /= det;
    this.m42 /= det;
    this.m43 /= det;
    this.m44 /= det;
};

CanvasMatrix4.prototype.translate = function(x,y,z)
{
    if (x === undefined)
        x = 0;
    if (y === undefined)
        y = 0;
    if (z === undefined)
        z = 0;

    var matrix = new CanvasMatrix4();
    matrix.m41 = x;
    matrix.m42 = y;
    matrix.m43 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.scale = function(x,y,z)
{
    if (x === undefined)
        x = 1;
    if (z === undefined) {
        if (y === undefined) {
            y = x;
            z = x;
        }
        else
            z = 1;
    }
    else if (y === undefined)
        y = x;

    var matrix = new CanvasMatrix4();
    matrix.m11 = x;
    matrix.m22 = y;
    matrix.m33 = z;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
    // angles are in degrees. Switch to radians
    angle = angle / 180 * Math.PI;

    angle /= 2;
    var sinA = Math.sin(angle);
    var cosA = Math.cos(angle);
    var sinA2 = sinA * sinA;

    // normalize
    var length = Math.sqrt(x * x + y * y + z * z);
    if (length === 0) {
        // bad vector, just use something reasonable
        x = 0;
        y = 0;
        z = 1;
    } else if (length != 1) {
        x /= length;
        y /= length;
        z /= length;
    }

    var mat = new CanvasMatrix4();

    // optimize case where axis is along major axis
    if (x == 1 && y === 0 && z === 0) {
        mat.m11 = 1;
        mat.m12 = 0;
        mat.m13 = 0;
        mat.m21 = 0;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 2 * sinA * cosA;
        mat.m31 = 0;
        mat.m32 = -2 * sinA * cosA;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y == 1 && z === 0) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 0;
        mat.m13 = -2 * sinA * cosA;
        mat.m21 = 0;
        mat.m22 = 1;
        mat.m23 = 0;
        mat.m31 = 2 * sinA * cosA;
        mat.m32 = 0;
        mat.m33 = 1 - 2 * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else if (x === 0 && y === 0 && z == 1) {
        mat.m11 = 1 - 2 * sinA2;
        mat.m12 = 2 * sinA * cosA;
        mat.m13 = 0;
        mat.m21 = -2 * sinA * cosA;
        mat.m22 = 1 - 2 * sinA2;
        mat.m23 = 0;
        mat.m31 = 0;
        mat.m32 = 0;
        mat.m33 = 1;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    } else {
        var x2 = x*x;
        var y2 = y*y;
        var z2 = z*z;

        mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
        mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
        mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
        mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
        mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
        mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
        mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
        mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
        mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
        mat.m14 = mat.m24 = mat.m34 = 0;
        mat.m41 = mat.m42 = mat.m43 = 0;
        mat.m44 = 1;
    }
    this.multRight(mat);
};

CanvasMatrix4.prototype.multRight = function(mat)
{
    var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
               this.m13 * mat.m31 + this.m14 * mat.m41);
    var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
               this.m13 * mat.m32 + this.m14 * mat.m42);
    var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
               this.m13 * mat.m33 + this.m14 * mat.m43);
    var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
               this.m13 * mat.m34 + this.m14 * mat.m44);

    var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
               this.m23 * mat.m31 + this.m24 * mat.m41);
    var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
               this.m23 * mat.m32 + this.m24 * mat.m42);
    var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
               this.m23 * mat.m33 + this.m24 * mat.m43);
    var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
               this.m23 * mat.m34 + this.m24 * mat.m44);

    var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
               this.m33 * mat.m31 + this.m34 * mat.m41);
    var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
               this.m33 * mat.m32 + this.m34 * mat.m42);
    var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
               this.m33 * mat.m33 + this.m34 * mat.m43);
    var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
               this.m33 * mat.m34 + this.m34 * mat.m44);

    var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
               this.m43 * mat.m31 + this.m44 * mat.m41);
    var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
               this.m43 * mat.m32 + this.m44 * mat.m42);
    var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
               this.m43 * mat.m33 + this.m44 * mat.m43);
    var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
               this.m43 * mat.m34 + this.m44 * mat.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.multLeft = function(mat)
{
    var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
               mat.m13 * this.m31 + mat.m14 * this.m41);
    var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
               mat.m13 * this.m32 + mat.m14 * this.m42);
    var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
               mat.m13 * this.m33 + mat.m14 * this.m43);
    var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
               mat.m13 * this.m34 + mat.m14 * this.m44);

    var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
               mat.m23 * this.m31 + mat.m24 * this.m41);
    var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
               mat.m23 * this.m32 + mat.m24 * this.m42);
    var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
               mat.m23 * this.m33 + mat.m24 * this.m43);
    var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
               mat.m23 * this.m34 + mat.m24 * this.m44);

    var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
               mat.m33 * this.m31 + mat.m34 * this.m41);
    var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
               mat.m33 * this.m32 + mat.m34 * this.m42);
    var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
               mat.m33 * this.m33 + mat.m34 * this.m43);
    var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
               mat.m33 * this.m34 + mat.m34 * this.m44);

    var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
               mat.m43 * this.m31 + mat.m44 * this.m41);
    var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
               mat.m43 * this.m32 + mat.m44 * this.m42);
    var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
               mat.m43 * this.m33 + mat.m44 * this.m43);
    var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
               mat.m43 * this.m34 + mat.m44 * this.m44);

    this.m11 = m11;
    this.m12 = m12;
    this.m13 = m13;
    this.m14 = m14;

    this.m21 = m21;
    this.m22 = m22;
    this.m23 = m23;
    this.m24 = m24;

    this.m31 = m31;
    this.m32 = m32;
    this.m33 = m33;
    this.m34 = m34;

    this.m41 = m41;
    this.m42 = m42;
    this.m43 = m43;
    this.m44 = m44;
};

CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
    var tx = (left + right) / (left - right);
    var ty = (top + bottom) / (bottom - top);
    var tz = (far + near) / (near - far);

    var matrix = new CanvasMatrix4();
    matrix.m11 = 2 / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;
    matrix.m21 = 0;
    matrix.m22 = 2 / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;
    matrix.m31 = 0;
    matrix.m32 = 0;
    matrix.m33 = -2 / (far - near);
    matrix.m34 = 0;
    matrix.m41 = tx;
    matrix.m42 = ty;
    matrix.m43 = tz;
    matrix.m44 = 1;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
    var matrix = new CanvasMatrix4();
    var A = (right + left) / (right - left);
    var B = (top + bottom) / (top - bottom);
    var C = -(far + near) / (far - near);
    var D = -(2 * far * near) / (far - near);

    matrix.m11 = (2 * near) / (right - left);
    matrix.m12 = 0;
    matrix.m13 = 0;
    matrix.m14 = 0;

    matrix.m21 = 0;
    matrix.m22 = 2 * near / (top - bottom);
    matrix.m23 = 0;
    matrix.m24 = 0;

    matrix.m31 = A;
    matrix.m32 = B;
    matrix.m33 = C;
    matrix.m34 = -1;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = D;
    matrix.m44 = 0;

    this.multRight(matrix);
};

CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
    var top = Math.tan(fovy * Math.PI / 360) * zNear;
    var bottom = -top;
    var left = aspect * bottom;
    var right = aspect * top;
    this.frustum(left, right, bottom, top, zNear, zFar);
};

CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
    var matrix = new CanvasMatrix4(),
        xx, xy, xz;

    // Make rotation matrix

    // Z vector
    var zx = eyex - centerx;
    var zy = eyey - centery;
    var zz = eyez - centerz;
    var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
    if (mag) {
        zx /= mag;
        zy /= mag;
        zz /= mag;
    }

    // Y vector
    var yx = upx;
    var yy = upy;
    var yz = upz;

    // X vector = Y cross Z
    xx =  yy * zz - yz * zy;
    xy = -yx * zz + yz * zx;
    xz =  yx * zy - yy * zx;

    // Recompute Y = Z cross X
    yx = zy * xz - zz * xy;
    yy = -zx * xz + zz * xx;
    yx = zx * xy - zy * xx;

    // cross product gives area of parallelogram, which is < 1.0 for
    // non-perpendicular unit-length vectors; so normalize x, y here

    mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
    if (mag) {
        xx /= mag;
        xy /= mag;
        xz /= mag;
    }

    mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
    if (mag) {
        yx /= mag;
        yy /= mag;
        yz /= mag;
    }

    matrix.m11 = xx;
    matrix.m12 = xy;
    matrix.m13 = xz;
    matrix.m14 = 0;

    matrix.m21 = yx;
    matrix.m22 = yy;
    matrix.m23 = yz;
    matrix.m24 = 0;

    matrix.m31 = zx;
    matrix.m32 = zy;
    matrix.m33 = zz;
    matrix.m34 = 0;

    matrix.m41 = 0;
    matrix.m42 = 0;
    matrix.m43 = 0;
    matrix.m44 = 1;
    matrix.translate(-eyex, -eyey, -eyez);

    this.multRight(matrix);
};

// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
    return a * d - b * c;
};

CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
    return a1 * this._determinant2x2(b2, b3, c2, c3) -
         b1 * this._determinant2x2(a2, a3, c2, c3) +
         c1 * this._determinant2x2(a2, a3, b2, b3);
};

CanvasMatrix4.prototype._determinant4x4 = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
         b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
         c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
         d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

CanvasMatrix4.prototype._makeAdjoint = function()
{
    var a1 = this.m11;
    var b1 = this.m12;
    var c1 = this.m13;
    var d1 = this.m14;

    var a2 = this.m21;
    var b2 = this.m22;
    var c2 = this.m23;
    var d2 = this.m24;

    var a3 = this.m31;
    var b3 = this.m32;
    var c3 = this.m33;
    var d3 = this.m34;

    var a4 = this.m41;
    var b4 = this.m42;
    var c4 = this.m43;
    var d4 = this.m44;

    // Row column labeling reversed since we transpose rows & columns
    this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to neurons and
neuronlists</h1>
<h4 class="author">Gregory Jefferis</h4>
<h4 class="date">2023-01-28</h4>



<div id="preface" class="section level2">
<h2>Preface</h2>
<p>This vignette is designed to give you a good introduction to some of
the key features of nat by teaching you about how it handles individual
neurons and collections of neurons.</p>
<p>The source code for this vignette is available at <a href="https://github.com/natverse/nat/blob/master/vignettes/neurons-intro.Rmd" class="uri">https://github.com/natverse/nat/blob/master/vignettes/neurons-intro.Rmd</a>.
If you find something unclear or notice a typo, I would be very happy if
you would click on the Pencil Icon on that page or follow <a href="https://github.com/natverse/nat/edit/master/vignettes/neurons-intro.Rmd">this
link to edit</a> and suggest an alternative wording. Dont be shy about
doing this; I have to review any change and even if your suggestion is
not perfect it will still be a prompt for me to improve this document.
Thank you!</p>
</div>
<div id="startup" class="section level2">
<h2>Startup</h2>
<p>Install the package if required</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&#39;nat&#39;</span>, <span class="at">dependencies =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Load the package</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(nat)</span></code></pre></div>
</div>
<div id="neurons-and-neuronlists" class="section level2">
<h2>Neurons and Neuronlists</h2>
<p>There are a number of basic built in types of data in R such as
vectors and matrices, but it is also very easy to define new data types
with specialised features to enable powerful and efficient analysis of
particular kinds of data. These specialised data types are called
<em>classes</em> and a specific instance of a class is an
<em>object</em> (a neuroscience analogy: this is the difference between
talking about the general class of mitral cells and the specific cell
that you just sealed onto with your patch clamp electrode.)</p>
<p>We will look at two key classes that <strong>nat</strong> defines for
handling 3D structures of neurons</p>
<ul>
<li><code>neuron</code></li>
<li><code>neuronlist</code></li>
</ul>
<div id="sample-data" class="section level3">
<h3>Sample Data</h3>
<p>As an example were going to look at a data set of olfactory
projection neurons originally published as Supplemental Information to
accompany <a href="http://dx.doi.org/10.1016/j.cell.2007.01.040">Jefferis, Potter et
al, Cell (2007)</a>. A subset of the original data are distributed as a
sample data object with the <strong>nat</strong> package, which we can
load like so.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">&quot;Cell07PNs&quot;</span>)</span></code></pre></div>
<p>For more information about these data see <a href="http://natverse.org/nat/reference/Cell07PNs.html">Cell07PNs</a>.</p>
<p>This <code>Cell07PNs</code> object has two classes
<code>neuronlist</code> and the base class <code>list</code></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(Cell07PNs)</span></code></pre></div>
<pre><code>## [1] &quot;neuronlist&quot; &quot;list&quot;</code></pre>
<p>Many R objects inherit from the base class <code>list</code> (objects
can have multiple classes in the same way that a mitral cell is also
neuron) because this is a convenient container class into which you can
put a variety of different kinds of data. In this case the
<code>Cell07PNs</code> <code>neuronlist</code> contains 40 objects:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span>(Cell07PNs)</span></code></pre></div>
<pre><code>## [1] 40</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># access the first neuron in the neuronlist</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">class</span>(Cell07PNs[[<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [1] &quot;neuron&quot; &quot;list&quot;</code></pre>
<p>each representing a traced neuron. We will now look in detail at
these two classes.</p>
</div>
</div>
<div id="neurons" class="section level2">
<h2>Neurons</h2>
<p>We start by extracting the first neuron in Cell07PNs, and assigning
it to a variable. We can then plot the neuron so that we have an image
of what we are talking about.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>n1<span class="ot">=</span>Cell07PNs[[<span class="dv">1</span>]]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAEgCAYAAABsPKAhAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAeCgAwAEAAAAAQAAASAAAAAATIqLkQAAQABJREFUeAHtnQeAE8X3x7+5Qu9NuqICSpMiRYqIYkFERRTEBiooFkQUBQsiYBdFFLF3iigiCD/FAiqISBEERQSkiCK9H3BwZf7vDSb/3F3uLgl3l+zmOxgvuzs7O+8zm307M++98RhJYCIBEiABEiABEihQAnEFejVejARIgARIgARIwBKgAuaNQAIkQAIkQAIRIEAFHAHovCQJkAAJkAAJUAHzHiABEiABEiCBCBCgAo4AdF6SBEiABEiABKiAeQ+QAAmQAAmQQAQIUAFHADovSQIkQAIkQAJUwLwHSIAESIAESCACBKiAIwCdlyQBEiABEiABKmDeAyRAAiRAAiQQAQJUwBGAzkuSAAmQAAmQABUw7wESIAESIAESiAABKuAIQOclSYAESIAESIAKmPcACZAACZAACUSAABVwBKDzkiRAAiRAAiRABcx7gARIgARIgAQiQIAKOALQeUkSIAESIAESoALmPUACJEACJEACESBABRwB6LwkCZAACZAACVAB8x4gARIgARIggQgQoAKOAHRekgRIgARIgASogHkPkAAJkAAJkEAECFABRwA6L0kCJEACJEACVMC8B0iABEiABEggAgSogCMAnZckARIgARIgASpg3gMkQAIkQAIkEAECVMARgM5LkgAJkAAJkAAVMO8BEiABEiABEogAASrgCEDnJUmABEiABEiACpj3AAmQAAmQAAlEgAAVcASg85IkQAIkQAIkQAXMe4AESIAESIAEIkAgIQLX5CVJIOYJPP/885g5c2auHC677DIMGDDA5hs9ejRmzJiR5ZyEhAQUK1YM9erVw4033ojatWv78uzZswfdunWz2+3a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" /><!-- --></p>
<div id="neuron-internal-structure" class="section level3">
<h3>Neuron internal structure</h3>
<p>The <code>str</code> function (short for structure) allows us to take
a look at the internal structure of this neuron object.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use =1 so that we don&#39;t show complete structure</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># for objects inside n1</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(n1, <span class="at">max.level=</span><span class="dv">1</span>)</span></code></pre></div>
<pre><code>## List of 24
##  $ CellType     : chr &quot;DA1&quot;
##  $ NeuronName   : chr &quot;EBH11R&quot;
##  $ InputFileName: &#39;AsIs&#39; chr &quot;/GD/projects/PN2/TransformedTraces/DA1/EBH11R.tasc&quot;
##  $ CreatedAt    : POSIXt[1:1], format: &quot;2006-01-17 15:21:14&quot;
##  $ NodeName     : Named chr &quot;jefferis.joh.cam.ac.uk&quot;
##   ..- attr(*, &quot;names&quot;)= chr &quot;nodename&quot;
##  $ InputFileStat:&#39;data.frame&#39;:   1 obs. of  10 variables:
##  $ InputFileMD5 : Named chr &quot;fcacee3f874cbe2c6ad96214e6fee337&quot;
##   ..- attr(*, &quot;names&quot;)= &#39;AsIs&#39; chr &quot;/GD/projects/PN2/TransformedTraces/DA1/EBH11R.tasc&quot;
##  $ NumPoints    : int 180
##  $ StartPoint   : num 1
##  $ BranchPoints : num [1:16] 34 48 51 75 78 95 98 99 108 109 ...
##  $ EndPoints    : num [1:18] 1 42 59 62 80 85 96 100 102 112 ...
##  $ NumSegs      : int 33
##  $ SegList      :List of 33
##  $ d            :&#39;data.frame&#39;:   180 obs. of  7 variables:
##  $ OrientInfo   :List of 5
##  $ SegOrders    : num [1:33] 1 2 2 3 4 4 3 4 5 5 ...
##  $ MBPoints     : int [1:2] 34 48
##  $ LHBranchPoint: int 75
##  $ SegTypes     : num [1:33] 1 3 1 3 3 3 1 2 2 2 ...
##  $ AxonSegNos   :List of 3
##  $ LHSegNos     : num [1:26] 8 9 10 11 12 13 14 15 16 17 ...
##  $ MBSegNos     :List of 2
##  $ NumMBBranches: num 2
##  $ AxonLHEP     : num 72
##  - attr(*, &quot;class&quot;)= chr [1:2] &quot;neuron&quot; &quot;list&quot;</code></pre>
<p>From this you can see that there are a large number of fields inside
the neuron. Each field can be accessed using the <code>$</code> or
<code>[[</code> operators</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>n1<span class="sc">$</span>NumPoints</span></code></pre></div>
<pre><code>## [1] 180</code></pre>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>n1[[<span class="st">&quot;NumPoints&quot;</span>]]</span></code></pre></div>
<pre><code>## [1] 180</code></pre>
<p>There are a set of core fields (described in <code>?neuron</code>
documentation); the key ones will be described shortly. However there
are also quite a few user fields in this neuron and you can safely add
any field you like so long as its name does not clash with an existing
field. For example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>n1<span class="sc">$</span>Comment<span class="ot">=</span><span class="st">&#39;The sex of this specimen is uncertain&#39;</span></span></code></pre></div>
<p>The single most important field in a neuron is the <code>$d</code>
<code>data.frame</code>. This contains a block of data closely
reminiscent of the SWC data format for traced neurons:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(n1<span class="sc">$</span>d)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    180 obs. of  7 variables:
##  $ PointNo: int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Label  : num  2 2 2 2 2 2 2 2 2 2 ...
##  $ X      : num  187 187 188 188 188 ...
##  $ Y      : num  133 131 130 129 129 ...
##  $ Z      : num  88.2 90.6 93.1 95 97.5 ...
##  $ W      : num  1.01 1.27 1.14 1.27 1.27 1.27 1.27 1.27 1.27 1.27 ...
##  $ Parent : num  -1 1 2 3 4 5 6 7 8 9 ...</code></pre>
<p>Each row defines a node in a branched tree with a unique integer
identifier, <code>PointNo</code>, normally but not always sequentially
numbered from 1. The <code>X,Y,Z</code> columns encode the position of
each vertex and the <code>W</code> column encodes the diameter of the
neurite at that position.</p>
</div>
<div id="methods-for-neurons" class="section level3">
<h3>Methods for neurons</h3>
<p>Rs simple <a href="http://adv-r.had.co.nz/OO-essentials.html">S3
object oriented system</a> allows specialised functions for particular
classes to be defined. These functions tailored to a particular class
are called <em>methods</em>. Methods can be provided for pre-existing
functions supplied with base R as well as new user-written functions.
The system is quite simple. If a function <code>foo</code> is defined as
a <em>generic</em> function then you can define new functions called
<code>foo.bar</code> that will be called when you write
<code>foo(x)</code> and <code>x</code> has class `bar.</p>
<p>We already used one such method without comment,
<code>plot.neuron</code>. There is a base R function called
<code>plot</code>. nat defines a new function called
<code>plot.neuron</code>, which R interprets as a <code>plot</code>
method specialised for <code>neuron</code> objects. When the base R
<code>plot</code> function is called, it looks at the class of its first
object to see whether a specialised method exists. If there is none, it
will use a fallback method called <code>plot.default</code>.</p>
<p>The <code>plot.neuron</code> method interprets the branching
structure of a neuron and draws line segments joining up the connected
nodes at the appropriate 2D positions. You can compare it with what you
would get if you just plotted the XY position of all nodes joined
together by a single line:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1<span class="sc">$</span>d<span class="sc">$</span>X, n1<span class="sc">$</span>d<span class="sc">$</span>Y, <span class="at">type =</span> <span class="st">&#39;l&#39;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAEgCAYAAABsPKAhAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAeCgAwAEAAAAAQAAASAAAAAATIqLkQAAQABJREFUeAHtnQe8FOXVhw+IgorYIiIWsCCKGtRYUGzYsKCCRlBAwILyqVgQQz4UFSVExRYQQSHYwIJoSFQEsVeChWILIlIEG58NC8Y23/u8yay7e/fu7i17Z2f3f36/vXd25p32zOycec97Sr3AiUlEQAREQAREQATqlED9Ot2bdiYCIiACIiACIuAJSAHrRhABERABERCBCAhIAUcAXbsUAREQAREQASlg3QMiIAIiIAIiEAEBKeAIoGuXIiACIiACIiAFrHtABERABERABCIgIAUcAXTtUgREQAREQASkgHUPiIAIiIAIiEAEBKSAI4CuXYqACIiACIiAFLDuAREQAREQARGIgIAUcATQtUsREAEREAERkALWPSACIiACIiACERCQAo4AunYpAiIgAiIgAlLAugdEQAREQAREIAICUsARQNcuRUAEREAEREAKWPeACIiACIiACERAQAo4AujapQiIgAiIgAhIAeseEAEREAEREIEICEgBRwBduxQBERABERABKWDdAyIgAiIgAiIQAQEp4Aiga5ciIAIiIAIiIAWse0AEREAEREAEIiAgBRwBdO1SBERABERABKSAdQ+IgAiIgAiIQAQEpIAjgK5dioAIiIAIiIAUsO4BERABERABEYiAgBRwBNC1SxEQAREQARGQAtY9IAIiIAIiIAIREJACjgC6dikCIiACIiACUsC6B0RABERABEQgAgJSwBFA1y5FQAREQAREQApY94AIiIAIiIAIREBACjgC6NqlCIiACIiACEgB6x4QAREQAREQgQgISAFHAF27FAEREAEREAEpYN0DIiACIiACIhABASngCKBrlyIgAiIgAiIgBax7QAREQAREQAQiICAFHAF07VIEREAEREAEpIB1D4iACIiACIhABASkgCOArl2KgAiIgAiIgBSw7gEREAEREAERiICAFHAE0LVLERABERABEZAC1j0gAiIgAiIgAhEQkAKOALp2KQIiIAIiIAJSwLoHREAEREAERCACAlLAEUDXLkVABERABERAClj3gAiIgAiIgAhEQEAKOALo2qUIiIAIiIAISAHrHhABERABERCBCAhIAUcAXbsUAREQAREQASlg3QMiIAIiIAIiEAEBKeAIoGuXIiACIiACIiAFrHtABERABERABCIgIAUcAXTtUgREQAREQASkgHUPiIAIiIAIiEAEBKSAI4CuXYqACIiACIiAFLDuAREQAREQARGIgIAUcATQtUsREAEREAERkALWPSACIiACIiACERCQAo4AunYpAiIgAiIgAlLAugdEQAREQAREIAICUsARQNcuRUAEREAEREAKWPeACIiACIiACERAQAo4AujapQiIgAiIgAhIAeseEAEREAEREIEICEgBRwBduxQBERABERABKWDdAyIgAiIgAiIQAQEp4Aiga5ciIAIiIAIiIAWse0AEREAEREAEIiAgBRwBdO1SBERABERABKSAdQ+IgAiIgAiIQAQEpIAjgK5dioAIiIAIiIAUsO4BERABERABEYiAgBRwBNC1SxEQAREQARGIvQIOgsBWrlxpn3/+ua6mCIiACIiACMSGQCwV8IoVK2zQoEHWsmVLW2uttaxp06a28cYb2/rrr29t27a1iy66yL755pvYXAQdqAiIgAiIQPkRqOd6kEGcTnvp0qW23377Wb169ezEE0+0bbbZxjbaaCP/nV7w4sWLbcqUKcZpPfnkk7btttsW5PRGjhxpY8aM8Uq/IDvQRkVABERABKpNoFGjRvbwww/beuutV+1tFHrF2Cngc8891+bNm2dPPPGENWzYMCOfH3/80Y488khr3769DR06NGObms7cc889bdiwYVLANQWp9UVABESgAAQ6dOhgs2bN8lbRAmy+VjbZoFa2UocbmTt3rvXu3btS5cuhrLnmmtanTx8bNWpUwRRwgwYNrEmTJtauXbs6PHvtSgREQAREIB8C22+/fT7NIm0TuzHgfffd11588cWc0J566inbfPPNc7ZTAxEQAREQARGIgkDsesDdu3c3lPAnn3xiPXr08GO8OGDVr1/fe0IvWbLEJk2aZNOmTfNm6iigVrZPjpmeM8crEQEREAERKG8CsVPAu+66q82fP9/OOussb4r+5ZdfKlzBQw891B5//HE78MADKyyLcsbHH39snTp1MhzJeGGQiIAIiIAIlC+B2ClgLtV2223nPZx/+OEHW7ZsmdHrxfGqefPmtsUWWxRtD5MQKczi9M5RxBIREAEREIHyJRBLBRxeLmKAUcZ8kJ9//tnoZRaz9OvXzy644AIp4GK+SDo2ERABEagDArG0g6JkQw/nf/3rXx7T5Zdfbs2aNfM9YHrCf//73+sAX9V3wbj1okWLfHxa1dfWGiIgAiIgAqVCIHYKGOVLfO+AAQPs2muv9Q5Z48aN89MdO3a0m266yZt5TzjhBHv11VeL7joRIvX6669b3759bezYsUV3fDogERABERCBuiEQOxP09ddf7+NvcWQiEcd5551nZ555pl122WWJmN/zzz/f9tlnHxsxYoTdf//9VSLJWPLq1atzrsP4M22rI7vttpu99NJL3oOblJkDBw6szma0jgiIgAiIQIwJxE4Bz5492yfZwMyMDB482O655x7r1q1bymUgWcctt9ySMi+fL5MnT7azzz47Z9NVq1bZjBkz7IADDsjZNlMDUmh++OGHRrA4Wbt22mmnTM00TwREQAREoEQJxM4EjScxqShDQXHR06UQQ7LMmTPHF2lInpfPNGO0X331Vc5P48aNfTGIfLZZWZvNNtvMJkyYYKeeemplTTRfBERABESgRAnETgHT0504caJXWh988IG/LJhww6xXy5cvt/79+9sdd9xhJO0odlmwYIHSWRb7RdLxiYAIiEABCMROAeOAhZkYU/TChQsrICEL1ujRo70SjkPP8h//+IedfPLJFc5DM0RABERABEqbQOzGgLkcnTt3tmOOOcbH/aZfnp49e/oMWYQkxUF++umnrIUl4nAOOkYREAEREIGqE4ilAuY011hjDf9JP+XQFJ0+vxi/kzjkiy++8Nm8qFnZqlWrYjxMHZMIiIAIiEABCMTOBF0ABpFtkpeIW2+91Xr16uW9ocld/f3330d2PNqxCIiACIhA3RGQAq471hn3dPjhhxshTRSVILQKJzN6xhIREAEREIHSJhA7BbzHHnvYOuusk9eH8eC4SL169bx3N6FJJBKRiIAIiIAIlDaB2I0B33jjjUaaSTJRXXrppVnL+pHkIk5CT/iRRx7x1ZLidNw6VhEQAREQgaoTiJ0C3n///e2FF14w6gJjqi2lNI5NmjSxL7/80lq0aFH1K6k1REAEREAEYkUgdiZo6NKzveqqq2zYsGH22WefxQp4toPFKWvPPfe0WbNmZWumZSIgAiIgAiVAIJYKGO7U1CWJRSk5LAVBYK1bt7aHHnrIO2WVwP2lUxABERABEaiEQGwVML3FDh06VCvfcyUsIp+NI9bNN99sH330kXXt2rWkXi4ih6sDEAEREIEiIxBbBVxkHGvtcBo0aOB7wMQDDx8+vNa2qw2JgAiIgAgUFwEp4OK6Hv5oUMJTpkyxxx9/3Oe0LsJD1CGJgAiIgAjUkIAUcA0BFmr1Ro0a2dNPP20vv/yyPfDAA4XajbYrAiIgAiIQEQEp4IjA57NbesJkxpo5c2Y+zdVGBERABEQgRgQyKuA33njDvvvuuxidRuke6imnnGIPPvigUTVJIgIiIAIiUDoEMipgxh533313X3O3dE41nmdCWcUNN9zQFi1aFM8T0FGLgAiIgAhkJJBRAR955JG21lprWfv27e2KK65Q7ysjurqbucsuuxhWCYkIiIAIiEDpEMiogNu0aWOvvvqqDR482IfC7LvvvrZgwYLSOeuYnYkUcMwumA5XBERABPIgkFEBsx494KFDh9orr7ziN7Pbbrv5JBFka5LULYG9997be0PX7V61NxEQAREQgUISqFQBhztt27atz008YMAAH5PasGFDr5xR0OEnbKv/hSGw3377eQVMBSiJCIiACIhAaRDIWQ0J79uRI0f6D7Vqe/ToYaRMLFV54oknjJKHuWT16tX28ccf52pWK8vXX399nyN69uzZhjKWiIAIiIAIxJ9AVgU8b948O/XUU23OnDle8aKIN9poo/ifdZYz2GGHHeycc87J0uI/i5566imjfGBdCXmvScwhBVxXxLUfERABESgsgYwKGFMn5f6uvvpq+81vfmNTp0614447rrBHUiRb32KLLYxPLiFJxjrrrJOrWa0tRwFfd911NmTIkFrbpjYkAiIgAiIQHYGMY8CjR4/2tXapyPPWW2+VjfKN7jLk3vMBBxzgLRFffPFF7sZqIQIiIAIiUPQEMirgTTbZxFfkmTRpUsmbnIv+Cv33ABs3bmydO3e2v/71r3E5ZB2nCIiACIhAFgIZFXDPnj2tS5cula72ySefGOXyJHVL4IwzzrDx48fX7U61NxEQAREQgYIQyKiA2dMHH3xgPPC//fbbxI6ff/5523bbbY30iPTIunfvbjKJJvAUfILMZMiLL75Y8H1pByIgAiIgAoUlkFEBv/7669aqVSvvdfvVV1/5I/j888/thBNO8Ip3zJgxNnDgQHvyySe9ki7sIWrryQTOPPNMu+2225JnaVoEREAERCCGBDJ6QU+YMMEOPPBAmz59eiLm96GHHjKU8DPPPGOkqkRIUYl39GeffWYbb7xxDE8/fofcq1cv22677YwXI+KDJSIgAiIgAvEkUEEB07tFAaNQST8ZyooVK2zNNdf0ZudwXvgfRUzvePjw4eEs/S8QAcLCSIZy4YUX+utUoN1osyIgAiIgAgUmUEEB9+vXz/dySbhx8803+91/9NFHRoKKv/zlL3b66acnDumFF14w4lMpX7jlllsm5muisARGjBhhpAjFKnH88ccXdmfaugiIgAiIQEEIVFDApJmkCDw92k033dSoxDNq1CirX7++nXTSSbbGGmvYv//9b3vsscd8taRdd93VWrRoUZCD00YzEyABCCFivPy0a9fOmjdvnrmh5oqACIiACBQtgQoKmCOlHnD//v3tT3/6k68FjNfzo48+mki9+OCDD3ozaMuWLe2RRx6J9OSozvR///d//sWg1NNkJoPea6+97IILLrCDDz7YXnvtNVt33XWTF2taBERABESgyAlk9IKml0vaw6+//toWL15smKD333//xKkceuih9tJLL9miRYtsm222ScyvqwnGowcNGmS8AFCRqWnTpn7MGqckTLMXXXSRffPNN3V1OJHthxckQpMOOeQQhYNFdhW0YxEQARGoHoGMPeBwU40aNfJKLvwe/kfh8YlCli5d6gsSYCo/8cQT/QsAPV++46XNC8OUKVOMXjphUsQtl7KQGYuXERQxlZxkji7lq61zEwERKCUCGRXw5MmTbezYsXmfJ5WB6kpwQGrper4oG2oTZxK8sTGj33XXXTZ06NBMTUpq3jXXXOOLZqCEZ86c6cOUSuoEdTIiIAJ1RkDOnXWG2jKaoHHywQEr/KxcudIn5WC8tXXr1j7+9NVXX/Xz8qkcVJunM3fuXCMWtjLly74Il+rTp4+PY67NfRfzti6++GK79NJLjaIN//rXv4r5UHVsIiACRUqAZ/2AAQPyKslapKcQq8PK2APu1KmT8UEY/8UTeuLEid7xKjy7H3/80V+kt99+O5xVJ/+JOSYVY9++fbPuj1755ptvnrVNqS0kRGzDDTf03tFkyzrmmGNK7RR1PiIgAgUkcP7559sRRxxh99xzjy9Hu9566xVwb9p0RgWcjGXGjBnevEne52Shl3nJJZd4c/DHH3/s80MnLy/UNMeBEqYgBAkpGOMlaQhhUowBL1myxIfoTJs2zZupC3Ucxbpd4oIZEyeP99133+1DyLBkSERABEQgF4E999zT3n33XTvssMP8EN4555yTaxUtrwGBjCbo5O01adLEPvzwQ/vyyy+TZ/vpWbNm2dprr12nKRGJO54/f7798MMP1rt3b6+MMYuTu3rvvfe2bt262XfffeeTg5BOsxzloIMO8nWcSVm58847e6e0VatWlSMKnbMIiEAVCJDr4b777jNyzt9yyy1VWLOwTelYlaLkVMC8Cf38888+A9Ybb7zhyxBSAYn4X7xvMVWjhOtSUCx4OK9evdoWLlzoHY/o8TI+TEwwjkgkqShnYYwcZzQ43XjjjbbZZpsZLy/Ed5NqlGsqEQEREIFkAjwnMEG/9dZbfja5//MRwj/vv//+fJpWqQ3PeDpaZauAGQMg5SQVkn772996ZYuJk/FFkkHceeedVQJam42JAUYZE5eM1zM3gYpCpBLmmnH9KN5w6623+qxlU6dOtT322MNf09TW+iYCIlDuBBgHxocE8/Po0aPzwkHehWuvvTavtvk2oiQuVs1ffvnFO5fmu16c2uXsAXMyFGVYsGCBvfLKK0bcKTG2xOMSrlTXvd84wS2WYyVGukGDBv5mpozkP/7xD+/pyEsL3tOY7CUiIAIiAAGUHhXu6NgQ7skQZDbBH4f2y5Yts/feey9b07yXjR8/3ncS/ud//sf7suDjU4qS91lh0qTXdNppp/mkD1El4ijFixDFOZHvGzMTXu477bRTWTqsRcFd+xSBYifACztlZh9++GHv6IrlLJu8/PLLvnwtuqEmtcp/+ukn70C7++67e8sq6Y9RwKUslXpB0/0niQUVkMI8w88//7yPr33//fd97uWuXbt6EwWhL3UlvATkG/qERzDhU1URzo0bKpcQhhX3dJeUNoQP1azwmmaM+IEHHvBx1LnOX8tFQARKlwCOnChgcgvQE+Y/kS/pgi8JChvfGxy3GBKkkA/DgWRSzCbklcA5FAdfrKr4quBMe+WVVybCYLOtXwrLMipgxnsJ9SGOlrFDFDAhPoBlkJ6awQyK33777f7BDby6Ei4Sx4EXNDdFNtPE9ttvX+XDWr58ua/0lGtFbrxSMd0efvjhvjdMiBfFHciEs8kmm+RCoOVZCBCHTrEMPPYlIhA3Avj+8Oxv06aNT770t7/9zTu2EqKE4yvDkeiJN9980+sJdAIhoaeeeqrP0UAb6gTQm0VnkLAJ/xxqCJDEiY4OzrzoFuZj9v773//u28eNVU2ON6MCxkuWEJ7p06f7txt2wEMZJYxXHBcFQUljqsD+X1fOTxSFwKmI3hpKkDHN2hQySfHJJdwspWSG54fAOV122WX2u9/9znuSE94lqR4BnFd4WElEIG4EGPMdN26cLzvLsV9//fX+mYDzLZ0aasPz/CVkCf+gxo0bJ04R3YFgIcRSiYKmU4NC/uc//2nEGZ988sleh1A8h8I/ZS3ODJAiLvYrcI5VgXtjCZwZIfFx5srAmRQS38NlDl7gLkrwv//7vynbKfQXV60pcBc+cKaPQu8q4/bZtxvvyLgs7jNdMYvAvVwELtFK4H48cT+dOj9+V0UscOlc/afOd64dikA1CThzsH+O86x31pvA1X1PbMn1hhPTcZlwESCBC00t6sOt0APu16+f7+XytnPzzTf7lxMcdXjrYTyYdIeh0BMl3pYxxC233DKcXSf/Me9h3lA8a+3jxsTP9cb5gjSkxIITP8z4e65xndo/mvhtkXF0fheY2yQiUOwEvv/+e+/78Yc//CERA5xu3SMhk6T2CVRQwAyo4yHLQ5gUhjyAR40a5cdaMTlgMnBvRn6cdPDgwd4U0aJFi9o/shxb5DjKPdlGDkQ1Woxn9MiRI42aw3fccYd/8cITHjP11ltvXaNtl/rKVOHCe3P27Nmlfqo6v5gSIGkRQ4yEGeF0Sk4HkhlhUpbUHYGMYUjEh9Lj4eH7+9//3scA4xIevgXhdNWlSxefiYrau5LSJYAzBvcCFZZ44WrXrp0vhlG6Z1yzMyMWkoxxeJi3bNmyZhvT2iJQywTIjNexY0f//MaySdIN4niffvppKd9aZp3P5ir0gFmJ3qUbY7Vhw4YZhRbSHyS4pWNew3MtmxdyPgegNvEggGUECwjOdjje4Y2OpUSSSoDeL5woYsKLrEQEoiZAJikyFmLJxHpJ8h1+u2XvABX1hXH7z6iAw+NivC9d+bKM8YH0MYJwHf0vbQKMBzP2f9RRR3nvd8IO8GaU/IcACpjYauKqa5KUQDxFoKYE8D6eN2+ez3rHOC/FFfjd8jItKQ4CGU3QxXFomY8CRyDnYZrXp2fPnpk3ork1IoCDFuObBOoT30fIGnlgCTkoZ2EsjV4FDomEcmAhkohAXRKgt0v8LalnuQ8ploM/B0mD8N/IVNWuLo9P+0olkLUHnNq0OL4VOhFHcZxl8R8FY5x4vxPvx/gRPgLHHnuskU6Ot+yjjz7aDjnkEP+iVPxnUztHSO+3V69engXJTdTTqB2u2kp+BPjt8bvDIkWufrJR4UhJgh0ULy/JOFCSQIjf7RVXXGGXX355fhtXq8IQyBQk5ZyvfCww8cD5fDJto5DzXGEIf1xXX311IXeTddulHAec9cRzLHznnXcCF7gfuIxaPk7bPRACV7oycOFiOdaM92Jn4gtc6F7gUrgGzkExuPvuu+N9Qjr62BFwCXQC5zQZOEuMj+ElP4MrvJJyHk75BsT7ujzwgasVHriSpSnLS+lLHOKA6wE8XbWT2erEE0/0PRtKUmHSyCYDBgzItrggy8jOwhscKTHrKgtX8ongHXzDDTf4tGvJ8zX9KwGXkMJXXuItHGc+YswZGy3FNJdEA4wdO9aHduAfQfWwUjzPX6+upqIksHjxYm9dotdLLn6G5XgWuk6JzzjF/cdzETM0UQwMh6Q/x8nfTFTDkCFDfM3d6p4PKoTfOjkZ+ODo1axZs8idvLAAYJXif9FKZW88zkQR7LfffoGLDwvcRa6sWWTzOSaXbzdwLvSRHIN6wFXD7vLGBk75Bs48FrhUdMFzzz1XtQ0UeWtXHztwnqbBvffeG7gogSI/Wh1eXAmQmY57zeVX9tnq3DBH4HwyKjyj6em6GF86V94iQ2ZDp5ADLFKu2EHgho8CZ5YOXLpIP99FtVQZiQtNDFzyjqB58+a+573BBhv4bbkaAoHLDRG4DkoQZQatOPSAK3XCYhCf2r8kk3cPlaJ7gQgTccgbu+guTcYDIsCf/LKMTfHWTeUUZwLznplxryq1cuVKcy8UPnkN59i3b9+MDDRTBGpCgMx05GDGEXXFihU+fhenKxwh8Y1JFuq044NBXnvKBFLdjvh0Mhl+++23PscDxXaoGLfPPvv4vP5EN9CjziUUYSBRExWT8HPAB4SqRhRXoFeN9zUWIQo2EEVz3nnn+bKnubZblstzvfY4N/bAXbhczcpuuXrANb/k7ocbuKEO/yZPDnKsLnGUm266KXDOV4HLLBS4cmwpOXTjeD465uIjQO57erDpz2J6rtxzztQauGIHAb3SZHGxv/7eTJ4XTuOXwfOdnPZO+fkPPWosnxdddFEwefLkwCWW8c3di7Pv0TqFHtDDdWmJA/wecgk9duoE4B/hqtcFTvnnWqXWlsehB2y1drZltiEp4Nq74DxU3Nt64KovVXAaqb29FG5LrncfzJw5M3BjbIFLwFG4HWnLZUlg/PjxAQUSnB9Fyvk7r2avNF3lrcBFIASuHKA3TbtecoCDquslBy7bVYBpOLmwQspG/vsFkzXroIhdHHtw7rnnBi58KaGYme9yAASTJk3yTlyZtpFtHoq8d+/efgiK3/qIESPyUuDZtplrWRwUcF5hSGS9cm/53rRAHd50ob6jRASqSwBTNDlpH3vsMV9eEuc2PnHIS+u8Se3TTz815+ntTYOEH0lEoLYIEN5H3XNizMnNH8rQoUP9kA73m/Nktj/+8Y++oMKaa67ph0Puu+8+P8TTvn17X4/XvSD6ECXWxzGJIRPM2HwwGROahPOU6/ka+RNcL9j69Oljrnft18fBi9h/knkwxELtXxy7wg+xxtmyIuIMRk55agw/++yzdv/99/vShtdcc43PHBeeV7n9z+gFnQyBsQPgElvGWEGYDzq5jXtDS/5aFtPygi7MZcaLEt8D6hKHDxfGuIpVKLrA8RJXSb1sPFIlIlAbBFB4JNLg5Y5iCaFQNIF4X34X5GdnXHettdYKFyf+o1SpzHXhhRd6j3w8o53jqh8bJi0lXtGMA7MdPKZRpiSQQdEzdltZnn/GicmwRX3f8IMip9ZvqJD57xzFEseSaeL555/3KTF5aXDhiz55SKZ21Z0Xay/osHt/++23e7OBe7iEs/TfEZAJurC3ATV1GTNyCi1wb/fBmDFjAtdD9mNc+Yw9FfbogsA9qLxJzT0cAsaAnTNMoXep7ZcRAUzCrVq1CpyyzXjWU6dOzWlWDld87bXXvCmZ8VgXHuSjR8Jl4X/nxOXbcC/z+3JV8AL3YhkuzvnfOWB5HwjXMw9cIh4/Xu16vYEr5hMwfu2UbcA5pQt+H66XHjBWXdsSBxN0zh6wU8BGzG25pxlMfwtTDzidSGG+82ZNfC0VWzCDEf+IJzWZuDCPYZkhBhKvTz7p0+uuu665MAn/Ns4bOW/3NU1CT6ESzH7EyuMRirenRARqkwD3F71L0kfWVJwC9sMjzsfCm5UxVycLPdq//e1v/reB1zRCj7RNmza+p+sUWXLzvKcXLVrkz2HWrFn+P17YpLGld0wkBP85JiJt+C3RQ6/N7HFx6AHnVMA89LgQPGQwRUv+Q0AKOLo7wb0p+7ErlDEp9jC1rV692n8yTTOMQuk1PoQMobxRxpjfMMPxEAg/mOMqewjg/0BIBw8Wxticd6cfKzv77LOjg6E9lxwBSlri/4DixBRcU0GJk46SF9F333034/3NEAqm4GRh/JnKXi5u2C644IKM6yW3zzXN72fOnDkpSpmwpd13392eeeYZHIJzbaJKy0tCAZPBCCcAZ/Kwbt26+fGC9B6EC8auEphSaCwFHM+rSNwkvWmUMfc2b93JH5xEUMYoaJQxSpqMVqxHL4G4c6xCPExYzkuAC7GIJwwddZUIoCBQVNw/fN5//33r0KFDrWY8Y/vkUifW989//nOVjq+yxtR0p4Y7/jsovHRFW9l6zOccifflJZaXXSxOtSlkXaSHjO/EvvvuW5ub9hmwij0TVk4vaAbbGchHKLOWScpRAWfioHnFTwBPTZQrH4SHXbKQUu+9995LeIdiAsfTmYcvdbBD8x3eoC7ftZRvMrwSm8aagtmURBN8sAJyfzCMwcdlezJS9V511VU+zWpNTx8vZGpIY5XBBF0bgmUIs7ILVfJJN5588kk74ogj8t40x8KQD4UciFZ48cUXbauttsp7/VwNcf7CoaxcJacC7tixo3cdLydA9HYk5UkAywbmv1whUDyACaegmgye0OS+lZQGATKz0ft0jn8+lzK9XIYZUGTpXu68nJHjfMKECdajRw9zaVYz1konVI1sVbz4YWUho5VLKZkAhve/K+LhS3sSAVDZMEhihTwn8IsgExXCOCudqVwKGIWLV3X4ksqxDBo0yPCngAVKWPd7nhcgR7NKU1HmWK9kFxOrhokm14cfKeZHSXkSYEyN+HhMejvuuKOPnWTMThJfAlg5GF5w3sc+NpbxUiyA5EA47rjjKihfzhS/GMJpeBHDIc9VIPKKmnVCofdMTxJFtnDhQu90hLK+5557wia+iAGxucTh1pbyTWz8vxMoYIZRsqWbxOdn//339+PFhCwli0vOYWeddZbvpWMJkNQCAXfTSapBQGFI1YBWoquQ1J4SjM4k6cswkuheEh8CTiH5EBoySLlxyMAlFqr2wZNqkUxSLpd+4CJHAjecETgfgsAp4ZRtzp0712e3ck5Jfj4pJZ0zUkqbQnxxuRz8uWbaNmFC7oUicDmnfagSIUuEFZGyMllcjz9wMfpFnzo2DmFI6gHXwkuMNlHeBHBMoSQn3tFkDyLxgavN6s197sFV3nCK+OwJtcF/BWc6erB4tWNe5dpVVwiDo3fL2DDmXnwMXH1178iUvE0XZ+sTG5Fkg3uEQghknyq0hGboTPvhmCkXSqEUTM14LNMLxmRN9EAojCdjgsY7WlJDAslvNprOn4B6wPmzKreWJOWgEHrDhg19cgN6QZLiIOC8bgMKf7isTT5vMkle0gsY1MaROmenwA1jBS58J+PmsJi4R7cvfNC1a1c//fDDD2dsW5sznTezL4xAAoxkoWyge5GsUN4V64DLtuULMLiXhMQqzjnRJ8lxQ3GJecU2EYcesIoxVPOukQKuJrgyW82N8/lqTy6tYJmdefGcLsrGjX36urguFCdw4/feDJtuWq3NI3bex754Ai9jmQRF6MLfAufI56sOkeWtrsQlwahQNOTmm28OXJhppYfA8WFKpwBEeE5uXDygUESxShwUcE4v6Bp2sLW6CJQ1Abxi8SYlly+xmNRflRSGALHZOEYSRkb8KkMC/CejFI5yrmSk3XnnnYane6GlUaNGxqcyweyN4LRV1xKaocPCIYQ/4fWdLesWZmiczFgXpzM44pCF6Z5c1JLqEdAYcPW4aS0RyJsAiQyoZsN4I6EmJDWQ1JyA63n5NLnEzlKdh0QTeCu73pw5s7KPVyVzGfG7ZFpiui6Ub83PrLBbQIk+9NBD3vOaPY0bN85no8o19s1LA57apIAlTI8ENRQgIVZaUj0C6gFXj5vWEoEqESD37dtvv22UXyMGlIQepPerSlaiKu0who0Jj3FJ/X3GJWJl0z9w42UmFGJwBw4c6KsF0ZPceuuta72iTrivUvpPaUBCrXCwIpkMuc0pBZqPcL9SKpSYaF58cCbjBYf/kqoTkAKuOjOtIQLVIkBygyFDhiS8ZIk5xZRHGbdyElIa8vCnBjRexyhaelJkniJPN71UPMuTP8Sd4l1OrzcUzMokhyBuNVOZ1LCd/lckEJqhDzvsMJ9WFdZVkc6dOxtFGlDgJBmRVI+AFHD1uGktEag2AZIy0OPADEgavosvvtj35AqVgKHaB1pLK5JzG9MlY4d8SPZA3l9SezKOyMOffNrZlCgF3MkWlSzkpKdXTAIUwmYk+RNAAVMEgWxfrvxg1vHqyrbKfUwedV6cJNUjIAVcPW5aSwRqTACHLHq/OGrNnDnTFzwhjjTOgkMPjlBkCQsVLr1beql8evbs6eNsXaKKKp1mZXGy8MMEKgVcJZx+fJxxc7J0IRSBqI64UDvjI6kegar9Cqq3D60lAiJQCQHG48gpTf5fEjHgaVqZuKxEFiavZ7wzKmGsFg9j0iqmf+jtUkIPhx4ULmO0lDOtae+ehBV80oWqQdm8d9Pb6/uvBKiSdPXVV3szMrnNJXVPQAq47plrjyKQQgBTKgnzyTCUSSgOwvinS23oK/AMGzbM5yXGfE14CObc2uo5L1++3PfGGVvF4YbeDUqVrFF4FvOhDR6xOPLwQcHifcw0FYLSy5VmOqeqzMPLlmPJVI8cBcy4uqTqBHCicgljbNKkSVVfWWvUCgEp4FrBqI2IQM0IUNyD3m26YNI95ZRTvKMLBdJRjDgi0VPmO8rY5S72tU/xEObTvn37vBQy+6TcIrWR8SjmQcyYHlV6GNfDLElvl/FZHJ6I99xhhx28oq1tJZt+3snfUfD0tAnfwmKQLHg/UxADM7fqMieTyT1NeUGGCSTREZACjo699iwCCQIoQ5ddLfGdCbyD6Vk2bdrUXIEHXyKO+ZhzMfHywXRNzVfijIl1pTYtypmarTg1UT6PD97F5PNF2X744Yf+gyLffPPNfaIQeq8kVTjkkEOKKpQHBijZ9DKAcEBgQS+YcWBKp0pEIE4EpIDjdLV0rCVLgJ5ocpIIvqNQ8BSmjmy2MVRqvhIOwgdBIS9btszH1BJXG36IRSYrV/Pmzf0neX/FCpaSgIS5EDON0xovGOn1bFHAWAGkgIv1Kuq4KiMQewXMWzwmKExiMkFVdpk1v5gJcA/jrOQS9HuTL0oHZXL++ef7+VU9dhRy69atq7paUbYn1hTnM8a4UcKY42fMmOFDaMIDRgHfe++94Vf9F4HYEIilAqZ3MHLkSCM2kGnGqRBMbnhg0mvgR5tu0ovNVdGBlhWBKVOm+PzFOMWgeElOQXpAwpPKXXACw8weCmPTOKwRlhQKoUiUg5SIQNwIxE4BL1261IdrYJIjmJxgcHq+fMcRgxhEHmgkvnclwXyO2LhdFB1v+RBg7BfnJrxRCQlhrBdZtWqVzZs3zztXlQ+N3GdKvVpevKlFGypmQrJQzJ988okpnCY3Q7UoHgKxU8AjRozwvVzS2FUWAD58+HCfp/Suu+7yPeHiwa0jEYFUAiS17927t2F2xmqDFQfl269fPz/227Zt29QVyvwbL9oTJ070XtmMeYdF7MOEHJ06dSpzQjr9OBGoH6eD5Vjnzp3ry4pVpnxpQ8xgnz59bPr06XyViEBREsArmfSKVO9hvJeUgJTUQyihx5inpCKBZs2a+aQcJPpwRex9g1ABV2ytOSJQvARip4BJOsAYWS4h2TshFhIRKEYCFCQgvAivZEyohAfhz0BqQMKIqB8sqZwAsc44Y5FH+6ijjvJOZ3hCS0QgTgRiZ4Lu3r27z/zDeE+PHj38GC8JDOrXr+/HgJcsWeITCkybNs1XW4nTxdCxlg8BMltRV3WDDTbwmafCTFaECEnyI0BBebJkjRo1yo8H12VykPyOUK1EIDuB2Clgqp/Mnz/fV1Fh7Iw0femCFzTOLAceeGD6In0XgcgJ4DB0xx13+MIE/JfiqP4lYbgJD2g+ZA2TiECcCMROAQOXngMezoyXkXCAXi9p8+g9kKM2U0q/fC8KifEp0ZVLGK9THcxclLQ8EwF6u5Qi7NKlS6bFmldNAtn8Qqq5Sa0mAgUlEEsFHBLBI5Ii54QeNGrUyIcj1UT5sl1S+OXzYCQOkfR9EhGoDoF87rHqbFfriIAIxIdALBUw+WEJ0yB2EnNespCsnVjBSy65pFqmPRxi+OSSm266qUJi+FzraLkIiIAIiIAIhARip4DxFCVhPOEbhGlghibxBmbps88+2+bMmWPjx4/3IUgoaJLQF0IYb8Jj9bXXXivE5iPfJmPoZBgr52xipDilcDyOUuUqeGtzHxTqdxQHriRL4UP4U7kKQ250djp37hwbBCRmKnaJnQK+++67vbmZeOBQSLyB6ZgbhAw5hCZ06NDB54ft379/2KxW/99yyy3ekYYHdCkKcaiMqa2//vqleHp5nRN1cLm+5ax8eAnBv4JwqXIVLG4kR6GoRbkKz1bi1ilHGRchtp6Si8Us9Vwi+KCYDzD92FCs1CtNz/0KbGIpJ0+e7Fchly7TM2fOTN+EvudBgDzElMI76aST8mhdmk0okIDiueiii0rzBPM4KyoxUYf3hhtuyKN1aTbhOUJqW1JglquQe2HQoEEpObjLlUVtnnfsEnHQI+PHkC6kpkwOSeKhoepI6ZT0XQREQAREoFgIxE4B9+rVy1566SVfiGHq1Kk+2Qa9tbffftu6du3qx4SHDBliOEl169atWDjrOERABERABEQghUDsBjApyk1BBpQszlcIoUjDhg3zCpixCpK1X3fddXbsscemnKy+iIAIiIAIiECxEIidAgYcY3OnnXaaT0OHNzRFu0NHGZIcLFy40DvPFAtkHYcIiIAIiIAIpBOIpQLmJBjfrSzVZKl6JqdfPH0XAREQARGIL4HYjQHHF7WOXAREQAREQAR+JSAF/CsLTYmACIiACIhAnRGQAq4z1NqRCIiACIiACPxKIHaJOH49dE0VkgBVpoi5LudMWCR2odxd6OBXSN7Fum1lwjIjExYfsu2VqxBdwu9h2223LVcEBTlvKeCCYNVGRUAEREAERCA7AZmgs/PRUhEQAREQAREoCAEp4IJg1UZFQAREQAREIDsBKeDsfLRUBERABERABApCQAq4IFi1UREQAREQARHITkAKODsfLRUBERABERCBghCQAi4IVm1UBERABERABLITkALOzkdLRUAEREAERKAgBKSAC4JVGxUBERABERCB7ASkgLPz0VIREAEREAERKAgBKeCCYNVGRUAEREAERCA7ASng7HxKcukvv/yS87yCIKiVNjk3ElGDfBjk0yYfThGdYl67zeccc22oHBjkOsdcy3MxjHp5PvdBPueYT5uoz7WY9i8FXExXo8DHcu+999rOO+9sDRs2tI022si6detmy5cvT9nrnDlzrEePHrbhhhvaNttsY1dddVXKcr7ceeeddtBBB9k666xje+21lz3zzDMV2hTrjHwY5NMmH07FyuDtt9+2o446ypo0aeKv4R577GEzZ86s9HD79+9vm266aYXlpc4ApTR06FBfgGC99dazk046qcK9XuoMVqxYYSeccIJx/uuuu64deuihxv2TLN98840NGjTIWrVq5Z8rxx9/vH322WfJTTRdGQH3xiIpAwIPP/wwXdqgd+/egVOYwW233RY4BRvssssuwb///W9P4Ntvv/XzTj755OD1118Pbr/99sAp2WDYsGEJQs8++2yw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AtZdIAJlQADv50cffdSP+zIW++abb9of/vAHnxmLxBzNmjWzU0891S6++GKvdL/88ksjvIjecSht27a1Vq1a+eQdxPViZr733ntt4sSJ1rNnT0PREw/co0cP23LLLY2wqVA22mgju/XWW/32iA+WiIAIOAJl74YmACJQxATwgt5jjz1SjtCN2XrPYhfXmzKfL5V5QTszdHDGGWcEzmTs1+Wn75y5gtmzZye24XqmQdeuXYO1117bt9l///0D12MNXPxuoo1zrApcbzmxDbZzwgknBHhMI+ecc473jn7uuecS6yRPOEWddXlyW02LQKkTqMcJ6k1EBESgPAiQg/mYY46xIUOGGN7QmYReLIk46BVXJsQn4yFNasmNN964smaaLwIikIWAEnFkgaNFIlBqBMjBjALecccdKz011wM2PtkEE7Pr+Ur5ZoOkZSKQg4B6wDkAabEIiIAIiIAIFIKAnLAKQVXbFAEREAEREIEcBKSAcwDSYhEQAREQAREoBAEp4EJQ1TZFQAREQAREIAcBKeAcgLRYBERABERABApBQAq4EFS1TREQAREQARHIQUAKOAcgLRYBERABERCBQhCQAi4EVW1TBArT8WcAAADtSURBVERABERABHIQkALOAUiLRUAEREAERKAQBKSAC0FV2xQBERABERCBHASkgHMA0mIREAEREAERKAQBKeBCUNU2RUAEREAERCAHASngHIC0WAREQAREQAQKQUAKuBBUtU0REAEREAERyEFACjgHIC0WAREQAREQgUIQkAIuBFVtUwREQAREQARyEJACzgFIi0VABERABESgEASkgAtBVdsUAREQAREQgRwEpIBzANJiERABERABESgEASngQlDVNkVABERABEQgBwEp4ByAtFgEREAEREAECkFACrgQVLVNERABERABEchB4P8BAD/hlUEKGjYAAAAASUVORK5CYII=" /><!-- --></p>
<p>You can find out what methods are available for a particular class
like so:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">methods</span>(<span class="at">class =</span> <span class="st">&#39;neuron&#39;</span>)</span></code></pre></div>
<pre><code>##  [1] *                  +                  -                  /                 
##  [5] all.equal          as.neuron          as.ngraph          as.seglist        
##  [9] boundingbox        branchpoints       dotprops           endpoints         
## [13] ndigest            nvertices          plot               plot3d            
## [17] potential_synapses prune              resample           rootpoints        
## [21] scale              subset             summary            write.vtk         
## [25] xform              xyzmatrix          xyzmatrix&lt;-       
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>You can then find the help page for any method in the console with
<code>?plot.neuron</code>. Note that if you write <code>?plot</code> you
will get the documentation for the basic <code>plot</code> function
supplied with R.</p>
<p>It is also good idea to look at <a href="http://natverse.org/nat/reference/index.html">nats function
reference page</a> which groups available functions into categories that
often reflect the class of object they can work on.</p>
<p>In R, operators such as <code>*</code> or <code>+</code> are actually
special functions with two arguments, so one can add methods for these
in the same way. In the following example we use this arithmetic to
shift a neuron by a small amount:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1, <span class="at">col =</span> <span class="st">&#39;black&#39;</span>, <span class="at">WithNodes =</span> F, <span class="at">main=</span><span class="st">&quot;Shifting neurons&quot;</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co"># shift by 3 microns in x,y,z</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1<span class="sc">+</span><span class="dv">3</span>, <span class="at">col =</span> <span class="st">&#39;red&#39;</span>, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">WithNodes =</span> F)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co"># shift by -5 microns in y</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1<span class="sc">+</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="dv">0</span>), <span class="at">col =</span> <span class="st">&#39;blue&#39;</span>, <span class="at">add =</span> <span class="cn">TRUE</span>, <span class="at">WithNodes =</span> F)</span></code></pre></div>
<p><img src="data:image/png;base64,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yy236L8PPvjA65i/L2+88YY7v9PpdGfB9gsvvEA1atTQddarV4+WLl3qPn7gwAH6888/3d9PnjzpLuf9999375cNISAE4pdAlvjtmvRMCBB98cUXdP/993sJu9OnT9OhQ4fom2++oUmTJtGaNWsoR44cGteFCxdoxYoVevvGG28MiXDXrl3u/Eopd/6hQ4cS/oy0fv16yp49O/399996/1tvvUXbtm2jPHny6Cye9TZo0MA4TT6FgBCIYwIigOP44iZ61yAQe/TooYVv7ty5qVWrVtSwYUP6+eef6ZNPPiGMQjdv3kwDBgwgjGQjSbVq1SIIdCSbzeYuYt26dXo7S5YstGHDBrryyiupWLFiNGTIEPrf//7nzmds5MyZk+666y79tXLlysZu+RQCQiCOCYgAjuOLm+hd27RpEx07dkxjeOaZZ+ill15yI2nbti3VrVtXf1+yZElQAQxBjhFziRIlCALVMz322GOEP9909OhRvevqq6/W09C+x32/FyxYkD7//HPf3am+oy2HDx+mokWLUtasWVMdN3akpKTQkSNHqHTp0l4vBsbxcD7N1vnXX3/pl52SJUuGU7zpvOgProG/9Ntvv5HdbtfT/f6O+9uH9mJGAiwDJSwTnDhxgvLmzUsFChTQdQTKK/uFQNgE+MclSQjEJQGe4sWcsP679tprFY98vfq5fPlytXLlSvXjjz+69+/fv999ziuvvKJeffVVxaNXvY+nkFWvXr0UTxe78z/88MPq8ssv138s9BSv8+ptFgb6HHziOE9nq9atW6vLLrvMXT5Pe6siRYroslioussZPHiw3rdv3z73vgULFii0h9ew9fksfFW3bt3UuXPn3G3Bxj///KPbiLai7yw4FI+6FU95u8vyOsHnSyR18hS+ql69uuIZAF0neD3++ONenFANLwXoNvDLhletvBTgbtv06dP1MZRpcF24cKHiFxldNgt3derUKZ0Hfe3bt6+qVKmSPob+Fi9eXPfV4XB41fHggw/q8urXr6942UBdd911yrhG/JKivvrqK6/8M2fOVOXKlXOXi7ILFy6sRowY4ZVPvgiBtBCgtJws5wqBWCaAh7DnwxkCgqeM1fPPP68Fb3JycqrmewpgXp/VD2A8eJOSktwPY56ydp8HIWgIeQjgL7/80v3d2I9PHm2rO+64I9UxnhrXZR08eNB9jEfqet/e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Gh7rwenhHCMGuy9NEgKWIyAC2HKXTBosBPwTgDkVTH8MLWDfXBgR//DDD4QITpKEgBCIPgFZA47+NZAWCIF0IYA1SqyL9uvXT09tY3oXU8GITmSYCYnwTRfUUogQSBcCMgJOF4xSiBCITQJQTvJcC47NVkqrhEBiEhABnJjXXXotBISAEBACUSYgU9BRvgBSvRAQAkJACCQmARHAiXndpddCQAgIASEQZQIigKN8AaR6ISAEhIAQSEwCIoAT87pLr4WAEBACQiDKBEQAR/kCSPVCQAgIASGQmAREACfmdZdeCwEhIASEQJQJiACO8gWQ6oWAEBACQiAxCYgATszrLr0WAkJACAiBKBMQARzlCyDVCwEhIASEQGISEAGcmNddei0EhIAQEAJRJiACOMoXQKoXAkJACAiBxCQgAjgxr7v0WggIASEgBKJMQARwlC+AVC8EhIAQEAKJSUAEcGJed+m1EBACQkAIRJmACOAoXwCpXggIASEgBBKTgAjgxLzu0mshIASEgBCIMgERwFG+AFK9EBACQkAIJCYBEcCJed2l10JACAgBIRBlAiKAo3wBpHohIASEgBBITAIigBPzukuvhYAQEAJCIMoELC+AlVL022+/0enTp6OMUqoXAkJACAgBIWCegCUF8NGjR+nZZ5+lMmXKUNasWalQoUKUP39+ypMnD9WoUYOefvppOnfunHkKklMICAEhIASEQCYTsPEIUmVynWmq7tChQ9SwYUOy2WzUtm1bKleuHOXLl09/xyj4wIEDNGfOHEK3li1bRuXLl09TfXKyEBACQkAICIGMIGA5Afzoo4/Sli1baOnSpZQtWza/TJKTk6l58+bUoEEDGjRokN88slMICAEhIASEQDQJWG4KevPmzdSlS5eAwhcwL7vsMurWrRstWbIkmmylbiEgBISAEBACAQlkCXgkRg/Ur1+fvvvuO+rZs2fQFi5fvpyKFy8eNE9aDo4cOZLGjh2r153TUo6cKwTMELhwoRgvq2SlHDkOmsluiTwXLxbml+Xf6d9/0Tc79+2QJdotjbQGgezZs9OCBQsoV65cMdtgywngDh06EITwyZMnqWPHjnqNFwpYdrtda0IfPHiQPvroI1q8eLGeps4o8tOnT6d3331XBHBGAZZyvQgcOpSd+vevSOPHb/HaH+yL00m0eXNuWrv2Svrrryz8+8BfVrri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Wq1Rkwhga1wnaaUQEAJCQAjEGQGZgo6zCyrdEQJCQAgIAWsQEAFsjeskrRQCQkAICIE4IyACOM4uqHRHCAgBISAErEFABLA1rpO0UggIASEgBOKMgAjgOLug0h0hIASEgBCwBgERwNa4TtJKISAEhIAQiDMCIoDj7IJKd4SAEBACQsAaBEQAW+M6SSuFgBAQAkIgzgiIAI6zCyrdEQJCQAgIAWsQEAFsjeskrRQCQkAICIE4IyAC2IIX9Pz580Fb7XQ6gx7HQaVUyDwZlSE92hfr7U+PPmYUf5Rrpn1m6o/162CmfWbymGERbh4z18BMnmi1H/01U3d65QmXrxXyiwC2wlXyaOOUKVOoQIECHntcm/ihDh48mIoVK0aXXXaZdqI/Y8YMr3znzp2jZ599lipUqED58uWj1q1b06lTp7zyZNQXOPa/4447KHfu3JQzZ06qU6cOff31117VmWnfpk2bqGPHjpQ3b14qV64cvfrqq15lZOSXmTNnUrVq1Shbtmya33333UdHjhzxqtJMng8++IBuvvlmzeG6666jlStXepWRUV/+/vtv6tevn75HsmTJQqVLl6YhQ4ZQSkqK3yqRv3z58vToo4+mOh6tPpi5j/BbGDRokG57rly5qH379qkYm7nXUnU6nXaYuUfw26hZs6a+1woWLEiPP/44IbiEZ4rWbyE5OZneeecduv766+mKK66gm266ib7//nvPpultM/eImTypCo6nHfx2IskiBObOnauyZs2qcuTIkarFr7/+urLZbOp///ufWrdunerZsyeGuGrJkiXuvH379lX8QFX841bffPONqlGjhuIfueIHljtPRmywkFfFixdXtWvXVh999JH68ssv1Z133qn4RUH9+OOP7ipDtY8FgmKhq+6//361ceNG9f777ysW5uq1115zl5FRGwsWLNA8u3btqlhgqgkTJui2VK9eXV28eFFXayYPuOMajho1SvEDVPXq1Utlz55dbdmyJaOa7i63S5cuil9c9D2ydu1a9cILLygWxOqll15y5/Hc6NOnj+7zI4884rlb3zvR6IPZ+4hfGNTll1+u749vv/1W3XPPPYpfONXZs2fd/Qh1r7kzpvOGmXuEXzIUv+Spu+++W6H9o0ePVvwioXr06OFuTTR/C++9957KkyePbtd3332n+EVU8961a5e7fWbuczN53AXG6Qam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lrtk0mAhIASEgBCIBwIigOPhKkofhIAQEAJCwHIERABb7pJJg4WAEBACQiAeCIgAjoerKH0QAkJACAgByxEQAWy5SyYNFgJCQAgIgXggIAI4Hq6i9EEICAEhIAQsR0AEsOUumTRYCAgBISAE4oGACOB4uIrSByEgBISAELAcARHAlrtk0mAhIASEgBCIBwIigOPhKkofhIAQEAJCwHIERABb7pJJg4WAEBACQiAeCIgAjoerKH0QAkJACAgByxEQAWy5SyYNFgJCQAgIgXggIAI4Hq6i9EEICAEhIAQsR0AEsOUumTRYCAgBISAE4oGACOB4uIrSByEQJoGJEyeSzWajMWPGpDpzz549lCtXLnriiSdSHZMdQkAIpB8Bm+KUfsVJSUJACFiFQIsWLWjFihW0ceNGqlixom72hQsX6Prrr9fb33//PWXLls0q3ZF2CgHLEZARsOUumTRYCKQPgUmTJlGOHDmoU6dOlJKSogvFqBcj4JkzZ4rwTR/MUooQCEggS8AjckAICIG4JlCkSBEaO3YstWvXjt58802qUqUKjR8/nsaNG0eVK1eO675L54RALBCQKehYuArSBiEQRQIdO3akefPmUe7cufX089y5c6PYGqlaCCQOARHAiXOtpadCwC+BM2fOUIkSJejixYt05MgRwshYkhAQAhlPQNaAM56x1CAEYprArFmz6Pz58+RwOOi9996L6bZK44RAPBGQEXA8XU3pixAIkwAUrmrVqkWYhoYG9IwZM2jt2rVUt27dMEuS7EJACIRLQARwuMQkvxCIEwLQfK5fvz6dOHGCtm3bpkfAVatWpbx582rTpOzZs8dJT6UbQiA2CcgUdGxeF2mVEMhwAoMHD6YNGzbQlClTKE+ePJQvXz6tAb1r1y56+eWXM7x+qUAIJDoBGQEn+h0g/U9IAphmbtSoEfXq1SvVui/sgmEHvGrVKmrQoEFC8pFOC4HMICACODMoSx1CIIYInDt3jmrWrKldUW7ZsoVy5szp1brTp08TpqKvuOIK8nfcK7N8EQJCIGICIoAjRicnCgEhIASEgBCInICsAUfOTs4UAkJACAgBIRAxARHAEaOTE4WAEBACQkAIRE5ABHDk7ORMISAEhIAQEAIRExABHDE6OVEICAEhIASEQOQERABHzk7OFAJCQAgIASEQMQERwBGjkxOFgBAQAkJACEROQARw5OzkTCEgBISAEBACERMQARwxOjlRCAgBISAEhEDkBEQAR85OzhQCQkAICAEhEDEBEcARo5MThYAQEAJCQAhETkAEcOTs5EwhIASEgBAQAhETEAEcMTo5UQgIASEgBIRA5AREAEfOTs4UAkJACAgBIRAxARHAEaOTE4WAEBACQkAIRE5ABHDk7ORMISAEhIAQEAIRExABHDE6OVEICAEhIASEQOQERABHzk7OFAJCQAgIASEQMQERwBGjkxOFgBAQAkJACEROQARw5OzkTCEgBISAEBACERMQARwxOjlRCAgBISAEhEDkBEQAR85OzhQCQkAICAEhEDEBEcARo5MThYAQEAJCQAhETkAEcOTs5EwhIASEgBAQAhET+D81Uck2s0+u0gAAAABJRU5ErkJggg==" /><!-- --></p>
<p>Another specialised method is <code>subset.neuron</code> which we can
use to extract part of a neuron into a new object. For example, a simple
spatial criterion, X location must be &gt;240, is used to extract the
axon terminal arborisation field in this example</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1, <span class="at">col =</span> <span class="st">&#39;black&#39;</span>, <span class="at">WithAllPoints =</span> T, <span class="at">main=</span><span class="st">&quot;Subsetting a neuron&quot;</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co"># keep only nodes with X position &gt;20</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>n1.lh<span class="ot">=</span><span class="fu">subset</span>(n1, X<span class="sc">&gt;</span><span class="dv">240</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the selected part of the neuron in blue</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(n1.lh, <span class="at">col=</span><span class="st">&#39;blue&#39;</span>, <span class="at">lwd=</span><span class="dv">3</span>, <span class="at">add=</span><span class="cn">TRUE</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="co"># add a line illustrating the cut point</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="dv">240</span>, <span class="at">lty=</span><span class="dv">2</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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2Wexdu3a4FcmwBoMGTJEP8ixz3urhho1aoAdJFWvXt2qTUizeltyBMw0eB1w8+ayL22a3RmSsRAQAkJACKQpATFvTVO8krkQEAJCQAgIAd8ERAD75iKxQkAICAEhIATSlIAI4DTFK5kLASEgBISAEPBNQASwby4SKwSEgBAQAkIgTQmIAE5TvJK5EBACQkAICAHfBEQA++YisUJACAgBISAE0pSACOA0xSuZCwEhIASEgBDwTcCyjjh8N0dimcDWrVstvejd8IRVqlQpy3ZoOHjC2r59OypWrKjX3FuxIwxPWDfkljXIDQ8XT1glSpTQrlmDjDPkihcBHHJdIhUSAkJACAiBjEBAVNAZoZeljUJACAgBIRByBEQAh1yXSIWEgBAQAkIgIxAQAZwRelnaKASEgBAQAiFHQARwyHWJVEgICAEhIAQyAgERwBmhl6WNQkAICAEhEHIERACHXJdIhYSAEBACQiAjEBABnBF6WdooBISAEBACIUdABHDIdYlUSAgIASEgBDICARHAGaGXpY1CQAgIASEQcgREAIdcl0iFhIAQEAJCICMQEAFswV6+cuXKdWvt8Xiue55PKqWSTZNWCVKjfqFe/9RoY1rx53z9qZ8/5Yd6P/hTP3/S+MMipWn86QN/0gSr/txef8pOrTQp5WuF9CKArdBLXnX88ssvkT9/fq+YuEP+or7++usoWrQoIiMjtRP9adOmxUsXHR2NQYMGoXz58sibNy86d+6M06dPx0uTVh/Ysf8dd9yBnDlzImvWrKhbty4WL14crzh/6rdx40b07NkTefLkQZkyZTB8+PB4eaTlh2+++QbVqlVD5syZNb/u3buDN13wDv6kmTx5Mm677TbNoX79+vjll1+8s0iz40uXLmHgwIH6HomIiABvdvHmm2/C5XL5LJPT80YGTz75ZKLzwWqDP/cRfxeGDRum654jRw7ce++9iRj7c68lanQqRfhzj/B3o1atWvpeK1CgAJ555hnw5hLeIVjfBafTidGjR+OWW25B9uzZ0axZM/z222/eVdPH/twj/qRJlHE4RdDTiQSLEJgzZ47KlCmTypIlS6Iav/POO8pms6k33nhDrVu3Tj388MM8xFULFy400z711FOKflAVfbnVr7/+qmrWrKnoS67oB8tMkxYHJORVsWLFVJ06ddTUqVPVzz//rO68805FDwrqjz/+MItMrn4kEBQJXXXfffepP//8U02cOFGRMFcjRoww80irg++//17z7NOnjyKBqT777DNdl+rVq6urV6/qYv1Jw9y5Dz/88ENFP6DqscceU1FRUWrz5s1pVXUz3969eyt6cNH3yNq1a9VLL72kSBCrl19+2UzjffD444/rNj/xxBPe0freCUYb/L2P6IFBZcuWTd8fK1euVB07dlT0wKkuXrxotiO5e81MmMoH/twj9JCh6CFPdejQQXH9x40bp+hBQj300ENmbYL5Xfjoo49Urly5dL1Wr16t6EFU896xY4dZP3/uc3/SmBmG6QGrECSEOIHz588rGvXpH8MKFSr4FMC1a9dWbdu2NVtCoxot9O6//34dt2XLFmW329XcuXPNNPxFTyikzZOpePDFF1/ocn7//XczV24TPT0r/rHk4E/9Xn31VUUjaEUqeDMfGuko0giomJgYMy4tDpht6dKl4z2sfPvtt7pd/EPCwZ80lStX1n3pXUcaVat+/fp5R6X68blz53T/P//88/Hy7tKliypYsGC8OP6wZMkSLbSKFCmiEgrgYLXBn/vo2LFjWniRpshsE40c9YMnjbZ0nD/3mnlxKh/4c4+89dZbug0nT540SzceKtxut44L1neBWRYuXFi98MILZt34u8wPPPzwbwR/7hF/0hj5heu7qKAtoM6gUSJWrVoFEp6gERNopJuo1vny5QN9Ecx4umG1apFVvhxYpUWjFrRr185MQ18AkEDHjz/+aMalxQGNfDF+/HjUq1fPzJ7rxap0o87+1I9Gzrr+NGI086FRAk6dOoX169ebcWlxQBoFfPrpp/HY33TTTbooow3JpWF1NY0S0KlTp3hV5DYsWLAgXlxqf6Afbt0H//vf/+JlzW2gkWG8uTz+/OCDD2o1I99X3vdbMNvgz300Y8YMsNq5b9++ZjtJY4S///4bpAHQcf7ca+bFqXyQ3D3CxfH0EKt5vW09eJqA1b1GXwTru8Aseb9x0pqYZM6ePQvSAumpL4705x7xJ41ZQBgfiAC2QOfyD8/u3bvBP9RJBf5hJbUsXnzxRSxfvlz/gPKXwvgh4h8gnktiIewdeM6YN/1Oy8BzWfzg4B34geLAgQN6Honj/akfpyFVtnc25mca+cSLT+0PPF9+++23x8uW1OnguVSez+aQXJo9e/bodL7aQKOdVDOM0oUk+MM/6o888giMhwY+zXOlPB/ZoEED84ed45977jlUqVLFFFgcZ4RgtsGf++jQoUOoWrUqdu3aBZouAE2z6HbwD74R/LnXjLSp/Z7cPcLl3X333SBtC0grAha077//Pvhee/rpp81+CuZ3gR+c+SGHHxJWrFgB/u3h35auXbtqXP7cI/6kSW32oZhfRChWSuoUnwDNt8SP8PGJv9hsqEFzwfrFSdhgyxAOFy5c0E/WCS9lY6a0FsAJy+QRFqk1UalSJdC8lj7tT/04DY/IvEPu3Ln1x/RuA8196RExCytS03pXyTxOmMYYpSdsA/cBj1DZII5/yNIrDB48GP/++y9mz55tFkk2A+BR5F9//WXGeR9w33EIhTb4uo/++ecfnDlzRhu5sYaHtS4svBYtWoRt27bpevtzr3m3OS2PE94jXBapeHWdmzZtCpoK0MWTzYR+uDbqEgrfBTbEYqNODjQ9oB8a+Nife8SfNOn5XeB6ByPICDgY1NOgTH5aZoE7cuRIkEEPaI5GW6+SsY8ujS2jaQ44Ucms0oqNjU0Un1YR/MPBPyY8UqE5VHNE7k/9OI2hgjPqZ3zmp/H0CmTkhrvuukuP3tna1lfwlYZHyxyMOie8Lj37gQzX8O677+qHNbbE5kDzxPqBiONLlCiRsHr6c6i0Ian7iONZRfrss89qTdCECRPAUzj8gPbee+/pNvhzr/lsfCpH+rpHuAgytkTz5s31CHjDhg0ggz/s3LlTa2D4QY1DKHwXyBgSNJ8OsivQo2C+pzj4c4/4k0ZnFuZ/Ev8ih3mDw7F5PHJic34ejQ0YMAA1atTQP6xk/Ym3335bN5mfqnmuJmHgOGOeOOG51P7M9eQfFl5KwvNwrB40gj/185WGhQYHVomlR1i2bBlatWqll4j88MMP8J6PNspPKo0xUjbqbKQ3+iW9+oF/MIcOHarvEV6WZASO5ykKXqb2Cy2N4hcv12H1LR+ToZs52g9mG653HxUqVEg/aBrzvdw2Vqfzd8LQQPi6jzhden4XkrpHuB4ff/wxePTONgc333wzeN6YH6yXLl0KFtocfLXB6JP0+i7wQxqtAtAPcvxQzfVm2xN/7nN/0uiGhvkfEcBh0MH8peT5PJ478g48Z8wquX379ukvBc8zGk/QRjqeO+X1tGkdWC3IguvEiRN63shQjRvl8hcyufrxj07CuV5WoXLg9appHXhuvX379rodbDTFRjEJw/XScP05GHU2ruU2GfNqRlxavbPAHTVqlP5xZy2Jd9i0aRP279+Pli1b6gclfljieXo2/uNjHkUGuw3J3Uds08APRWTZ7d00vfbZ0Dz4c6/FuziVP1zvHuGi1qxZk+i7zGvoedTLthMcgvVdYINDNto0DA91ZegPf7f5vuaHNX/uEX/SGHmH9Xu4mneHa7vox1OvffVuHy+roJtUTZ8+3TtakXGEcjgcipcO0JyeTsPLS4ywd+9eHffdd98ZUWnyTkJfkZpTkeMHRT/oPsvwp3689ILmhRQvsTICjfD10iRSPRpRafLO9eM1x7wG2bt878L8SUMGQurRRx/1vkyvj+7WrVu8uLT4wGvFeSkaL5/yFegHVB08eDDei5e98dpnjjfaHaw2+HMf0Uhd39MkqMwm0iheL+vhdc8c/LnXzItT+cCfe4RsI9Q999wTr2QaMet2ff311zo+WN8FUoXrevBSKe9ADwj6+5GSeyRY95F3vYN9LOuAg90DKSzflwBmRxrkWUmv5+QvKqnotKMHUmlqhxxGETSKUbzmlCxEFT2pqhYtWqgmTZrEW9tqpE3Nd1Kl6S8tO51gBxbeLxpJmkUlVz8azWvnHbwulUZC2iEGO1j44IMPzDzS6oCe8PX667Fjx8arP7eFf5Q4+JOGlmNpxxszZ85UNIpQ5IlKf+aHobQM3N/8AEGah0T15zbQ/LPP4vl+MdZqGwmC1QZ/7yN+2GOHLeSdSZG1rXYUwd8FXvduhOTuNSNdar/7c4+wowt+oKY5a/1d/umnnxSpohWpfJXxoBnM7wJ5vlKk6lfz5s1TR48eVa+99pp+0KdpDROXP/eIP2nMDMP0QASwxTrWlwDmJvAXklTQ2hsWf3l55EvLTuJ5/+Ef4UaNGukvNxlBqNatW8f7UUorFI0bN9Zlcr0Svtq0aWMW60/9aN5VO97gfFj4chuNp24zo1Q+YLYJ6+39mQx9NH/vuITHnIYD15Xm6vWDBKdhZwSGg4hUrna87MaMGXPdNvDDgK/gSwAHqw3+3kc0zaFovbse7TNj9v7G3te8gz/3mnf61Dj25z7icviBmr27scc74z4ia27trMa7HsH4LnD53A52KGLUjb12DRkyJN5DnD/3iD9pvNsbjsc2bhSBlBAmBNhohp5K9ZIA9lnsK7DjCraI5rWhoRiSqx/fsqQSRfHixU2Ly1Bsx/XqxAZNPB9esmTJ6yUL6XOh3gb+LrBhEt8nSYXk7rWkrkuPeLbX4Dl5/p4m9V0N5neB5+PZboNtSHh+2lfw5x7xJ42vvMMhTgRwOPSitEEICAEhIAQsR0CsoC3XZVJhISAEhIAQCAcCIoDDoRelDUJACAgBIWA5AiKALddlUmEhIASEgBAIBwIigMOhF6UNQkAICAEhYDkCIoAt12VSYSEgBISAEAgHAiKAw6EXpQ1CQAgIASFgOQIigC3XZVJhISAEhIAQCAcCIoDDoRelDUJACAgBIWA5AiKALddlUmEhIASEgBAIBwIigMOhF6UNQkAICAEhYDkCIoAt12VSYSEgBISAEAgHAiKAw6EXpQ1CQAgIASFgOQIigC3XZVJhISAEhIAQCAcCIoDDoRelDUJACAgBIWA5AiKALddlUmEhIASEgBAIBwIigMOhF6UNQkAICAEhYDkCIoAt12VSYSEgBISAEAgHAiKAw6EXpQ1CQAgIASFgOQIigC3XZVJhISAEhIAQCAcCIoDDoRelDUJACAgBIWA5AiKALddlUmEhIASEgBAIBwIigMOhF6UNQkAICAEhYDkCIoAt12VSYSEgBISAEAgHAiKAw6EXpQ1CQAgIASFgOQIigC3XZVJhISAEhIAQCAcCIoDDoRelDUIghQQ+//xz2Gw2fPzxx4mu3L17N3LkyIH+/fsnOicRQkAIpB4Bm6KQetlJTkJACFiFQPv27bF8+XL8+eefqFixoq52TEwMbrnlFn3822+/IXPmzFZpjtRTCFiOgIyALddlUmEhkDoEJkyYgCxZsqBXr15wuVw6Ux718gj4m2++EeGbOpglFyGQJIGIJM/ICSEgBMKaQOHChTF+/Hh069YNI0eORJUqVfDpp5/ik08+QeXKlcO67dI4IRAKBEQFHQq9IHUQAkEk0LNnT8ydOxc5c+bU6uc5c+YEsTZStBDIOAREAGecvpaWCgGfBM6ePYvixYvj6tWrOHLkCHhkLEEICIG0JyBzwGnPWEoQAiFNYPr06bhy5Qrcbjc++uijkK6rVE4IhBMBGQGHU29KW4RACgmwwVXt2rXBami2gJ42bRrWrl2LevXqpTAnSS4EhEBKCYgATikxSS8EwoQAWz43atQIx44dw9atW/UIuGrVqsiTJ49emhQVFRUmLZVmCIHQJCAq6NDsF6mVEEhzAq+//jo2bNiAL7/8Erly5ULevHm1BfSOHTswdOjQNC9fChACGZ2AjIAz+h0g7c+QBFjN3LRpUzz22GOJ5n15XTCvA16xYgUaN26cIflIo4VAehAQAZwelKUMIRBCBKKjo1GrVi3tinLz5s3ImjVrvNqdOXMGrIrOnj07fJ2Pl1g+CAEhEDABEcABo5MLhYAQEAJCQAgETkDmgANnJ1cKASEgBISAEAiYgAjggNHJhUJACAgBISAEAicgAjhwdnKlEBACQkAICIGACYgADhidXCgEhIAQEAJCIHACIoADZydXCgEhIASEgBAImIAI4IDRyYVCQAgIASEgBAInIAI4cHZypRAQAkJACAiBgAmIAA4YnVwoBISAEBACQiBwAiKAA2cnVwoBISAEhIAQCJiACOCA0cmFQkAICAEhIAQCJyACOHB2cqUQEAJCQAgIgYAJiAAOGJ1cKASEgBAQAkIgcAIigANnJ1cKASEgBISAEAiYgAjggNHJhUJACAgBISAEAicgAjhwdnKlEBACQkAICIGACYgADhidXCgEhIAQEAJCIHACIoADZydXCgEhIASEgBAImIAI4IDRyYVCQAgIASEgBAInIAI4cHZypRAQAkJACAiBgAmIAA4YnVwoBISAEBACQiBwAiKAA2cnVwoBISAEhIAQCJiACOCA0cmFQkAICAEhIAQCJyACOHB2cqUQEAJCQAgIgYAJ/B/ELE+/T9mRBwAAAABJRU5ErkJggg==" /><!-- --></p>
<p>We can also summarise the morphological properties of a neuron using
the <code>summary.neuron</code> method, which allows us to compare
measurements for the original neuron and the axon arbour that we just
cut out above.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(n1)</span></code></pre></div>
<pre><code>##   root nodes segments branchpoints endpoints cable.length
## 1    1   180       33           16        18     297.1763</code></pre>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(n1.lh)</span></code></pre></div>
<pre><code>##   root nodes segments branchpoints endpoints cable.length
## 1    1   111       27           13        15     156.7654</code></pre>
<p>See <a href="http://natverse.org/nat/reference/index.html">nats
function reference page</a> for additional functions for working with
neurons.</p>
</div>
</div>
<div id="neuronlists" class="section level2">
<h2>Neuronlists</h2>
<p>The <code>data</code> statement above loaded a
<code>neuronlist</code> object called <code>Cell07PNs</code> containing
40 <code>neuron</code> objects. <code>neuronlist</code> objects are key
data structures in nat for convenient handling of collections of
neurons.</p>
<div class="figure">
<img src="data:image/png;base64,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" alt />
<p class="caption">Structure of neuronlist objects</p>
</div>
<p>The diagram above presents the structure of a neuronlist,
<code>x</code>, which contains 5 neurons. The main structure is an R
<code>list</code> object, which in this case contains 5 slots. Each slot
contains a neuron with a unique name. In addition to this list of
neurons there is an optional attached <code>data.frame</code> (another
standard R class). When present, each neuron in the main list must have
a matching row in this <code>data.frame</code>.</p>
<p>Neuronlists can be manipulated use the square bracket subscript
operator to extract or replace a subset of their elements. Crucially
when this happens the corresponding rows of the attached metadata are
also selected as diagrammed for the result of x[1:3] (right hand side of
figure above).</p>
<p>When subscripting any list in R, it is very important to understand
the difference between using the single and double bracket operator. We
can illustrate this difference as follows:</p>
<div class="figure">
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcQAAACxCAIAAADVpVqOAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACcRJREFUeNrs3bFPI1ceB3D7tM2dFCm4jHSNUVIj2T1Egj8B6qtwu6mgO9LhatPiPg006ReJ3R6kTXd30lJeFZnoUlzp+5qXzM6xy4oFw47tz0fIGoax8Tz//J33ZsyjPZlMWgA8zJ80AYAwBRCmAMIUAGEKIEwBhCmAMAVAmAIIUwBhCiBMARCmAMIUQJgCCFMAhOkjGAxa7XZrdfXdmn6/NRpNFy4vpz/KV/kWFrj+36/2k5N374uPbCZMeWd3t/X27e/L+/uti4vfl7vd1mQyvYUlqf8s5NvIu2A4fLfN0dH0a/neFM+Uxz3leAskRtOrKNFpmM995JDr32fB3t70jXB4qCWE6S06nWnfM7c56pbzPldXWgX1jzD9ROPx9HzQysr0fND29vTYm2VQ/9zCOdPbHR1Nj8ynp+/OuIP6R8/0k+3sTM+pb25OF4xxUP8I0/vo96cfnYsy0skhuvoUFKh/DPPv6vz8Tpu5oM8y139lb2/6pWfKJxiN/u8voCrljz1yC0tS/1n44J82DQbTr+V7U7Qn+lYAeqYAwhRAmAIgTAGEKYAwBRCmAAhTAGEKIEwBhCkAwhRAmAI03wPmM33+vPXmjRZcOmtrrR9+0AwwuzBNkr5+rQUBWjOYaf/Fi2lXhWWQw+d332kGeJwwTZJubGhHYMm5AAUgTAGEKYAwBUCYAghTAGEKIEwBEKYAwhRAmAIstGdP9ps2/tV6/ZsGb5xJTxuo/yW1/kXr1TdzGKZx9k1r4wuvYIO0L7TBkx211H+zvPqtdfBvw3yAhhGmAMIUQJgCCFMAhCmAMAUQpgDCFABhCiBMAYQpgDAFQJgCCNOnMhqN2u12bh/+UHmc09NTTYr6F6bL6OTkpLp9uMvLS02K+hemS+fq6irH0s3NzdxmWYOg/hGm9z8s7+3t1Q/OGa3s7Oy0rw2Hw1Jz1Zqtra3cZuXFxUW/389yp9O5cWAfDAb1u8O81H9StSry1dXVMmy/rf6zQdksy8tc/8K0VUqn2+3myLyyslI/3ZPqGY/HR0dH+/v7GbmkOHL79lq1Qapqe3t7Mplks5RafYCT9bn7y5cvc/cbdQZNrv9SxlmTAu71eqn8Eo4frP/d3d3Uf6o99V9/2KWr/8m9ra9Pcvezs7tu/s/J2X8mzZR2qAqiapMsJB/ry/U15dsUyo32LGvKZllOIZb11R2btePnn7J1Xus0Tl537vF2+cc81X8p73qp33hH3Fb/9c0aXv95OfKizJCeaatcwSxXM8sY5yPXNHPofn9lDtRVg+ZgXlbmGF4dtDUyC1z/6X7Wc3lp61+YTk/6pERKKaQsypoPbpmgHA6HqZKMbkrZZU3GR+UkQFbW71gNlGZ1hRQaWP+5b4b/WZP1S17/wnR6HM7xszrwZrk6Micoq82ynKFKNlhdXe10OvVxfeqmrEyqVhunjDJoyvryaB88pEMz6/9G5VdD9dvqP2uq61TLW//Omd5dhvMpnbKQQun1evN+Is85U+dMl7b+nTP9zAOi8mmPHG/z7fHxsTZB/VM80wR3t31NO6D+cc4UQJgCCFMAYQqAMAUQpgDCFECYAiBMAYQpgDAFEKYACFMAYQown550Cr43/9XgLC/1v9gvx9OF6dqfWz/9Ov2iOda/0AZPVf9/af10Nf2iUS/KXIbpD3/12rG81P/Cc84UQJgCCFMAYQqAMAUQpgDCFECYAiBMAYQpgDAFEKYAfNyDJzp5/rz15ZfacSn8asoveLww/flnjQjQnkwm97zrmzfP/za1tramHZdIBiJecZhlmALwBxegAIQpwAKEabvd1oIAeqYAwhRgMcLUJwEA9EwBhCnAwoSpq/kAxbNHetyNjY3Xr19r38VzdnaWF1c7wCzD9OMXoJrzrksPeo6ulR0cHFS3TSNG4VGG+QAIU4BmhKkLUAB6pgDC9AG96WJ1dfXeD3J6etrpdB7yNPIIV1dXs9214XBYdm0wGKhsmKcwndM/J3358mWe+du3b+/9CL1e7/j4+CHPYWtr6+LiYoY7dXl5ub+/n53Kru3t7als0DN9OicnJ+lgpoeYGOr3+0m3dOuykNv8KBtkTTqw2WY0GpVebUJwZ2cnyVXSsNo+ncFsmYWy5ft3zL3ybdkg9y15Wn7LTKysrJQ9yu50u908w/LE8jTSC87vyjPMj6qnBMzY5HGsr6+fnZ1NmqG+m9WOb25u5tvt7e0sJInG43F6rKXfWhby0/RAj46OSh+23DedvnxbbZnb8/PzspD1pbv6wTseHh5modqg6iC/7+/X7rGbecDEaPYlC3kC1W/Myuxd1mdPs78L87JCozzoQ/vz9WH4+jA/sVKWkzjpuyUiS8+uhGx1WjMdzHL+MT8to/L8tPT76kP+bJmF+vr375jNqv7jI8lzS3wPh8P0gtMJze9Nj7v80tjd3c2PHnJyAzDMv1UiLxmUkW89B0s4ltxMB7OcYC1peEd3ueNsg7WkZ/nVZaRfeqblOWTvkqTplro2BcJ0Zra2tspV75Kh6aim11bOY8bOtTJyzxg5nbtyxrOegPXbDy58/I6RXOv3+zM8Z5oALfuV35snnyeQBy+7mTV5Gul9Z2UCN6mq7mHmHmucvrGxcXBwMF9/m18u1Hz2ExcN/9v85rysoGfaUI96QhMQpsui1+v5RyzAZwjTDPdevXqlEQFaD/zUYR6hfCiy/oBnZ2dfffWVtl1IL1688IlCmPHnTOvd0nqepsf69ddf//jjjyaHvoeGX4BaW1tzRIEZD/MBEKYASxmmZWIRrxkgTFudTqf6W6NPNfMJQO+hzBfV/EyfybStQEPDtMyInNv6RCHzJc+82+3OxVN9+LStQEPD9OTkZHt7u9frlb9JvzHLZ+uPGezLxKAZ1N+YlLN6nMFgUP7k/Onbq8xip26Azx+mUU3wkWAdj8fHx8dlNqOMoLNcJhlJHzZRW+bfPDw8rE93VCYVHQ6HTRj4N1Y5HWGaKHgaz57sN5UxfjWLUhnp12f5rCa+q+5yca2alLMeymXqo/y0vj03hvkaBxawZ5oELJPbR7fbfX/2ufLOL1MylzU3JuWsUjjxen5+7sUDljRMq3/0tru7W8L0xiyfR0dH5Z8slW9vTMpZNkvCJnb7/X7rM83zNC+TS5kECxZzmD8ej6vlvWvVt9V0TaXrWuYVLR3VGz3Q6r8nfcYmm4vJpUx/BQvbM72L0WhULvE/8B8pAyx1mJYzpOnD+vgRIEwBhCkAn+6xLkD98ssv3377bXP2c+5mSPn+++9VJ8yRtsu+AIb5AMIUQJgCIEwBhCmAMAUQpgAIUwBhCiBMAYQpAMIUQJgCCFOA5fA/AQYAg6h5Eer1D8gAAAAASUVORK5CYII=" alt />
<p class="caption">The difference between single and double bracket
subscript operators</p>
</div>
<p>The single bracket operator makes a new list containing a specified
subset of elements in the original list, while the double bracket
operator extracts the object at the given position. So in the figure
<code>x[1]</code> is a <code>neuronlist</code> object of length 1,
whereas <code>x[[1]]</code> is the <code>neuron</code> object at the
first position in the list.</p>
<div id="worked-examples" class="section level3">
<h3>Worked Examples</h3>
<p>Let us start by extracting the first five neurons from our sample
data.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># we can select neurons by indexing </span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>first5<span class="ot">=</span>Cell07PNs[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(first5)</span></code></pre></div>
<pre><code>##        root nodes segments branchpoints endpoints cable.length
## EBH11R    1   180       33           16        18     297.1763
## EBH20L    1   200       26           12        15     327.0929
## EBH20R    1   199       25           12        14     347.6153
## EBI12L    1   169       23           11        13     294.4680
## EBI22R    1   160       27           13        15     303.0150</code></pre>
<p>Each neuron in the neuronlist has an associated name which can be
used to select it. We can get the names of all neurons using the
<code>names</code> function.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(Cell07PNs)</span></code></pre></div>
<pre><code>##  [1] &quot;EBH11R&quot; &quot;EBH20L&quot; &quot;EBH20R&quot; &quot;EBI12L&quot; &quot;EBI22R&quot; &quot;EBJ23L&quot; &quot;EBJ3R&quot;  &quot;EBN19L&quot;
##  [9] &quot;EBO15L&quot; &quot;EBO53L&quot; &quot;ECA34L&quot; &quot;ECB3L&quot;  &quot;LI23L&quot;  &quot;LIC2R&quot;  &quot;LJ5L&quot;   &quot;MC3B&quot;  
## [17] &quot;MH16L&quot;  &quot;MM14L&quot;  &quot;NA7L&quot;   &quot;NH15L&quot;  &quot;NH29B&quot;  &quot;NI16L&quot;  &quot;NIA8L&quot;  &quot;NIA8R&quot; 
## [25] &quot;NNA9L&quot;  &quot;NNC4R&quot;  &quot;NNE1L&quot;  &quot;OFD2L&quot;  &quot;OKC9R&quot;  &quot;SDD8L&quot;  &quot;SH21L&quot;  &quot;SL20L&quot; 
## [33] &quot;TKC8R&quot;  &quot;TL4R&quot;   &quot;TS7L&quot;   &quot;TT27R&quot;  &quot;VA15R&quot;  &quot;VA20R&quot;  &quot;VB37L&quot;  &quot;VB58L&quot;</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>nl3<span class="ot">=</span>Cell07PNs[<span class="fu">c</span>(<span class="st">&quot;EBH11R&quot;</span>, <span class="st">&quot;EBH20L&quot;</span>, <span class="st">&quot;EBH20R&quot;</span>)]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(nl3, Cell07PNs[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>You can also use the <code>$</code> operator to access a single
neuron e.g.<code>Cell07PNs$EBH11R</code>. This can be quite useful when
working interactively in the console because RStudio will offer to
autocomplete the neuron name when you start typing past the
<code>$</code> symbol, but is not recommended for scripts.</p>
</div>
<div id="metadata" class="section level3">
<h3>Metadata</h3>
<p>The names of neurons are also used to index a <code>data.frame</code>
object attached to the neuronlist with one row for each neuron. You can
use the <code>head</code> function to give a summary of the attached
metadata in this neuronlist. Using the <code>as.data.frame</code> method
on a neuronlist allows you to extract this attached metadata to a
separate object.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(Cell07PNs)</span></code></pre></div>
<pre><code>##         Brain RegistrationScore Notes Glomerulus Batch Directory Traced
## EBH11R EBH11R                 4              DA1   PN2    unsure    yes
## EBH20L EBH20L                 4              DL3   PN2   unsure2    yes
## EBH20R EBH20R                 4              DA1   PN2   unsure2    yes
## EBI12L EBI12L                 4              DA1   PN2   unsure3    yes
## EBI22R EBI22R                 4              DL3   PN2   unsure3    yes
## EBJ23L EBJ23L                 4              DL3   PN2   unsure4    yes
##        Scored.By Sex Include     ID HaveWarp HaveAsc
## EBH11R       ACH   M         EBH11R     TRUE    TRUE
## EBH20L       ACH             EBH20L     TRUE    TRUE
## EBH20R       ACH   M         EBH20R     TRUE    TRUE
## EBI12L       ACH   F         EBI12L     TRUE    TRUE
## EBI22R       ACH             EBI22R     TRUE    TRUE
## EBJ23L       ACH             EBJ23L     TRUE    TRUE
##                                                 TraceFile AscBatch Status
## EBH11R /GD/projects/PN2/TransformedTraces/DA1/EBH11R.tasc      New       
## EBH20L /GD/projects/PN2/TransformedTraces/DL3/EBH20L.tasc      New       
## EBH20R /GD/projects/PN2/TransformedTraces/DA1/EBH20R.tasc      New       
## EBI12L /GD/projects/PN2/TransformedTraces/DA1/EBI12L.tasc      New       
## EBI22R /GD/projects/PN2/TransformedTraces/DL3/EBI22R.tasc      New       
## EBJ23L /GD/projects/PN2/TransformedTraces/DL3/EBJ23L.tasc      New       
##        GlomSeq NumNAs MBP1 MBP2 LHBP PNType Seq nTrees StartPoint
## EBH11R       1      0   34   48   75    iPN  13      1          1
## EBH20L       1      0   29   29   77    iPN  15      1          1
## EBH20R       2      0   24   80  147    iPN  16      1          1
## EBI12L       3      0   29   59   89    iPN  18      1          1
## EBI22R       2      0   34   34   56    iPN  20      1          1
## EBJ23L       3      0   23   23   52    iPN  21      1          1
##                  CreatedAt
## EBH11R 2006-01-17 15:21:14
## EBH20L 2006-01-17 15:21:14
## EBH20R 2006-01-17 15:21:14
## EBI12L 2006-01-17 15:21:15
## EBI22R 2006-01-17 15:21:15
## EBJ23L 2006-01-17 15:21:15
##                                                                                             WarpFile
## EBH11R  /GD/projects/PN2/allreg/warp/unsure/average-goodbrains_EBH11R101_warp_m0g40c4e1e-1x16r3.list
## EBH20L /GD/projects/PN2/allreg/warp/unsure2/average-goodbrains_EBH20L101_warp_m0g40c4e1e-1x16r3.list
## EBH20R /GD/projects/PN2/allreg/warp/unsure2/average-goodbrains_EBH20R101_warp_m0g40c4e1e-1x16r3.list
## EBI12L /GD/projects/PN2/allreg/warp/unsure3/average-goodbrains_EBI12L101_warp_m0g40c4e1e-1x16r3.list
## EBI22R /GD/projects/PN2/allreg/warp/unsure3/average-goodbrains_EBI22R101_warp_m0g40c4e1e-1x16r3.list
## EBJ23L /GD/projects/PN2/allreg/warp/unsure4/average-goodbrains_EBJ23L101_warp_m0g40c4e1e-1x16r3.list</code></pre>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>df<span class="ot">=</span><span class="fu">as.data.frame</span>(Cell07PNs)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">nrow</span>(df)</span></code></pre></div>
<pre><code>## [1] 40</code></pre>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># rownames of data.frame are the same as names of Cell07PNs list.</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="fu">all.equal</span>(<span class="fu">rownames</span>(df), <span class="fu">names</span>(Cell07PNs))</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>You can use columns in the attached metadata in expressions that
select or operate on the neurons in the list. In the next two examples
we</p>
<ul>
<li><code>subset</code> the neurons in a neuronlist based on a metadata
column</li>
<li>use the <code>with</code> function to carry out a calculation using
column(s) of metadata.</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># subset.neuronlist method (which you call using the subset function)</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>da1n<span class="ot">=</span><span class="fu">subset</span>(Cell07PNs, Glomerulus<span class="sc">==</span><span class="st">&quot;DA1&quot;</span>)</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co"># with.neuronlist method</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="fu">with</span>(Cell07PNs, <span class="fu">table</span>(Glomerulus))</span></code></pre></div>
<pre><code>## Glomerulus
##  DA1  DL3 DP1m VA1d 
##   11   10    8   11</code></pre>
<p>There is a second approach to accessing this attached metadata
data.frame, using the square bracket operator with two arguments as used
for subscripting (2D) matrices or <code>data.frames</code>. For example
we can access the <code>Glomerulus</code> column like so:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>Cell07PNs[, <span class="st">&#39;Glomerulus&#39;</span>]</span></code></pre></div>
<pre><code>##  [1] DA1  DL3  DA1  DA1  DL3  DL3  VA1d VA1d VA1d VA1d DP1m DP1m DA1  DL3  VA1d
## [16] VA1d DL3  DA1  DA1  VA1d VA1d VA1d DL3  VA1d DP1m DP1m DP1m DP1m DP1m DP1m
## [31] DA1  DL3  DL3  DL3  VA1d DA1  DA1  DA1  DL3  DA1 
## Levels: DA1 DL3 DP1m VA1d</code></pre>
<p>This approach has some features that make for additional flexibility.
For example you can acess the whole data.frame like so:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(Cell07PNs[,])</span></code></pre></div>
<p>The form <code>[,]</code> which includes a comma implies two
(missing) arguments. <strong>nat</strong> therefore interprets this as
request for the 2D data.frame attached to Cell07PNs rather than the
neuronlist itself. You can also use this notation to add new columns or
modify existing columns in place.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>Cell07PNs[, <span class="st">&#39;NewColumn&#39;</span>] <span class="ot">=</span> somevariable</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>Cell07PNs[, <span class="st">&quot;Sex&quot;</span>] <span class="ot">=</span> <span class="fu">sub</span>(<span class="st">&quot;F&quot;</span>, <span class="st">&quot;female&quot;</span>, Cell07PNs[, <span class="st">&quot;Sex&quot;</span>])</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>Cell07PNs[, <span class="st">&quot;Sex&quot;</span>] <span class="ot">=</span> <span class="fu">sub</span>(<span class="st">&quot;M&quot;</span>, <span class="st">&quot;male&quot;</span>, Cell07PNs[, <span class="st">&quot;Sex&quot;</span>])</span></code></pre></div>
<p>You can also access selected rows of the data.frame in the normal
way:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>Cell07PNs[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>, <span class="st">&quot;Glomerulus&quot;</span>]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>Cell07PNs[Cell07PNs[, <span class="st">&quot;Sex&quot;</span>]<span class="sc">==</span><span class="st">&quot;F&quot;</span>, <span class="st">&quot;Glomerulus&quot;</span>]</span></code></pre></div>
</div>
<div id="working-on-all-the-neurons-in-a-neuronlist" class="section level3">
<h3>Working on all the neurons in a neuronlist</h3>
<p>There are quite a few methods defined for the <code>neuronlist</code>
class:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">methods</span>(<span class="at">class =</span> <span class="st">&quot;neuronlist&quot;</span>)</span></code></pre></div>
<pre><code>##  [1] *                  +                  -                  /                 
##  [5] [                  [&lt;-                as.data.frame      as.neuronlistfh   
##  [9] c                  data.frame&lt;-       dimnames           dotprops          
## [13] droplevels         head               intersect          mirror            
## [17] nvertices          plot               plot3d             potential_synapses
## [21] prune              setdiff            subset             summary           
## [25] tail               union              with               xform             
## [29] xyzmatrix          xyzmatrix&lt;-       
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>For example we can scale the position (and diameter) of all of the
neurons in a neuronlist using the <code>*</code> operator:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># convert from microns to nm</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>Cell07PNs.nm <span class="ot">=</span> Cell07PNs<span class="sc">*</span><span class="fl">1e3</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs.nm)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>There is also a more powerful <code>xform</code> function that allows
arbitrary transformations to be applied. For example here we apply a 3D
rotation expressed as a homogeneous affine matrix:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># define a 180 degree rotation around the x axis</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>rotm<span class="ot">=</span><span class="fu">cmtkparams2affmat</span>(<span class="at">rx=</span><span class="dv">180</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="co"># remove tiny values due to rounding errors</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>rotm<span class="ot">=</span><span class="fu">zapsmall</span>(rotm)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(<span class="fu">xform</span>(Cell07PNs, rotm))</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAEgCAYAAABsPKAhAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAeCgAwAEAAAAAQAAASAAAAAATIqLkQAAQABJREFUeAHsnQV8FOfTx39ncXeDAMETLLi7F3eKFytFipVixVroS7FSKAXa4lAKpRQoDsXdPWgICSHudpe7fefZIyEU/qUC5BLm4bO5vZVnn+e7x87OPDPzKCQq4MIEmAATYAJMgAm8VQLKt3o1vhgTYAJMgAkwASYgE2ABzD8EJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QIAFcC5A50syASbABJgAE2ABzL8BJsAEmAATYAK5QECdC9fkSzKBd57AvHnzsGPHjldyaNOmDUaMGCEfN3/+fGzfvv2Fc9RqNaysrFC6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" /><!-- --></p>
<p>More generally any function that works on a neuron can be applied to
a neuronlist by using the function <code>nlapply</code>. This is an
analogue to base Rs <code>lapply</code> function. This will take care
of returning a new neuronlist with the attached metadata and includes
additional features such as error tolerance, progress bars and
parallelisation for multi-core machines. It is worth reviewing the help
and examples for this function carefully if you start to work regularly
with neuronlists.</p>
</div>
</div>
<div id="plots" class="section level2">
<h2>Plots</h2>
<p>We have already seen that we can plot a single neuron (the first)
like so:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs[[<span class="dv">1</span>]])</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>The purple node higlights the root or soma of the neuron, red nodes
are branch points, green nodes are end points. We can also label each
node with its <code>PointNo</code> index.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs[[<span class="dv">1</span>]], <span class="at">col=</span><span class="st">&#39;red&#39;</span>, <span class="at">WithText=</span>T)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwAAAAGACAYAAAAargV/AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAwCgAwAEAAAAAQAAAYAAAAAA8BDjYgAAQABJREFUeAHsnQmcTeUbx3/n3LHvS5Ql+5Jki+x/kbShIqRsWZItFaVC1lCJihKprJGlQouEVKhESZZQsmffs8455/973uuO2WcwM+bOPI/PnXvuOe/ZvufOeJ/3fZ7fY3k0qCkBJaAElIASUAJKQAkoASWQKgjYqeIu9SaVgBJQAkpACSgBJaAElIASMATUAdAvghJQAkpACSgBJaAElIASSEUE1AFIRQ9bb1UJKAEloASUgBJQAkpACagDoN8BJaAElIASUAJKQAkoASWQigioA5CKHrbeqhJQAkpACSgBJaAElIASUAdAvwNKQAkoASWgBJSAElACSiAVEVAHIBU9bL1VJaAElIASUAJKQAkoASWgDoB+B5SAElACSkAJKAEloASUQCoioA5AKnrYeqtKQAkoASWgBJSAElACSkAdAP0OKAEloASUgBJQAkpACSiBVERAHYBU9LD1VpWAElACSkAJKAEloASUgDoA+h1QAkpACSgBJaAElIASUAKpiIA6AKnoYeutKgEloASUgBJQAkpACSgBdQD0O6AElIASUAJKQAkoASWgBFIRAXUAUtHD1ltVAkpACSgBJaAElIASUALqAOh3QAkoASWgBJSAElACSkAJpCIC6gCkooett6oElIASUAJKQAkoASWgBNQB0O+AElACSkAJKAEloASUgBJIRQTUAUhFD1tvVQkoASWgBJSAElACSkAJqAOg3wEloASUgBJQAkpACSgBJZCKCKgDkIoett6qElACSkAJKAEloASUgBJQB0C/A0pACSgBJaAElIASUAJKIBURUAcgFT1svVUloASUgBJQAkpACSgBJaAOgH4HlIASUAJKQAkoASWgBJRAKiKgDkAqeth6q0pACSgBJaAElIASUAJKQB0A/Q4oASWgBJSAElACSkAJKIFUREAdgFT0sPVWlYASUAJKQAkoASWgBJSAOgD6HVACSkAJKAEloASUgBJQAqmIgDoAqehh660qASWgBJSAElACSkAJKAF1APQ7oASUgBJQAkpACSgBJaAEUhEBdQBS0cPWW1UCSkAJKAEloASUgBJQAuoA6HdACSgBJaAElIASUAJKQAmkIgIhqehe9VaVgBJQAimCwKhRo/D555/HeS/3338/evbsadqNHj0aCxYsiLJPSEgIMmbMiDJlyuCxxx5DiRIlwtocPXoUTZs2NZ9r166NQYMGhW0LLLRs2RL79+9H7ty5MWvWrMDqCO/z58/H4MGDzbrvvvsOmTJlirA9/IfY2sZ2D5kzZ0b+/PnRqFEjNGjQIPwhdVkJKAEloAQiEVAHIBIQ/agElIASSO4E/vzzT3z77bdxXmbp0qXD2mzZsiXWfebNm4eRI0dCOuB333232e/8+fNh+2TPnj3sWOEXVq5ciZ07d5rOd/j1geXt27ejbdu2OHbsmFnlOE5gU5T3uNrGdQ9ywLfffhv9+/eP1lmJckJdoQSUgBJIpQTUAUilD15vWwkogZRB4OGHH0auXLmivRkZtY/OpEN+3XXXwfM8hIaG4tdff8UPP/yACxcuoE2bNmZE37Ks6Ha9rHXr1q1D69atwzr/se18OW3lOC1atDCzDnIPruti27ZtWLRokbknmW1o3Lgxbr311thOqduUgBJQAqmWgDoAqfbR640rASWQEgj069cPN99882XdyjPPPINy5cpF2KdZs2aYM2cODh48iE2bNpmQoAgNLvNDly5d8N577yG2Ef/AIS+nbWCfF198Mco9SMd/wIABpsnXX3+tDkAAlr4rASWgBCIR0CTgSED0oxJQAkogNRIIhPikS5cOhQoVumoEEydONCPzHTp0QPPmzWM93uW0je1A4Uf89+7dG1tT3aYElIASSNUEdAYgVT9+vXkloASCnYDE7q9evTra25AE3bRp00bZJnH7//77rwmXkbCf5cuXY9q0aaadhABFl6S7Z88ezJ49O8qxTp8+HWWdrKhWrRokWblKlSro0aNHtG0CKy+nbWCfyO8HDhzAm2++GbZazqumBJSAElAC0RNQByB6LrpWCSgBJRAU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hbBf1gIFgORk5xSKR0oBClCAAhSgAAWiLBD2nirKx5Tl7qtUqWIi/CTLjd+WLVugrf5HpRvImWeeifISAUafCDA5X6DLkItQ7rTTjhdkW9gCWY0bwv7yK+DO28Ou50IKUIACFKAABShAgVABR1YAAkUoIK2/WhnQH00+iRLz559/Blbzt8MFTtz8Z1wQq+ll8Pd/JOMMXEMBClCAAhSgAAUoECLguEHAevR6k//SSy+ZEJ+//PKLKdCgQYNQtmxZ8wRAnwR89tlnIQXlm/gUsM46CzitNOyl38dnAVkqClCAAhSgAAUokMMCjnsCoDf/DRs2NF1/9AnACy+8gBEjRmDkyJFo06YN6tWrh/fee8+8XrJkCerWrZvDZNxcLAnYq1YD+/4G6iTG0mHxWChAAQpQgAIUoEDMCjiuAjBq1CgUL14cOiOwTgR277334q677sLAgQODk37dd999uPTSS6GThk2ePPmk8H///Xd8++23WX5Gxxz8+++/WeZjhtwV8D87Gp77esHScKBMFKAABShAAQpQgAJZCjiuArB06VIzyZd289H06KOPYtKkSWjfvn1IYTVC0Lhx40KWRfLmr7/+imiegXwSfjKjmYgj2Q/z/HcBe9s2MwDYwxmA/zsmt0ABClCAAhSggGsEHFcBqF27NlatWhU8Qeeff75p6S9RokRwmb5YsWIFypQpE7IskjfavUh/skpr167FhRdemFU2rs8lAVvCv/p73w+rc0dYac59Lu2Sm6UABShAAQpQgAJxIeC4QcDa0q99/Lt164atW7eak/DAAw8EZ/39448/0Lt3b7z99tvQScOY4lPAf0cPMwGY57ln4rOALBUFKEABClCAAhTIJQHHPQHQ1vkPP/wQjz32GLS/foUKFUJodBbgsWPHom/fvqaSELKSbxwr8MTiBsFj9z/5NOzVa+CdPxuWzADNRAEKUIACFKAABSgQuYDjKgBatBtvvBHXXXedifuftqidOnUyMwRrSFCm+BPwT/oA/tfehHfJAlhFisRfAVkiClCAAhSgAAUokMsCjqwAqInX6zU/aX3KlSuXdhHfx4mAvX07/L36wLt2JSxW8OLkrLIYFKAABShAAQrktQD7T+S1OPeXbQF7udz4167Fm/9sC/KDFKAABShAAQpQAGAFgN8CxwjYn38J67prHXO8PFAKUIACFKAABSgQiwKO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6NG45JJLULRoUTRp0gTfffddSJ5Irg2R5AnZKN+cEJBaFZOLBQ4fPmz36NFDm/btLl26hEjIhc6uV6+eLTej9gcffGBPnz7dlj88doUKFey///47mLd37972OeecY8sfJFv+yNu1a9e2ExMTbf08k21//vnnQV+5ibRfffVVY3rBBRfYR44cMURyM2WW3XLLLfby5cvtt956y5YbT3vYsGFBwkjyBDO79EXnzp1tqUDZTz75pL148WL70UcftaUiYA8YMCAoEkke/R4XKFDAfumll2y5aTL/RgoWLGivWrUquB23v4jEMWD077//2meffbb5d6C2qROvH6k10r+WxhS7XLly9oUXXmhPnDjRnjlzpn3ttdfacvNp//DDD+YDeh0/66yzbKmo2rNnz7blhtSWBhlbGhSCG+T1I0iR4YtIrtUjRoywLcsy15glS5bYd955p/lez5gxI7hdXj+CFBm+GDNmjF2iRAl77Nix9qJFi2xpFLOlkdH++eefg5+J5NoQSZ7gBvkiREC7bDC5VGDZsmV2jRo17FNOOcUuU6ZMugrAunXrzIXtjTfeCArphU0rC3qh1LR69WpbWvXsTz/9NJhHWqvSXRCDK1344uqrr7alRS6kQqQVKnUM3AwNGjTIltY9+9ChQ0GhwYMH26VLl7b1j7umSPIEP+zCF/v27TPfRWn5DCm9PMEy329dGEkezVe9evWQmyddJk9w7Ntuu01fuj5F6hiA0kaG888/P+Q7r+t4/QgIZfxbr796rVi6dGkwkzbASKup3atXL7NMGxW04rtly5Zgni+//NI01siTAbOM148gTYYvIrlW16lTx9Z8gSRPF00F7dZbbw0s4vUjKBH+xcGDB+2yZcvaDz74YDCDfqe1AqCNN5oiuTZEkie4A75IJ8AuQHJldWt6/fXXIS1LpluJdjlJm6RiYB7Z//PPP8FVga4U+ihakz6GlpZStGjRIphHbp5QtWpVyB+g4DI3v5AWIowfPx7SahRkkNZQ81oueua3tOoZQ2llDua54YYbsGvXLnz//fcR5wl+2IUvdBzLyy+/jLvvvjuk9GotLdBmfEokebRrlrRCoVWrViHb0fMhT8FClrn1TSSOARtpkcbkyZPxwgsvBBYFf/P6EaTI8IW0/JvvtTyNDebR6680DiBw/ZgwYQK0W6E8nQ3m0S5DUiHA6aefbpZF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" /><!-- --></p>
<p>Multiple neurons can be plotted by passing a whole neuronlist or
indexing it</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwAAAAGACAYAAAAargV/AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAwCgAwAEAAAAAQAAAYAAAAAA8BDjYgAAQABJREFUeAHsnQd8U9UXx39JoGzZe++99x4iKiobVECGiIj8RZaishFkiKCIAxQBUVERZIgCAjJkoyB7yBaRvVfb5P5/54VAZ5qWFtL2nH5eX/Lmvd+XtOfce4bNUKCiBJSAElACSkAJKAEloASUQKIgYE8UvdROKgEloASUgBJQAkpACSgBJWARUANAPwhKQAkoASWgBJSAElACSiAREVADIBE9bO2qElACSkAJKAEloASUgBJQA0A/A0pACSgBJaAElIASUAJKIBERUAMgET1s7aoSUAJKQAkoASWgBJSAElADQD8DSkAJKAEloASUgBJQAkogERFQAyARPWztqhJQAkpACSgBJaAElIASUANAPwNKQAkoASWgBJSAElACSiAREVADIBE9bO2qElACSkAJKAEloASUgBJQA0A/A0pACSgBJaAElIASUAJKIBERUAMgET1s7aoSUAJKQAkoASWgBJSAElADQD8DSkAJKAEloASUgBJQAkogERFQAyARPWztqhJQAkpACSgBJaAElIASUANAPwNKQAkoASWgBJSAElACSiAREVADIBE9bO2qElACSkAJKAEloASUgBJQA0A/A0pACSgBJaAElIASUAJKIBERUAMgET1s7aoSUAJKQAkoASWgBJSAElADQD8DSkAJKAEloASUgBJQAkogERFQAyARPWztqhJQAkpACSgBJaAElIASUANAPwNKQAkoASWgBJSAElACSiAREVADIBE9bO2qElACSkAJKAEloASUgBJQA0A/A0pACSgBJaAElIASUAJKIBERUAMgET1s7aoSUAJKQAkoASWgBJSAElADQD8DSkAJKAEloASUgBJQAkogERFQAyARPWztqhJQAkpACSgBJaAElIASUANAPwNKQAkoASWgBJSAElACSiAREVADIBE9bO2qElACSkAJKAEloASUgBJQA0A/A0pACSgBJaAElIASUAJKIBERUAMgET1s7aoSUAJKQAkoASWgBJSAElADQD8DSkAJKAEloASUgBJQAkogERFQAyARPWztqhJQAkpACSgBJaAElIASUANAPwNKQAkoASWgBJSAElACSiAREUiSiPqqXVUCSkAJJAgC48ePx08//RRlX5o2bYpXX33VOm7ChAlYuHBhuHOSJEmClClTokSJEujcuTMKFy5855gLFy6gZcuW1vvatWtj2LBhd/Z5Xjz77LM4deoUMmXKhO+//96zOdR6wYIFGD58uLVt1apVSJUqVaj9Id94O9ZbH1KnTo2cOXPiqaeeQqNGjUJeUl8rASWgBJRAGAJqAIQBom+VgBJQAv5OYO/evfjtt9+ibGaxYsXuHLN//36v58yfPx/jxo2DKOCPPfaYdV5gYOCdc9KlS3fnWiFfrFu3DseOHbOU75DbPa+PHDmCjh074uLFi9Ymp9Pp2RVuHdWxUfVBLvjRRx9h0KBBERor4W6oG5SAElACiZSAGgCJ9MFrt5WAEkgYBJ555hlkzJgxws7IqH1EIgp55syZYYxBcHAw/vzzT6xZswZBQUHo0KGDNaJvs9kiOjVa27Zv347nnnvujvLv7eToHCvXefrpp61ZB+mDy+XCoUOHsHTpUqtPMtvQpEkTVKxY0dstdZ8SUAJKINESUAMg0T567bgSUAIJgcDAgQNRsmTJaHWlT58+KFOmTKhzWrdujR9++AFnzpzBnj17LJegUAdE80337t3x2WefwduIv+eS0TnWc85bb70Vrg+i+A8ZMsQ6ZMmSJWoAeGDpWgkoASUQhoAGAYcBom+VgBJQAomRgMfFJ1myZMibN+89I/j888+tkfkuXbqgTZs2Xq8XnWO9XSjkiP+///7r7VDdpwSUgBJI1AR0BiBRP37tvBJQAvGdgPjub9myJcJuSIBuQEBAuH3it3/y5EnLXUbcfn7//Xd89dVX1nHiAhRRkO6JEycwe/bscNe6fv16uG2yoVq1apBg5cqVK+OVV16J8BjPxugc6zkn7Pr06dP44IMP7myW+6ooASWgBJRAxATUAIiYi25VAkpACcQLAgMGDIi0nZIRJ0OGDOH2i8tNRCJ+9ZMnT45oFzZt2hTlSH7IEyWmwFeJzrGea0p8g8PhsGYZbt26hZs3b3p2oXr16mjfvv2d9/pCCSgBJaAEQhNQAyA0D32nBJSAEohXBGS0XhThiCS6gbwSAyDuP5LuM3ny5OEuabeH9xqVANwHIZcvXw532woVKlhpS/v16xcpk3An6QYloASUQCIkEP6veSKEoF1WAkpACcRXAhs3bsSlS5ciXNKnTx9ht7Zu3WoF50oGoKtXr0LSa7Zq1craNnbsWIhPflhp3ry5tV+CekMuefLkCXvofXkvMxWzZs2y2u25Ye7cudGjR48I3Z48x+haCSgBJaAEADUA9FOgBJSAEkhkBGQkXxaZOZAZBCn+JQq1Z8ZAZgL8XSRuQFKgSlyCpDUVkXiIhg0bhnIH8vd+aPuUgBJQAg+CgBoAD4K63lMJKAEl4GcEJP2n5NQXuXLlip+1zntzJk2ahAIFClgHSUC0pEZVUQJKQAkogcgJaAxA5Gx0jxJQAkrA7wksX74cBw4ciLCdqVOntkbEw+5csWKFVThLtosbkCj/ITPo1K1bN+wpfv1e+jl9+nRIu8WIef/9961CYZoJyK8fmzZOCSiBB0hADYAHCF9vrQSUgBK4VwKvvvpqpJcoUqQI9u3bF25/7969w23zbBB3oPg4gi5ZgXr27GkZMhKj0K1bN2zevFmDgT0PVtdKQAkogRAE1AUoBAx9qQSUgBJITATE5z9p0qR34gD69+8PmVGIKHVofOAyatQoK55B2iqBzjIToKIElIASUALhCdg4Xep2+gy/T7coASWgBJSAElACSkAJKAElkMAI6AxAAnug2h0loASUgBJQAkpACSgBJeCNgBoA3ujoPiWgBJSAElACSkAJKAElkMAIqAGQwB6odkcJKAEloASUgBJQAkpACXgjoAaANzq6TwkoASWgBJSAElACSkAJJDACagAksAeq3VECSkAJKAEloASUgBJQAt4IqAHgjY7uUwJKQAkoASWgBJSAElACCYyAGgAJ7IFqd5SAElACSkAJKAEloASUgDcCagB4o6P7lIASUAJKQAkoASWgBJRAAiOgBkACe6DaHSWgBJSAElACSkAJKAEl4I2AGgDe6Og+JaAElIASUAJKQAkoASWQwAioAZDAHqh2RwkoASWgBJSAElACSkAJeCOgBoA3OrpPCSgBJaAElIASUAJKQAkkMAJqACSwB6rdUQJKQAkoASWgBJSAElAC3gioAeCNju5TAkpACSgBJaAElIASUAIJjIAaAAnsgWp3lIASUAJKQAkoASWgBJSANwJqAHijo/uUgBJQAkpACSgBJaAElEACI6AGQAJ7oNodJaAElIASUAJKQAkoASXgjYAaAN7o6D4loASUgBJQAkpACSgBJZDACKgBkMAeqHZHCSgBJaAElIASUAJKQAl4I6AGgDc6uk8JKAEloASUgBJQAkpACSQwAmoAJLAHqt1RAkpACSgBJaAElIASUALeCKgB4I2O7lMCSkAJKAEloASUgBJQAgmMgBoACeyBaneUgBJQAkpACSgBJaAElIA3AmoAeKOj+5SAElACSkAJKAEloASUQAIjoAZAAnug2h0loASUgBJQAkpACSgBJeCNgBoA3ujoPiWgBJSAElACSkAJKAElkMAIqAGQwB6odkcJKAEloASUgBJQAkpACXgjoAaANzq6TwkoASWgBJSAElACSkAJJDACagAksAeq3VECSkAJKAEloASUgBJQAt4IqAHgjY7uUwJKQAkoASWgBJSAElACCYxAkgTWn/vWnYkTJ+KTTz5B2rRp79s99UZKQAkoASWgBJSAElAC/k0gefLkWLhwIdKkSeO3DbUZit+2zo8bVrlyZYwYMUINAD9+Rto0JaAElIASUAJKQAncbwL169fHhg0bULZs2ft9a5/vpzMAPqMKfWCSJEnw0EMPoVq1aqF36DsloASUgBJQAkpACSiBREugSJEift93jQHw+0ekDVQCSkAJKAEloASUgBJQArFHQA2A2GOpV1ICSkAJKAEloASUgBJQAn5PQF2A/P4RaQOVgBJQAkpACSiB6BD4B0cwH9/A8Od59EJKpIrO6XqsEkjwBNQASPCPWDuoBJSAElACSiDxENiLHXgSlZAUAVan38dw/I5DyIaciQeC9lQJREFAXYCiAKS7lYASUAJKQAkoAf8ksAKLUA15UByp8QZetEb8RfkXCUKgtdhgQ0+09c8OaKuUwAMioDMADwi83lYJKAEloASUgBKIOYFd2EaVv8WdCyzAt1T1bXfee16IG9AR/O15q2sloARIQGcA9GOgBJSAElACSkAJxDsCQ/BKqDYH4hZ+wAzOBpQJZQg44EAhlAh1rL5RAomdgBoAif0ToP1XAkpA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" /><!-- --></p>
<p>More complex subsets are possible by using
<code>plot.neuronlist</code> subset argument (which works in the same
way as the <code>subset.neuronlist</code> function). For example here we
select neurons by which olfactory glomeruli their dendrites occupy:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs, <span class="at">subset=</span>Glomerulus<span class="sc">!=</span><span class="st">&quot;DA1&quot;</span>, <span class="at">col=</span><span class="st">&#39;grey&#39;</span>, <span class="at">WithNodes=</span>F, <span class="at">main=</span><span class="st">&quot;DA1 neurons&quot;</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(Cell07PNs, <span class="at">subset=</span>Glomerulus<span class="sc">==</span><span class="st">&quot;DA1&quot;</span>, <span class="at">add=</span><span class="cn">TRUE</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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rl4ECySQQDpPBGHlJ2iDaH/+hiXld4wTt2dnZ+sEExjrnF/QVCDtJ1p+k2CBLjPkLMBvzp84uY1RAfu7o9xGAiRAAiRAAiEmwCCsEAPm6UmABEiABEjAHwEqYH9UuI0ESIAESIAEQkyACjjEgHl6EiABEiABEvBHgArYHxVuIwESIAESIIEQE6ACDjFgnp4ESIAESIAE/BGgAvZHhdtIgARIgARIIMQEqIBDDJinJwESIAESIAF/BKiA/VHhNhIgARIgARIIMQEq4BAD5ulJgARIgARIwB8BKmB/VLiNBEiABEiABEJMgAo4xIB5ehIgARIgARLwR4AK2B8VbiMBEiABEiCBEBOgAg4xYJ6eBEiABEiABPwRoAL2R4XbSIAESIAESCDEBKiAQwyYpycBEiABEiABfwSogP1R4TYSIAESIAESCDEBKuAQA+bpSYAESIAESMAfASpgf1S4jQRIgARIgARCTIAKOMSAeXoSIAESIAES8EeACtgfFW4jARIgARIggRAToAIOMWCengRIgARIgAT8EaAC9keF20iABEiABEggxASogEMMmKcnARIgARIgAX8EqID9UeE2EiABEiABEggxASrgEAPm6UmABEiABEjAHwEqYH9UuI0EXE7g73//u8TExMiYMWPy1HTbtm1SsmRJGTBgQJ593EACJHDlCMRYSq7c6XgmEiABpxDo2rWrZGRkyJo1a+T666/Xl52VlSUtW7bUy8uXL5ekpCSnVIfXSQKOI0AL2HG3jBdMAleGwLhx46RYsWLSq1cvycnJ0SeF1QsLeMqUKVS+VwYzz0IC+RKIz3cPd5AACbiaQEpKiowdO1buu+8+ef3116Vu3bry/vvvy3vvvSfp6emurjsrRwKRQIAu6Ei4C7wGEggjgZ49e8qMGTOkVKlS2v38+eefh/Fq+NUkED0EqICj516zpiTgl8CJEyekatWqkp2dLfv37xdYxhQSIIHQE2AfcOgZ8xtIIKIJTJs2Tc6dOye5ubkyevToiL5WXhwJuIkALWA33U3WhQQKSQABV40aNRK4oREBPXnyZFm2bJk0a9askGdicRIggcISoAIuLDGWJwGXEEDkc+vWreXw4cOyceNGbQHXq1dPypYtq4cmJScnu6SmrAYJRCYBuqAj877wqkgg5ASGDx8uq1atkg8//FBKly4t5cqV0xHQW7ZskSFDhoT8+/kFJBDtBGgBR3sLYP2jkgDczL/61a/ksccey9Pvi3HBGAe8aNEiadOmTVTyYaVJoCgIUAEXBWV+BwlEEIHTp0/LjTfeqFNRrl+/XooXL+51dT/88IPAFV2iRAnxt9+rMFdIgASCJkAFHDQ6HkgCJEACJEACwRNgH3Dw7HgkCZAACZAACQRNgAo4aHQ8kARIgARIgASCJ0AFHDw7HkkCJEACJEACQROgAg4aHQ8kARIgARIggeAJUAEHz45HkgAJkAAJkEDQBKiAg0bHA0mABEiABEggeAJUwMGz45EkQAIkQAIkEDQBKuCg0fFAEiABEiABEgieABVw8Ox4JAmQAAmQAAkETYAKOGh0PJAESIAESIAEgidABRw8Ox5JAiRAAiRAAkEToAIOGh0PJAESIAESIIHgCVABB8+OR5IACZAACZBA0ASogINGxwNJgARIgARIIHgCVMDBs+ORJEACJEACJBA0ASrgoNHxQBIgARIgARIIngAVcPDseCQJkAAJkAAJBE2ACjhodDyQBEiABEiABIInQAUcPDseSQIkQAIkQAJBE6ACDhodDyQBEiABEiCB4AlQAQfPjkeSAAmQAAmQQNAEqICDRscDSYAESIAESCB4AlTAwbPjkSRAAiRAAiQQNIF/A7YjSp+gIyfqAAAAAElFTkSuQmCC" /><!-- --></p>
<div id="d-plots" class="section level3">
<h3>3D plots</h3>
<p>So far we have only used 2D plots in this document, but especially
for interactive analysis and exploration, it is much more helpful to
have 3D plots that can be rotated, zoomed etc. <strong>nat</strong>
provides numerous functions for <a href="http://natverse.org/nat/reference/index.html#section--d-plotting-of-objects">3D
plots</a> based on the <a href="https://cran.r-project.org/package=rgl">rgl package</a>. It is
actually possible to embed fully interactive 3d figures in <a href="https://rmarkdown.rstudio.com/">rmarkdown</a> reports like this
one by setting the <a href="https://CRAN.R-project.org/package=rgl/vignettes/WebGL.html">webgl
chunk option</a>.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="fu">clear3d</span>()</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot3d</span>(Cell07PNs[[<span class="dv">1</span>]], <span class="at">col=</span><span class="st">&#39;red&#39;</span>)</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co"># set a grey background so it&#39;s easier to see extent of the webgl canvas</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="fu">bg3d</span>(<span class="at">col=</span><span class="st">&#39;lightgrey&#39;</span>)</span></code></pre></div>
<div id="rgl46032" style="width:480px;height:288px;" class="rglWebGL html-widget "></div>
<script type="application/json" data-for="rgl46032">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":7,"objects":{"13":{"id":13,"type":"points","material":{"lit":false},"vertices":"0","colors":"1","centers":"2","ignoreExtent":false,"flags":34816},"14":{"id":14,"type":"linestrip","material":{"lit":false},"vertices":"3","colors":"4","centers":"5","ignoreExtent":false,"flags":32832},"11":{"id":11,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"10":{"id":10,"type":"background","material":{},"colors":"6","centers":"7","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"12":{"id":12,"type":"background","material":{"lit":false,"back":"lines"},"colors":"8","centers":"9","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"15":{"id":15,"type":"background","material":{"lit":false,"back":"lines"},"colors":"10","centers":"11","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"7":{"id":7,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":7,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,252.683288574219],"modelMatrix":[[1,0,0,-238.201232910156],[0,0.342020153999329,0.939692616462708,-153.495361328125],[0,-0.939692616462708,0.342020153999329,-189.856597900391],[0,0,0,1]],"projMatrix":[[3.73205065727234,0,0,0],[0,3.73205065727234,0,0],[0,0,-3.86370372772217,-910.894104003906],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[186.86604309082,289.536407470703,90.3632507324219,132.709320068359,88.2039337158203,157.296997070312],"windowRect":[220,265,476,521],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/rgl/fonts/FreeSans.ttf","maxClipPlanes":6,"glVersion":2.1,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[15,13,14,11],"subscenes":[],"flags":35136}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":480,"height":288,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":34,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":34,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":34,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":245,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":245,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":8,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":9,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5121,"count":1,"type":"VEC3"}],"bufferViews":[{"buffer":0,"byteLength":408,"byteOffset":0},{"buffer":0,"byteLength":136,"byteOffset":408},{"buffer":0,"byteLength":408,"byteOffset":544},{"buffer":0,"byteLength":2940,"byteOffset":952},{"buffer":0,"byteLength":4,"byteOffset":3892},{"buffer":0,"byteLength":2940,"byteOffset":3896},{"buffer":0,"byteLength":16,"byteOffset":6836},{"buffer":0,"byteLength":3,"byteOffset":6852},{"buffer":0,"byteLength":4,"byteOffset":6855},{"buffer":0,"byteLength":3,"byteOffset":6859},{"buffer":0,"byteLength":16,"byteOffset":6864},{"buffer":0,"byteLength":3,"byteOffset":6880}],"buffers":[{"byteLength":6883,"bytes":"lfxcQ1b5yUKJWxJDtXJkQ2zkvkKn7xBDZodjQ7ImuEL3FRNDe5V6Qx/UwUJ+mwpD3F96Q8Gt\nvELAnglDWueDQ1ppx0JaovVCOCKFQ9sxyEKvqOxCu2CFQ31exkI63OhCFwSIQzXy0UINvNFC\nayWIQ1de0EI9781C9WaJQ5qxzUKAoM5COuSKQ066zkLAs85C0l+IQ2wp00I4ZdBCTX2LQ9iT\ny0IQ+MdCEGOLQ+zH2kI4wtBCLhONQ/IB3EIF59JC7bRgQyy620JmlhlDZKJlQ9ycuEIITB1D\nr+JiQ/y5tEKVmBND6eJ5Q3wuu0IoxwhDiQJ9Q+nltUJmWQlDQQqEQ1sRxUINyvNCQimFQ/52\nxUJh7uhC4sWFQ3syxUJQtuFCwImHQ4RYzUL4sslCcU6JQ1rXyUJQk85CLbKKQwpizEK0Y81C\nio+PQwfeykJjnc5C3eWMQ51HwUJYKcpC2lOKQzkyvkI4ccZCFCqLQzaD40IGwdFCSieNQ0Dd\n30JST9NCqcSQQ5jr30KZXdpCtd06Q5a1BENqaLBC/wAA//8AAP//AAD//wAA//8AAP//AAD/\n/wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA/wAA//8AAP//AAD//wAA\n//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//AAD//wAA//8AAP//\noCDw/5X8XENW+clCiVsSQ7VyZENs5L5Cp+8QQ2aHY0OyJrhC9xUTQ3uVekMf1MFCfpsKQ9xf\nekPBrbxCwJ4JQ1rng0NaacdCWqL1QjgihUPbMchCr6jsQrtghUN9XsZCOtzoQhcEiEM18tFC\nDbzRQmsliENXXtBCPe/NQvVmiUOasc1CgKDOQjrkikNOus5CwLPOQtJfiENsKdNCOGXQQk19\ni0PYk8tCEPjHQhBji0Psx9pCOMLQQi4TjUPyAdxCBefSQu20YEMsuttCZpYZQ2SiZUPcnLhC\nCEwdQ6/iYkP8ubRClZgTQ+nieUN8LrtCKMcIQ4kCfUPp5bVCZlkJQ0EKhENbEcVCDcrzQkIp\nhUP+dsVCYe7oQuLFhUN7MsVCULbhQsCJh0OEWM1C+LLJQnFOiUNa18lCUJPOQi2yikMKYsxC\ntGPNQoqPj0MH3spCY53OQt3ljEOdR8FCWCnKQtpTikM5Mr5COHHGQhQqi0M2g+NCBsHRQkon\n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\nAQAAAAAA1NNTP9TTUz/U01M/AACAPwAAAA=="}]},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n    \n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n#ifdef TEXTURE_rgb\n    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n#endif\n    \n#ifdef TEXTURE_rgba\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef TEXTURE_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n#endif\n    \n#ifdef TEXTURE_luminance\n    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n#endif\n    \n#ifdef TEXTURE_luminance_alpha\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n#endif\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
<p>You should be able to rotate (click and drag) and zoom (mouse wheel)
this figure.</p>
<p>Since this results in quite large html files when used with many
neurons, we will not use it further here. For now lets show a plot in
which we both select a subset of neurons and colour them according to
their glomerulus of origin.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 3d plot of neurons from olfactory glomeruli beginning with a D</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="co"># coloured by glomerulus</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>rval<span class="ot">=</span><span class="fu">plot3d</span>(Cell07PNs, <span class="at">subset=</span><span class="fu">grepl</span>(<span class="st">&quot;^D&quot;</span>, Glomerulus), <span class="at">col=</span>Glomerulus,</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">lwd=</span><span class="dv">2</span>, <span class="at">WithNodes=</span><span class="cn">FALSE</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># make a legend so that you know which colours match which glomerulus</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">plot.new</span>()</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="fu">with</span>(<span class="fu">attr</span>(rval,<span class="st">&#39;df&#39;</span>), <span class="fu">legend</span>(<span class="st">&#39;center&#39;</span>, <span class="at">legend =</span> <span class="fu">unique</span>(Glomerulus), <span class="at">fill=</span><span class="fu">unique</span>(col)))</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
</div>
<div id="putting-it-all-together" class="section level2">
<h2>Putting it all together</h2>
<p>To close this tutorial, lets do some morphological analysis of the
neurons in this dataset. There are second order olfactory projection
neurons originating from 4 different glomeruli in the
<code>Cell07PNs</code> sample dataset, each coming from a different
animal. We can ask whether their axon terminal arborisations in a brain
area called the lateral horn show any features that are distinctive for
different classes. This would be consistent with the hypothesis that
information from different glomeruli (i.e.olfactory channels) is
handled in a stereotyped way in this brain area.</p>
<p>Lets start by cutting out the arbour within the lateral horn from
all of the neurons. Well use a very simple approach of cutting at
X=250, although <strong>nat</strong> has more sophisticated ways to do
this e.g.by using 3D spaces defined by a surface mesh.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># note that we had to use OmitFailures=T due to a problem with the graph</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co"># structure of one neuron</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>lha<span class="ot">=</span><span class="fu">nlapply</span>(Cell07PNs, subset, X<span class="sc">&gt;</span><span class="dv">250</span>, <span class="at">OmitFailures =</span> T)</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Let&#39;s plot what we have colouring by glomerulus</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(lha, <span class="at">col=</span>Glomerulus, <span class="at">WithNodes=</span>F)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>Now we can get a basic statistical summary by axon arbour.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>lhstats<span class="ot">=</span><span class="fu">summary</span>(lha, <span class="at">include.attached.dataframe =</span> <span class="cn">TRUE</span>)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(lhstats<span class="sc">$</span>cable.length<span class="sc">~</span>lhstats<span class="sc">$</span>Glomerulus, <span class="at">log=</span><span class="st">&#39;y&#39;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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PNmRTz75xE444QS7++677a233rJChQrZXXfdZZs3b3aKtWzZsq64/v3726xZs2zJkiV25plnBqvQZynkqlWr2pgxY+yf//xn8BofIACBvCPACDjvWFNTPiAgM/Ctt95qZ5xxhlWpUsWNNEPnTBcvXmwXXXSRM+NWqlTJevXqZT/99JPrmeZiP/roI1uwYIE1aNDAtm3b5s6/+eab1qRJEytdurQzG7dr186++eYbd+1f//qXDRkyxH1WmhdffNF9fvzxx61GjRpWvHhx00h17NixwbnbMmXKuDlfv3xlOPHEE50p+vzzz3f5pdRlCtfIOlT5uoveH5mhx48fb82aNfNPZXj/4YcfXP/KlStnUuqdOnWyb7/9Npjus88+s4YNG7pRdevWrV3/Lr74YvcQsHTpUsdJZnLx1MNBqDzzzDNWr1491w61WRx8Eb8LL7zQ3n//fStfvrwrR4xV17Rp0/xk7l2jflkdwsnHH3/svoddu3aluaz6Xn/99eC5rFgHE/EBArlAAAWcC1ApMv8SGDFihFMyDz30kFOao0aNcspPPdq/f7+1b9/eKbvnnnvOjTqlJGTmlXTu3NkqV65sFStWdOZhzblOnz7dunTpYnXr1jUpnX79+tmyZcvcOeWRctR8rOSWW26xc88912bMmOGU1uWXX+7M2VJuMjGrTomv7KTINRoOJ6tWrbJffvnFKa1w13XuyiuvtKuuuirs5d9++81atmxpUmJiMWnSJPdAofZt3brV5dm7d6/JHN62bVs3xyxT+PLly+3SSy+1bt262XnnneceLqZMmWJScr5o/vqmm25yfZ86darjLHZvvPGGS/Lzzz+bHnRuvPFG+/Of/+wUux5evvjiizQmdiXWPHZmZvQ9e/aYHgTUl1DROd9UH4l1aD4+QyDHCXhP9wgECiSBt99+W+7AAW8k6frvKcxA/fr1A94PdpCHZ6YNeArUHS9atMil/+9//xu87o1uA3feeWfAG3G6c54iCXhKOnh9wIABgY4dOwaP9cFTaK6c3bt3u/MvvfSSO963b5879szJAdUbKt5IL6B0vngKKuApQ5fPG/0GPGUd8JSufzngKWt3LfScLn733XeBL7/8MuApSvfyHgYChw8fdvmOP/74wIQJE9xnvR977LEBT7m5Y/3xRpLunKcY3bnZs2e7OoYPHx5M481Nu3Oed3bwnPic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" /><!-- --></p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">boxplot</span>(lhstats<span class="sc">$</span>branchpoints<span class="sc">~</span>lhstats<span class="sc">$</span>Glomerulus)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAeAAAAEgCAYAAABsPKAhAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAAeCgAwAEAAAAAQAAASAAAAAATIqLkQAAPkVJREFUeAHtnQncTPX3xw8hS0hF1qwhZC1bCj9Zk620UIgkP6QNSf1KWSpE/KiEyhaSFpIUSihFhfr97HtkichO3f/9nP/vTjPz3HnuPHfmmTszz+e8XvPMnXvvd7nv586ce873fM83k2GKUEiABEiABEiABGJKIHNMW2NjJEACJEACJEACSoAKmDcCCZAACZAACXhAgArYA+hskgRIgARIgASogHkPkAAJkAAJkIAHBKiAPYDOJkmABEiABEiACpj3AAmQAAmQAAl4QIAK2APobJIESIAESIAEqIB5D5AACZAACZCABwSogD2AziZJgARIgARIgAqY9wAJkAAJkAAJeECACtgD6GySBEiABEiABKiAeQ+QAAmQAAmQgAcEqIA9gM4mSYAESIAESIAKmPcACZAACZAACXhAgArYA+hskgRIgARIgASogHkPkAAJkAAJkIAHBKiAPYDOJkmABEiABEiACpj3AAmQAAmQAAl4QIAK2APobJIESIAESIAEqIB5D5AACZAACZCABwSogD2AziZJgARIgARIgAqY9wAJkAAJkAAJeECACtgD6GySBEiABEiABKiAeQ+QAAmQAAmQgAcEqIA9gM4mSYAESIAESIAKmPcACZAACZAACXhAgArYA+hskgRIgARIgASogHkPkAAJkAAJkIAHBKiAPYDOJkmABEiABEiACpj3AAmQAAmQAAl4QIAK2APobJIESIAESIAEqIB5D5AACZAACZCABwSogD2AziZJgARIgARIgAqY9wAJkAAJkAAJeECACtgD6GySBEiABEiABKiAeQ+QAAmQAAmQgAcEqIA9gM4mSYAESIAESIAKmPcACZAACZAACXhAgArYA+hskgRIgARIgASogHkPkAAJkAAJkIAHBKiAPYDOJkmABEiABEiACpj3AAmQAAmQAAl4QIAK2APobJIESIAESIAEqIB5D5AACZAACZCABwSogD2AziZJgARIgARIgAqY9wAJkAAJkAAJeECACtgD6GySBEiABEiABKiAeQ+QAAmQAAmQgAcEqIA9gM4mSYAESIAESIAKmPcACZAACZAACXhAgArYA+hskgRIgARIgASogHkPkAAJkAAJkIAHBKiAPYDOJkmABEiABEiACpj3AAmQAAmQAAl4QIAK2APobJIESIAESIAEqIB5D5AACZAACZCABwSogD2AziZJgARIgARIgAqY9wAJkAAJkAAJeECACtgD6GySBEiABEiABKiAeQ+QAAmQAAmQgAcEqIA9gM4mSYAESIAESCBsBWwYho/WwYMH5cMPP5T9+/f79nGDBEiABEiABEggfAJhKeAJEyZIhQoVtNZt27ZJuXLlpE2bNlKsWDFZtGhR+K3xTBIgARIgARIgASXgqIA3b94sffv2lfr16wus4BEjRkiWLFlk1apV0qtXL+nevTtRkgAJkAAJkAAJpJFAJlOp/u1btik8bdo0GTp0qGzcuFGPFilSRFq2bCmvv/66uqALFy6s7wULFrQpzV0kQAIkQAIkQAJ2BBwt4N9++03y58+vZdevXy/79u2Tpk2b6uezZ8+qNZwzZ067urmPBEiABEiABEggBAFHBVylShVZs2aNfPnllzJq1CjJkSOHNG7cWI4fP66Wca1atSRPnjwhquduEiABEiABEiABOwJZ7Hb672vYsKG6nBs0aKC7x40bJ7lz55auXbvK/PnzZeLEif6nc5sESIAESIAESCAMAo5jwKdPn5ajR4/qK2/evFK0aFGtdu3atbqNsWEEaFFIgARIgARIgATCJ+Dogl66dKm0atVKKlas6FO+qL5GjRqCCGlYxkeOHAm/RZ5JAiRAAiRAAiQgthbwmTNnpFOnTnLixAk5dOiQbNmyRerWrRuAC8HTsH6hfH///XfJlClTwHF+IAESIAESIAESCE3A1gLOnj27NGvWTLJly6ZRzlCu2PZ/4Zx69erJe++9R+Ubmi+PkAAJkAAJkIAtAVsL2P/Mb7/9VqZPny5jx471381tEiABEiABEiCBCAg4KuAI6mZREiABEiABEiCB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2J49e3R/RkrE4c/UTB9pmIpXk2mYbvwANkjE4X+u/7Y5hUTPRbIK07vgO8+MKDVM74Rh5jYOqCsRP1iJOPyvOzVeoRJxOF27aeEZpiIKOA2JKNCuOc7s229miNJ9SDhhiamcwk44YZWJp3ck0kECGPMB2TBd0AFdM+foatIN/B/sxAyoMkxFqglNgo+bmd203uD95kwJwwyGU2bgawa5KXszUj34VH4Og0AmnGOCpJAACXhIAONq8EogqYSbKGoPu86mMyABLNSAGAZYxRT3BKiA3bNjSRIgARIgARJwTYDzgF2jY0ESIAESIAEScE+ACtg9O5YkARIgARIgAdcEqIBdo2NBEiABEiABEnBPgArYPTuWJAESIAESIAHXBKiAXaNjQRIgARIgARJwT4AK2D07liQBEiABEiAB1wSogF2jY0ESIAESIAEScE+ACtg9O5YkARIgARIgAdcEqIBdo2NBEiABEiABEnBPgArYPTuWJAESIAESIAHXBKiAXaNjQRIgARIgARJwT4AK2D07liQBEiABEiAB1wSogF2jY0ESIAESIAEScE+ACtg9O5YkARIgARIgAdcEqIBdo2NBEiABEiABEnBPgArYPTuWJAESIAESIAHXBKiAXaNjQRIgARIgARJwT4AK2D07liQBEiABEiAB1wSogF2jY0ESIAESIAEScE+ACtg9O5YkARIgARIgAdcEqIBdo2NBEiABEiABEnBPgArYPTuWJAESIAESIAHXBKiAXaNjQRIgARIgARJwT4AK2D07liQBEiABEiAB1wSogF2jY0ES8JbAhQsX5IUXXpA+ffrI6dOnHTtz9uxZ2b17txiG4XguTyABEkh/AlTA6c+YLcQpgQ8//FAyZcokv/76q/Ywb968MmLEiIh6e/jwYXn77bfTVMdff/0lr776qpw5cybscuhnwYIF5fnnn5dJkybJlVdeKePGjUtRHkp34MCBUqdOHcmTJ48UL15ccufOLU2bNpUdO3YEnH/xxRfb1hFwUpx/SIZriHPE7F4UCVABRxEmqyKBHj16yOzZs9MEYs6cOfLPf/5T/vzzz7DKfffddzJgwADp27evvPbaazJo0CB59NFH5cknn5RDhw756kB9HTt2VKV66623ymeffSY///yzTJw4UZVv1apVZfPmzb7zuUECJBBbAlli2xxbI4HkJgBrFlZ1WgRl0iLLly+X7NmzS79+/eT999+XzJkzy+OPPy579+5VxZo/f36t7uGHH5aFCxfKmjVrpEKFCr4msA2FXKZMGRk1apS8/vrrvmPcIAESiB0BWsCxY82WEoAA3MC9e/eWwoULS+nSpdXS9B8z/fbbb6V+/frqxi1ZsqR06dJFjhw5oleGsdgvvvhCVqxYIdddd53s379f98+bN0/q1asnl112mbqNmzdvLv/973/12EcffSRPPfWUbuOcadOm6fb48eOlXLlykitXLoGlOnr0aN/Y7RVXXKFjvlb9KHDJJZeoK7pmzZpaHkodrnBY1v7KVw+af+CGfuWVV6RBgwbWrhTvBw4c0OsrUqSIQKm3bt1atm3b5jvv66+/ltq1a6tV3bhxY72+Jk2a6EPA2rVrlRPc5OCJhwN/mTx5slSrVk37gT6DgyXgV7duXVm8eLEULVpU6wFjtDVr1izrNH2H1Q+vg518+eWX+n/47bffAg6jvXfffde3LzXWvpO4QQLpQIAKOB2gssrEJTB06FBVMsOGDVOl+dJLL6nywxWdPHlSWrRoocruzTffVKsTSgJuXkibNm2kVKlSUqJECXUPY8x17ty5ctttt0mVKlUESqdnz57y448/6j6UgXLEeCykV69eUqNGDZk/f74qrTvuuEPd2VBucDGjTYil7KDIYQ3bycaNG+WPP/5QpWV3HPvuuusuufvuu20Pnz9/Xho1aiRQYmAxYcIEfaBA//bt26dljh8/LnCHN2vWTMeY4Qpft26dtG3bVtq3by/XX3+9PlxMnTpVoOQswfj1gw8+qNc+ffp05Qx27733np5y7NgxwYPOAw88IDfddJMqdjy8/PDDDwEudpyMcexQbvTff/9d8CCAa/EX7LNc9U6s/ctxmwSiTsB8uqeQQIYk8MEHHyAc2DAtSb1+U2Ea1atXN8wfbB8P001rmApUP69evVrP//77733HTevWeOyxxwzT4tR9piIxTCXtO/7II48YrVq18n3GhqnQtJ6jR4/q/hkzZujnEydO6GfTnWygXX8xLT0D51liKijDVIZazrR+DVNZG6bStQ4bprLWY/77cHD79u3G+vXrDVNR6st8GDDOnTun5bJly2aMHTtWt/F+0UUXGaZy08/4Y1qSus9UjLpv0aJF2saQIUN855hj07rPjM727QOfa6+9Vj/jmsH5vvvu8x3Hxp13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" /><!-- --></p>
<p>We can also calculate the median position of the arbour for each
neuron and add that to the lhstats database</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># quick function to calculate centroid</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>arbour_centroid <span class="ot">&lt;-</span> <span class="cf">function</span>(n) {</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># extract location of all points in neuron object</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  xyzs<span class="ot">=</span><span class="fu">xyzmatrix</span>(n)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># median in all 3 axes (=&gt;2 columns)</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">apply</span>(xyzs, <span class="dv">2</span>, median)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="co"># note that we have to transpose because sapply results in x,y,z rows</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>centroids<span class="ot">=</span><span class="fu">t</span>(<span class="fu">sapply</span>(lha, arbour_centroid))</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>lhstats<span class="ot">=</span><span class="fu">cbind</span>(lhstats, centroids)</span></code></pre></div>
<p>Finally we can take these data and see how well we can predict the
identity of the neuron (i.e.its glomerulus) based on the statistics of
the axon arbour in the lateral horn. We use the linear discriminant
analysis (provided by the function <code>lda</code> in recommended
package <code>MASS</code>). This also runs a leave one out
cross-validation to get a more robust initial estimate of prediction
error.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(MASS)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>lda.fit <span class="ot">=</span> <span class="fu">lda</span>(Glomerulus <span class="sc">~</span> cable.length<span class="sc">+</span>X<span class="sc">+</span>Y<span class="sc">+</span>Z<span class="sc">+</span>branchpoints, lhstats, <span class="at">CV =</span> T)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(lda.fit<span class="sc">$</span>class, lhstats<span class="sc">$</span>Glomerulus)</span></code></pre></div>
<pre><code>##       
##        DA1 DL3 DP1m VA1d
##   DA1   10   2    0    1
##   DL3    0   7    0    0
##   DP1m   0   0    8    0
##   VA1d   1   0    0   10</code></pre>
<p>The prediction accuracy of 35/39 i.e.just under 90% is already very
good compared with a chance level of about 25% for these 4 classes.</p>
</div>
<div id="learning-more" class="section level2">
<h2>Learning More</h2>
<p>We hope this tutorial will provide you with a good foundation for
further use of the <strong>nat</strong> and related packages. Please
visit the main <a href="http://natverse.org/nat/index.html">nat
README</a> for suggestions of resources to learn more and solve
problems. You may also find that some time spent reading Hadley
Wickhams <a href="http://adv-r.had.co.nz/">Advanced R</a> is a
worthwhile investment. I recommend the first 7 chapters (Introduction to
OO field guide) as material that will be helpful for anyone who intends
to carry out a significant project using R.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
